# Input Design: Iterator (コードドクターシリーズ連携案)

## 選定結果

| 要素 | 採用案 | スコア |
|------|--------|--------|
| テーマ | ページネーションAPIの透過的統合（革新） | 21/25 |
| 患者 | 力技のSaaS連携エンジニア（王道と革新のハイブリッド） | 20/25 |
| 症状 | 慢性ページネーション管理不全（革新） | 21/25 |

---

## 提案のコンテキスト

過去のシリーズで「本棚アプリ」として王道的なIterator（配列のラップ）を扱っているため、今回は**リモートリソースのストリーミング取得（APIページネーション）**への適用に焦点を当てます。これにより、メモリ効率と状態管理の分離というIteratorパターンの真価を伝えます。
また、**Perl v5.36以降（signatures, postfix dereference）**の強力な機能を用いることで、クロージャを用いた美しいIterator実装をハイライトします。

---

## テーマ詳細
**選定テーマ：ページネーションAPIの透過的統合（革新）**
- **概要**: 100件ずつしか返却しない外部SaaSのREST APIを、あたかも1つの巨大なリストオブジェクトのように `while (my $item = $iter->next)` で回せるようにする。
- **パターンとの接点**: 次のページを取得するための `next_cursor` や `page` の状態管理、およびHTTPリクエストのページング処理を、イテレータの内部に完全に隠蔽する。
- **読者像**: 外部APIと連携するバッチ処理や、データ同期を行うバックエンドエンジニア。

## 患者詳細
**選定患者：力技のSaaS連携エンジニア（王道と革新のハイブリッド）**
- **属性**: Webバックエンド歴3年。
- **性格**: スピード重視、「とりあえず全部取ってから考える」主義。
- **背景**: 1日1万件のデータ同期バッチを書いたが、取得時に一旦全件配列に `push` してから別関数に渡す設計にしたため、データ量増加と共にメモリ枯渇（OOM Killer）やタイムアウトが頻繁に発生している。
- **主訴**: 「SaaSのAPIが100件ずつしか返さないのが悪いんです！全件返すAPIなら一瞬で終わるのに！」
- **コメディポテンシャル**: 「全件取得のために配列をグローバル変数に置く」「ページネーションループの脱出条件をミスって無限リクエストを飛ばし、SaaS側からRate Limitの雷を落とされる」といったドタバタ劇。

## 症状詳細
**選定症状：慢性ページネーション管理不全 と 急性メモリ横領症（複合・革新）**
- **技術的症状**: `while` ループの外に `$next_token` を置き、ループ内でAPIを叩いて配列に `push` し続ける巨大なメソッド。状態変数が漏れ出し、処理とデータ取得が密結合している。
- **医療メタファー**: 外部器官（SaaS API）からの栄養（データ）を一度に全量胃（メモリ）に詰め込もうとする「急性異所性過食症」。
- **重症度**: 重症（本番バッチ停止・SaaS側のAPI制限抵触のリスク）
- **Before/Afterの見込み**:
  - Before: 取得ロジックと処理ロジックが絡み合った数百行の巨大メソッド。メモリ上に全件保持。
  - After: 完全に分離。クロージャで状態を保持する `$iter->next` によって、必要になる都度1件（または内部バッファから1件）ずつ返し、メモリ消費は常に一定。
- **読者の「あっ」ポイント**: APIのページネーション処理を書くたびに、同じようなループやトークン管理コードをコピペ量産していることに気づく瞬間。

---

## 評価サマリー

### テーマ評価
| 評価軸 | 案A（王道：巨大ログ解析） | 案B（革新：ページネーションAPI） | 案C（逆転：多次元ネスト平坦化） |
|--------|:-----------:|:-----------:|:-----------:|
| ① 読者共感度 | 5 | 5 | 3 |
| ② メタファー適合度 | 4 | 4 | 4 |
| ③ コメディ発展性 | 3 | 4 | 5 |
| ④ 教育価値 | 4 | 5 | 4 |
| ⑤ 差別化 | 2 | 4 | 4 |
| **合計** | 18 | **22** | 20 |
| **評価理由** | 既視感が強い | 実務的でモダン | かなり限定的 |

### 患者評価
| 評価軸 | 案A（王道：力技若手） | 案B（革新：再帰魔術師） | 案C（逆転：ネスト古参） |
|--------|:-----------:|:-----------:|:-----------:|
| ① 読者共感度 | 5 | 3 | 4 |
| ② メタファー適合度 | 4 | 3 | 4 |
| ③ コメディ発展性 | 4 | 5 | 4 |
| ④ 教育価値 | 4 | 4 | 3 |
| ⑤ 差別化 | 3 | 4 | 4 |
| **合計** | **20** | 19 | 19 |
| **評価理由** | OOMあるある | 知識偏重タイプ | 悪くないが重い |

### 症状評価
| 評価軸 | 案A（全件配列化） | 案B（APIトークン漏出） | 案C（多重ループ） |
|--------|:-----------:|:-----------:|:-----------:|
| ① 読者共感度 | 5 | 5 | 3 |
| ② メタファー適合度 | 4 | 4 | 3 |
| ③ コメディ発展性 | 3 | 4 | 4 |
| ④ 教育価値 | 4 | 5 | 3 |
| ⑤ 差別化 | 3 | 4 | 4 |
| **合計** | 19 | **22** | 17 |
| **評価理由** | 典型的な問題 | 構造的依存の解決 | やや古臭いコード |

### 相乗効果の検証
- **テーマ（案B） × 患者（案A）**: API連携で力技（全件メモリ乗せ）をやってしまうのは、実務あるあるとして非常に共感度が高い。
- **テーマ（案B） × 症状（案B＋Aの複合）**: トークン管理の手間を嫌がり、一つの関数で無理やり全件取得して配列化する（症状）という流れが極めて自然。
- **結論**: 「ページネーションAPI」というテーマに対し、「全件一括配列化によるメモリ枯渇＋トークン管理のスパゲッティ化」を抱えた「力技エンジニア」を組み合わせるのが最適解。

---

## 不採用案（参考）

- **案A（王道）**: 巨大ログファイルの行処理。典型的なIteratorのユースケースだが、やや古典的でありPerlの強みを出すには少しインパクトに欠ける。本や車などと同列の古さ。
- **案C（逆転）**: 複雑なJSONデータの平坦化イテレート。再帰を含むイテレータの実装になり、難易度が高く本来の「Iteratorパターンの本質・使い所」から少しブレる恐れがある。
