---
date: 2026-01-07T17:56:57+09:00
description: シリーズ記事「Strategyパターンを学ぶ新シリーズ」の連載構造案3つ（案A/B/C）- 既存ディスパッチャーシリーズとは異なるアプローチ
draft: true
image: /favicon.png
title: '連載構造案 - Strategyパターン新シリーズ（全10〜12回）'
---

# 連載構造案：Strategyパターンを学ぶ新シリーズ

調査結果: `content/warehouse/strategy-pattern.md` に基づく

## 前提情報

- **技術スタック**: Perl v5.36以降（signatures対応）、Mooによるオブジェクト指向プログラミング
- **想定読者**: Perl入学式卒業したばかりの入門者
- **想定ペルソナ**: 「Mooで覚えるオブジェクト指向プログラミング」シリーズを読了してオブジェクト指向プログラミングを身に付けたい、モダンなPerlを使ってみたい
- **学習目標**: 
  - オブジェクト指向プログラミングの原則を深く学べる
  - SOLID原則を深く学べる
  - 自然にStrategyパターンを覚えられる
  - デザインパターンの名前が覚えられる
- **位置づけ**: 「Mooで覚えるオブジェクト指向プログラミング」シリーズの続編
- **ストーリー**: 知っている知識で動くプログラムを作成 → 機能を追加していくと問題が発覚 → SOLID原則やデザインパターンを適用して問題を解決
- **制約**: 
  - 1記事1概念
  - コード例2つまで
  - 回の最後には完成コードを示す（原則1つのスクリプトファイル）
  - デザインパターンの名前はシリーズ名に敢えて出さない
  - **既存シリーズ「Mooを使ってディスパッチャーを作ってみよう」とは完全に異なるテーマ・題材を使用**

### 既存シリーズとの差別化

| 項目 | 既存シリーズ（ディスパッチャー） | 新シリーズ |
|------|-------------------------------|-----------|
| 題材 | ルーター/ディスパッチャー | 別のアプリケーション |
| パターンの見せ方 | URLルーティングによるハンドラー切り替え | 別の切り替えシナリオ |
| 読者層 | 同じ | 同じ |

### 前提知識（前シリーズで習得済み）

| 前シリーズで学んだこと | 本シリーズでの活用 |
|----------------------|-------------------|
| `has`と`sub`でクラスを定義 | Strategy/Contextクラスの定義 |
| `new`でオブジェクト生成 | Strategyオブジェクトの生成 |
| `is => 'ro'/'rw'`でアクセス制御 | 動的なStrategy切り替え |
| `required`と`default` | Strategyの初期化 |
| カプセル化 | アルゴリズムの隠蔽 |
| 複数クラスの連携 | Context-Strategy関係 |
| `extends`による継承 | 共通ロジックの継承（必要に応じて） |
| オーバーライド | Strategyメソッドの実装 |
| `Moo::Role`と`with`によるロール | Strategyインターフェースの定義 |
| `handles`による委譲 | ContextからStrategyへの処理委譲 |
| `isa`/`does`による型制約 | Strategy型の検証 |

---

## 案A: 「データエクスポーター」アプローチ

### シリーズ名案

**「Mooを使ってデータエクスポーターを作ってみよう」**（全10回）

### 特徴・アプローチ

アドレス帳や商品リストなどのデータを、**CSV、JSON、YAML**など複数のフォーマットで出力する「データエクスポーター」を作成します。最初はif/elseで出力形式を切り替える実装から始め、形式の追加により問題が発覚し、最終的にStrategyパターンに到達します。

### メリット

- **実用性が高い**: データのエクスポートは実務で頻出するタスク
- **視覚的にわかりやすい**: 出力結果が異なるため、Strategyの切り替えが目に見える
- **モジュールとの連携**: JSON::PP、YAML::Tiny、Text::CSVなどCPANモジュールの紹介も可能
- **差別化が明確**: ディスパッチャー（ルーティング）とは完全に異なるドメイン
- **段階的な複雑化が容易**: CSV→JSON→YAML→XML→カスタム形式と自然に拡張できる

### デメリット

- **CPANモジュール依存**: JSON、YAMLなどのモジュールが必要（インストール手順が必要）
- **データ構造の理解が前提**: ハッシュリファレンス、配列リファレンスの知識が必要
- **出力の検証が必要**: 出力フォーマットが正しいかの確認方法の説明が必要

### 連載構造

| 回 | タイトル | 新しい概念 | ストーリー | コード例1 | コード例2 | 推奨タグ |
|---|---------|-----------|-----------|----------|----------|---------|
| 第1回 | アドレス帳をファイルに保存しよう | if/elseでの形式切り替え | アドレス帳データをCSVとJSONで保存したい。if/elseで形式を切り替える実装を行う | if/elseでCSVとJSONを切り替えるコード | 実行結果（CSV出力、JSON出力） | perl, moo, export, csv |
| 第2回 | 新しい形式を追加すると大変！ | if/elseの肥大化問題 | YAMLとXML形式も追加したい。if/elseがどんどん増えて保守が難しくなる | if/elseが肥大化したコード | 問題点の整理 | perl, refactoring |
| 第3回 | 出力処理を別のクラスに分けよう | ハンドラークラス分離 | CSV出力をCsvExporterクラスに切り出す。責任の分離を体験 | CsvExporterクラスの作成 | JsonExporterクラスの作成 | perl, moo, class |
| 第4回 | 共通の約束を決めよう | requires（Moo::Role） | 各エクスポータークラスに「必ずexportメソッドを持つ」という約束をRoleで定義 | ExporterRoleの作成（requires 'export'） | エクスポータークラスでのwith適用 | perl, moo-role, interface |
| 第5回 | エクスポーターを管理するクラスを作ろう | Contextクラス | エクスポーターを保持するDataExporterクラス（Context）を作成 | DataExporterクラスとhas exporter定義 | export_dataメソッドの実装 | perl, moo, context |
| 第6回 | 実行時に形式を切り替えよう | 動的切り替え（is => 'rw'） | 実行時にCSV→JSON→YAMLと切り替える機能を追加 | set_exporterメソッドの追加 | 動的切り替えのデモコード | perl, moo, dynamic |
| 第7回 | 型チェックでバグを防ごう | does制約 | 間違ったオブジェクトが設定されないよう、does制約を追加 | does => 'ExporterRole'の追加 | 型エラーのデモと対処 | perl, moo, type-check |
| 第8回 | 形式名から自動で選ぼう | Factory的生成 | "csv"、"json"などの文字列から自動でエクスポーターを選択する仕組み | exporter_forメソッドの実装 | 形式名からエクスポーター選択 | perl, moo, factory |
| 第9回 | 完成！データエクスポーター | 統合と完成 | 全機能を統合してエクスポーターを完成。動作確認とテスト | 完成したDataExporterクラス全体 | 各形式での出力確認 | perl, moo, exporter |
| 第10回 | これがデザインパターンだ！ | Strategyパターン | 作ってきたものが「Strategyパターン」だったことを明かす。SOLID原則との関係も解説 | Strategyパターンの構造図解 | 他のパターンへの展望 | perl, design-patterns, strategy |

### 差別化ポイント

- **ディスパッチャーシリーズとの違い**: URLルーティングではなく「データ出力形式」の切り替え
- **出力の可視性**: 実行結果が異なるフォーマットで目に見えるため、Strategyの効果が実感しやすい
- **実務との関連**: データのエクスポート/インポートは多くのシステムで必要な機能

---

## 案B: 「テキストフォーマッター」アプローチ

### シリーズ名案

**「Mooを使ってテキストフォーマッターを作ってみよう」**（全10回）

### 特徴・アプローチ

ブログ記事やドキュメントのテキストを、**Markdown、HTML、プレーンテキスト**など複数の形式で整形する「テキストフォーマッター」を作成します。見出し、リスト、リンクなどの要素を各形式に変換する処理をStrategyパターンで実装します。

### メリット

- **身近なテーマ**: ブログやドキュメント作成は多くの人が経験している
- **変換結果が明確**: 同じ入力に対して異なる出力が得られるため、Strategyの効果が目に見える
- **拡張性のデモが容易**: 新しい形式（reStructuredText、AsciiDocなど）の追加が自然
- **CPANモジュール不要**: 基本的な文字列操作だけで実装可能

### デメリット

- **ドメイン知識が必要**: Markdown、HTML、プレーンテキストの記法理解が前提
- **テスト・検証が難しい**: 正しい変換結果かどうかの確認が複雑
- **実用性が限定的**: 実際にはText::Markdownなど既存ツールを使うことが多い

### 連載構造

| 回 | タイトル | 新しい概念 | ストーリー | コード例1 | コード例2 | 推奨タグ |
|---|---------|-----------|-----------|----------|----------|---------|
| 第1回 | テキストをHTMLに変換しよう | if/elseでの形式切り替え | ブログ記事をHTMLとプレーンテキストに変換したい。if/elseで形式を切り替える | if/elseで変換形式を切り替えるコード | 見出しとリストの変換例 | perl, moo, html |
| 第2回 | Markdown形式を追加すると大変！ | if/elseの肥大化問題 | Markdown出力も追加。条件分岐が複雑化し、保守困難に | if/elseが肥大化したコード | 問題点の整理 | perl, refactoring |
| 第3回 | 変換処理を別のクラスに分けよう | ハンドラークラス分離 | HTML変換をHtmlFormatterクラスに切り出す | HtmlFormatterクラスの作成 | PlainFormatterクラスの作成 | perl, moo, class |
| 第4回 | 共通の約束を決めよう | requires（Moo::Role） | 各フォーマッタークラスに共通のformatメソッドを定義 | FormatterRoleの作成（requires 'format'） | フォーマッタークラスでのwith適用 | perl, moo-role, interface |
| 第5回 | フォーマッターを管理するクラスを作ろう | Contextクラス | TextFormatterクラス（Context）を作成 | TextFormatterクラスとhas formatter定義 | format_textメソッドの実装 | perl, moo, context |
| 第6回 | 実行時に形式を切り替えよう | 動的切り替え（is => 'rw'） | 実行時にHTML→Markdown→プレーンと切り替え | set_formatterメソッドの追加 | 動的切り替えのデモコード | perl, moo, dynamic |
| 第7回 | 型チェックでバグを防ごう | does制約 | 間違ったオブジェクトが設定されないよう制約を追加 | does => 'FormatterRole'の追加 | 型エラーのデモと対処 | perl, moo, type-check |
| 第8回 | 形式名から自動で選ぼう | Factory的生成 | "html"、"markdown"などの文字列から自動でフォーマッターを選択 | formatter_forメソッドの実装 | 形式名からフォーマッター選択 | perl, moo, factory |
| 第9回 | 完成！テキストフォーマッター | 統合と完成 | 全機能を統合してフォーマッターを完成 | 完成したTextFormatterクラス全体 | 各形式での変換確認 | perl, moo, formatter |
| 第10回 | これがデザインパターンだ！ | Strategyパターン | 作ってきたものが「Strategyパターン」だったことを明かす | Strategyパターンの構造図解 | 他のパターンへの展望 | perl, design-patterns, strategy |

### 差別化ポイント

- **ディスパッチャーシリーズとの違い**: ルーティングではなく「テキスト変換」の切り替え
- **変換処理の理解**: 入力→処理→出力の流れがStrategyパターンの本質を理解しやすい
- **外部依存なし**: CPANモジュールなしで実装可能なため、セットアップが簡単

---

## 案C: 「通知システム」アプローチ

### シリーズ名案

**「Mooを使って通知システムを作ってみよう」**（全12回）

### 特徴・アプローチ

システムからの通知を**メール、ファイルログ、コンソール出力**など複数の方法で送信する「通知システム」を作成します。通知方法を動的に切り替えられるようにしながら、Strategyパターンを学びます。実務でよく使われる「通知」というテーマで、実践的なスキルも身につきます。

### メリット

- **実務での頻出パターン**: 通知方法の切り替えは多くのシステムで必要
- **外部サービスとの連携イメージ**: メール、Slack、LINEなど様々なサービスへの拡張を想像しやすい
- **テストしやすい**: ファイルやコンソールへの出力は確認が簡単
- **段階的な複雑化が自然**: コンソール→ファイル→メール（モック）と難易度を上げやすい
- **実世界のユースケース**: 本番/開発環境での通知方法切り替えなど、現実的なシナリオ

### デメリット

- **メール送信の実装は複雑**: 実際のメール送信はセットアップが大変（モックで対応）
- **外部サービス依存**: Slack、LINE等は認証が必要（本シリーズでは扱わない）
- **抽象度が高め**: 「通知」という概念自体がやや抽象的

### 連載構造

| 回 | タイトル | 新しい概念 | ストーリー | コード例1 | コード例2 | 推奨タグ |
|---|---------|-----------|-----------|----------|----------|---------|
| 第1回 | システムからお知らせを送ろう | if/elseでの通知切り替え | コンソール出力とファイル書き込みで通知を送りたい。if/elseで切り替え | if/elseで通知方法を切り替えるコード | 実行結果（コンソール、ファイル） | perl, moo, notification |
| 第2回 | メール通知を追加すると大変！ | if/elseの肥大化問題 | メール通知も追加したい。条件分岐が複雑化し、保守困難に | if/elseが肥大化したコード | 問題点の整理 | perl, refactoring |
| 第3回 | 通知処理を別のクラスに分けよう | ハンドラークラス分離 | コンソール通知をConsoleNotifierクラスに切り出す | ConsoleNotifierクラスの作成 | FileNotifierクラスの作成 | perl, moo, class |
| 第4回 | 共通の約束を決めよう | requires（Moo::Role） | 各通知クラスに「必ずnotifyメソッドを持つ」という約束をRoleで定義 | NotifierRoleの作成（requires 'notify'） | 通知クラスでのwith適用 | perl, moo-role, interface |
| 第5回 | 通知を管理するクラスを作ろう | Contextクラス | NotificationServiceクラス（Context）を作成 | NotificationServiceクラスとhas notifier定義 | send_notificationメソッドの実装 | perl, moo, context |
| 第6回 | 実行時に通知方法を切り替えよう | 動的切り替え（is => 'rw'） | 実行時にコンソール→ファイル→メールと切り替え | set_notifierメソッドの追加 | 動的切り替えのデモコード | perl, moo, dynamic |
| 第7回 | 型チェックでバグを防ごう | does制約 | 間違ったオブジェクトが設定されないよう制約を追加 | does => 'NotifierRole'の追加 | 型エラーのデモと対処 | perl, moo, type-check |
| 第8回 | 複数の方法で同時に通知しよう | 複数Strategy保持 | コンソールとファイルの両方に同時通知する機能を追加 | notifiersを配列で保持 | 複数通知のループ処理 | perl, moo, multi-strategy |
| 第9回 | 通知方法を自動で選ぼう | Factory的生成 | "console"、"file"などの文字列から自動で通知クラスを選択 | notifier_forメソッドの実装 | 通知方法名からクラス選択 | perl, moo, factory |
| 第10回 | 開発と本番で切り替えよう | 環境による切り替え | 開発環境ではコンソール、本番環境ではメール通知に切り替え | 環境変数による切り替え | 設定ファイルによる切り替え | perl, moo, environment |
| 第11回 | 完成！通知システム | 統合と完成 | 全機能を統合して通知システムを完成 | 完成したNotificationServiceクラス全体 | 各通知方法での動作確認 | perl, moo, notification |
| 第12回 | これがデザインパターンだ！ | Strategyパターン | 作ってきたものが「Strategyパターン」だったことを明かす。Observer等関連パターンも紹介 | Strategyパターンの構造図解 | 他のパターン（Observer等）への展望 | perl, design-patterns, strategy |

### 差別化ポイント

- **ディスパッチャーシリーズとの違い**: ルーティングではなく「通知方法」の切り替え
- **実務との関連が強い**: 通知システムは多くのアプリケーションで必要
- **発展性が高い**: 複数通知、環境切り替えなど実践的な拡張ができる
- **12回でより深い内容**: 環境切り替えや複数Strategy保持など発展的な内容を含む

---

## 推薦案とその理由

### 推薦：案A「データエクスポーター」

### 推薦理由

1. **ペルソナとの適合性**
   - 「Mooで覚えるオブジェクト指向プログラミング」で学んだアドレス帳などのデータを活用できる
   - 実際に手元でCSVやJSONファイルを生成・確認できるため、達成感がある
   - CPANモジュール（JSON::PP等）との連携を学べるため、実践的なPerl力が身につく

2. **検索意図との適合性**
   - 「Perl CSV出力」「Perl JSON変換」などの検索でたどり着く可能性がある
   - データ形式の変換は初心者がよく検索するトピック
   - 実用的なスクリプト作成の需要にマッチ

3. **学習効果**
   - 出力結果が目に見えるため、Strategyパターンの効果を実感しやすい
   - 「形式を追加するたびにif/elseが増える」という問題が直感的
   - 最終的に「これがStrategyパターンだった」という気づきが自然

4. **既存シリーズとの差別化**
   - ディスパッチャー（URLルーティング）とは完全に異なるドメイン
   - 出力形式という「データの変換」に焦点を当てる点が新鮮
   - 同じStrategyパターンを別の角度から学べる

5. **内部リンクの活用**
   - 「Mooで覚えるオブジェクト指向プログラミング」シリーズの第10回（Moo::Role）、第11回（委譲）、第12回（型制約）と密接にリンク可能
   - JSON、YAML関連の既存記事があればリンク可能

### 代替案の選択指針

- **案B（テキストフォーマッター）が適しているケース**:
  - ブログやドキュメント作成に興味がある読者層を想定する場合
  - CPANモジュールのインストールを最小限にしたい場合
  - Markdown、HTML変換に特化したシリーズを作りたい場合

- **案C（通知システム）が適しているケース**:
  - より実務的・システム寄りの内容を求める読者層を想定する場合
  - 12回と長めのシリーズで、複数Strategy保持や環境切り替えなど発展的な内容まで扱いたい場合
  - Observer パターンなど他のパターンへの橋渡しも視野に入れる場合

---

## 付記

### 各案の比較表

| 項目 | 案A（データエクスポーター） | 案B（テキストフォーマッター） | 案C（通知システム） |
|-----|--------------------------|---------------------------|-------------------|
| **回数** | 10回 | 10回 | 12回 |
| **題材** | CSV/JSON/YAML出力 | HTML/Markdown変換 | コンソール/ファイル/メール通知 |
| **実用性** | ◎ 高い | ○ 中程度 | ◎ 高い |
| **CPANモジュール依存** | ○ 一部必要（JSON::PP等） | ◎ 不要 | ○ 一部必要（メール送信等） |
| **視覚的なわかりやすさ** | ◎ 出力ファイルが異なる | ◎ 変換結果が異なる | ○ 出力先が異なる |
| **既存シリーズとの差別化** | ◎ 完全に異なるドメイン | ◎ 完全に異なるドメイン | ◎ 完全に異なるドメイン |
| **発展性** | ○ 新形式追加 | ○ 新形式追加 | ◎ 複数通知、環境切り替え |

### シリーズ名の決定について

シリーズ名にはデザインパターンの名前（Strategy）を**敢えて出さない**方針に従い、以下の形式を推奨：

- **案A**: 「Mooを使ってデータエクスポーターを作ってみよう」
- **案B**: 「Mooを使ってテキストフォーマッターを作ってみよう」
- **案C**: 「Mooを使って通知システムを作ってみよう」

いずれも具体的なアプリケーション名を使用し、Strategyパターンは最終回で初めて明かす構成。

### 前シリーズへのリンク

各回の冒頭で、関連する前シリーズの記事へのリンクを設置することを推奨：

| 本シリーズの回 | 関連する前シリーズの回 | トピック |
|--------------|---------------------|---------|
| 第3回 | 第7回「複数クラスの連携」 | クラスの分割と連携 |
| 第4回 | 第10回「ロール」 | Moo::Roleとwith |
| 第5回 | 第11回「委譲」 | handlesの使い方 |
| 第6回 | 第4回「読み書きを制限する」 | is => 'rw' |
| 第7回 | 第12回「型チェック」 | does制約 |

### 発展的な内容

本シリーズ完了後の発展として、最終回で以下のトピックを予告：

- **Commandパターン**: 操作自体をオブジェクトにする
- **Stateパターン**: オブジェクトの状態に応じて振る舞いを変える
- **Template Methodパターン**: アルゴリズムの骨格を定義し、一部をサブクラスで実装

---

**作成日**: 2026年1月7日  
**担当エージェント**: perl-monger エージェント

---

## レビュー履歴

### 第1版（2026-01-07）

- 作成担当: perl-monger エージェント
- 3案（データエクスポーター、テキストフォーマッター、通知システム）を作成
- 推薦案: 案A（データエクスポーター）
