# パターンDNA解析: Singleton

> **生成日**: 2026-02-03
> **対象ワークフロー**: `/planning-v3`
> **ステータス**: 提案中

---

## 1. 症状カタログ（問診票）

患者（ユーザーコード）から検出された症状リストです。

| # | 症状名 | 説明 | 深刻度 | 処方候補 |
|---|--------|------|--------|---------|
| 1 | **無限インスタンス増殖症** | 設定オブジェクトや接続クラスが `new` さえすればいくらでも生成されてしまう状態。メモリ圧迫や不整合の原因となる。 | 中症 | Singleton |
| 2 | **グローバル汚染症候群** | どこからでもアクセスしたいデータをグローバル変数 (`our $DATA`) で共有しており、誰がいつ書き換えたか追跡不能になっている。 | 重症 | Singleton (Capsule) |
| 3 | **リソース競合不全症** | ログファイルやDB接続など、排他制御が必要なリソースに対して複数のインスタンスが同時にアクセスを試み、競合を起こしている。 | 重症 | Singleton (Lock) |

---

## 2. DNA解析マップ

処方（デザインパターン）の効果とリスクの分析。

### パターン: Singleton

- **適応症状**:
    - **インスタンス制御不能**: システム内で「唯一」であることを保証する。
    - **グローバルアクセス必要**: 安全なアクセスポイント (`GetInstance`) を提供する。
- **禁忌（処方してはいけないケース）**:
    - **ステートフルな処理**: 状態を持ちすぎると、副作用がシステム全体に波及する（密結合の温床）。
    - **テスト容易性が最優先**: 依存性の注入（DI）が推奨される場面では、モックへの差し替えが困難になるため避けるべき。
- **副作用**:
    - グローバルステートの実質的な隠蔽
    - マルチスレッド環境での初期化競合（Perlではフォーク安全性が課題）

---

## 3. 治療計画（連載構造案）

3つの異なるアプローチを提案します。

| 案 | 治療方針 | テーマ（題材） | 特徴 |
|---|----------|---------------|------|
| **案A** | **標準治療** | **DB接続マネージャ** | 「リソース競合」の解決に重点。実用性が高く、Webアプリ開発者がイメージしやすい王道プラン。 |
| **案B** | **集中治療** | **統合アプリケーションロガー** | 「グローバル汚染」と「ファイル競合」の解決に重点。複数プロセスからのログ書き込み制御も含める。 |
| **案C** | **予防医学** | **設定ファイル・レジストリ** | 「無限インスタンス」の防止に重点。読み込みコストが高い設定ファイルのキャッシュ機構として実装。 |

> [!WARNING]
> **重複注意**: 「設定ファイルマネージャ」（案C相当）は過去のシリーズ（`singleton-pattern-series-structure.md`）で既に実施済みです。案Aまたは案Bを強く推奨します。

### 案A: DB接続マネージャ（標準治療プラン）

DB接続という「高価」かつ「競合しやすい」リソースを管理する、最も典型的なSingletonのユースケース。

| 回 | 症状名（テーマ） | 診断・治療内容 | Before/After |
|---|------------------|----------------|--------------|
| 1 | 導入: 接続が多すぎる | なぜDB接続は「重い」のか？無秩序な接続生成の罠。 | 接続数: 無制限 → 1 |
| 2 | 無限インスタンス増殖症 | `new` を禁止せよ。コンストラクタの私有化と `instance` メソッド。 | インスタンス数: N → 1 |
| 3 | リソース競合不全症 | 接続状態の管理。切断されたら再接続する自己修復機能。 | エラー率: 高 → 低 |
| 4 | グローバル汚染症候群 | グローバル変数を使わずに、どこからでもDBにアクセスする仕組み。 | 安全性: 低 → 高 |
| 5 | 副作用: テストの困難 | Singletonはテストの敵？モックへの差し替えテクニック。 | テスト容易性: 低 → 中 |
| 6 | 退院: 健全な接続管理 | 総括と、DI（Dependency Injection）への道。 | - |

- **USP**: 誰もが直面する「DB接続」を題材に、実用的なコードが手に入る。
- **批判への回答**: 「今はDIコンテナ使うべきでは？」→「仕組みを理解するためにこそ、素のSingletonを知る必要がある」

### 案B: 統合アプリケーションロガー（集中治療プラン）

複数のモジュールから同時に書き込まれるログファイルの排他制御と、フォーマット統一を行う。

| 回 | 症状名（テーマ） | 診断・治療内容 | Before/After |
|---|------------------|----------------|--------------|
| 1 | 導入: ログが消える？ | 複数箇所から同時にファイルを開く危険性。 | ファイル破損率: 高 → 0 |
| 2 | グローバル汚染症候群 | `our $LOGGER` やめろ。正規のアクセスポイントを作る。 | 汚染度: 高 → 0 |
| 3 | リソース競合不全症 | ファイルハンドルの唯一性を保証する。書き込みの直列化。 | 競合: 有 → 無 |
| 4 | 拡張: レベル制御 | ERROR, WARN, INFOを一元管理する。動的なレベル変更。 | 管理工数: 高 → 低 |
| 5 | 副作用: プロセス分岐 | `fork` した時のTrap。親子のプロセスでSingletonはどう動く？ | 安全性: ? → 高 |
| 6 | 退院: ログはシステムの脈 | 総括。「ただのファイル書き込み」から「ロギングシステム」へ。 | - |

- **USP**: `fork` 時の挙動など、Perl特有のSingletonのハマりどころ（副作用）に踏み込む。
- **批判への回答**: `Log::Dispatch` 使えば？ → 車輪の再発明を通じて、排他制御の基礎を学ぶ。

### 案C: 設定ファイル・レジストリ（予防医学プラン）

※既存シリーズとテーマ重複のため、参考案扱い。

読み込みに時間がかかる巨大なJSON/YAML設定ファイルを、メモリ上に常駐させて使い回すキャッシュ機構。

---

## 4. 推薦案と理由

### 推薦: **案A (DB接続マネージャ)**

**理由**:
1. **ニーズの高さ**: DB接続管理はWeb開発の基礎であり、初心者が最もメリットを感じやすい。
2. **重複回避**: 既存の「設定ファイルマネージャ」と明確に差別化できる。
3. **拡張性**: 将来的に「接続プール」（Object Poolパターン）への発展も見込める。

### 別の選択肢
- もし「並行処理・排他制御」などの深いトピックを扱いたいなら **案B** も有力です。
