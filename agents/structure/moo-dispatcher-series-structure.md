---
date: 2025-12-30T19:48:12+09:00
description: シリーズ記事「Mooを使ってディスパッチャーを作ってみよう」（全12回）の連載構造案
draft: false
epoch: 1767091692
image: /favicon.png
iso8601: 2025-12-30T19:48:12+09:00
title: '連載構造案 - Mooを使ってディスパッチャーを作ってみよう（シリーズ記事）'
---

# 連載構造案：Mooを使ってディスパッチャーを作ってみよう

## 前提情報

### シリーズ概要

- **タイトル**: Mooを使ってディスパッチャーを作ってみよう
- **全回数**: 12回
- **技術スタック**: Perl / Moo
- **想定読者**: Mooの基本的な使い方はわかっているPerl初心者
- **想定ペルソナ**: ルーターやディスパッチの仕組みに興味がある
- **学習目標**: PerlでStrategy パターンの書き方が身につく
- **位置づけ**: 「Mooで覚えるオブジェクト指向プログラミング」シリーズ（全12回）の続編

### ストーリー背景

前シリーズで作成したBBSに機能を追加していく過程で、if/elseだけでは解決が難しい（コードが見づらい）状況になります。全体記事の表示、投稿フォーム、スレッド表示、単体記事表示など、多くの機能を追加する中で、ルーターやディスパッチの必要性に気づき、どうすれば「良い実装」ができるようになるのかを考え、そして、気がつけばそれがデザインパターンと呼ばれている実装方法だったことに気づくのが目標です。

### 制約

- トーンは前シリーズと同じような入門者向けの優しい感じ
- 毎回コード例は2つまで
- 新しい概念は1記事あたり1つまで
- 図解を含めたわかりやすさを目指す
- ゆっくりと、少しずつ、手を動かして実行しているうちに「あー、こういうことだったのか」と理解できるようなシリーズ

### 前シリーズで学習済みの概念

- `has`と`sub`でクラスを定義
- `new`でオブジェクト生成
- `is => 'ro'/'rw'`でアクセス制御
- `required`と`default`
- カプセル化
- 複数クラスの連携
- `extends`による継承
- オーバーライド
- `Moo::Role`と`with`によるロール
- `handles`による委譲
- `isa`による型制約

---

## 案A：「問題発見から解決へ」アプローチ

### 特徴・アプローチ

if/elseの問題を実際に体験してから、段階的に解決策を学ぶアプローチ。読者は「なぜこの解決策が必要なのか」を実感しながら学べます。デザインパターンの名前（Strategy パターン）は後半で初めて登場し、「あ、これがデザインパターンだったのか！」という気づきを演出します。

### メリット

- **動機付けが強い**: 問題を体験してから解決策を学ぶため、「なぜ必要か」が明確
- **実践的**: 実際のコード改善の流れを追体験できる
- **記憶に残りやすい**: 「問題→解決」のストーリーで学習内容が定着しやすい
- **入門者に優しい**: 抽象的な概念から始めないので取り組みやすい

### デメリット

- **前半が冗長に感じる可能性**: if/elseの問題を見せるため、「早くパターンを教えて」と感じる読者もいるかも
- **デザインパターンの体系的理解が後回し**: パターンの全体像を掴むのが遅れる

### デメリットへの対策

- **前半が冗長に感じる可能性への対策**: 毎回「少しずつ良くなっていく」感覚を演出。第2回でハッシュに変えると明らかにスッキリする体験を強調
- **デザインパターンの体系的理解が後回しへの対策**: 第12回でGoFパターンの一覧を紹介し、「次に学ぶべきパターン」への道筋を示す

### 連載構造

| 回 | タイトル | 新しい概念 | ストーリー | コード例1 | コード例2 | 推奨タグ |
|---|---------|-----------|-----------|----------|----------|---------|
| 1 | BBSに機能を追加しよう | if/elseの問題 | 前シリーズで作ったBBSに「投稿一覧」「投稿フォーム」「スレッド表示」機能を追加。if/elseで機能を切り替える実装を行う | if/elseで3つの機能を切り替えるコード | さらに機能を追加してif/elseが肥大化したコード | Perl, Moo, リファクタリング |
| 2 | ハッシュで振り分けよう | ディスパッチテーブル | if/elseの代わりにハッシュを使って処理を振り分ける方法を学ぶ。コードがすっきりする感覚を体験 | ハッシュに処理名を登録して振り分け | ハッシュから処理を取り出して実行 | Perl, ハッシュ, ディスパッチ |
| 3 | 処理を変数に入れよう | コードリファレンス | サブルーチンを変数に代入する「コードリファレンス」を学ぶ。関数をデータとして扱う感覚を掴む | my $handler = sub { ... }; の基本 | コードリファレンスをハッシュに格納して呼び出し | Perl, コードリファレンス |
| 4 | 処理をクラスに分けよう | ハンドラークラス | 各機能（一覧、フォーム、スレッド）を別々のクラスに切り出す。責任の分離を体験 | ListHandler クラスの作成 | FormHandler クラスの作成 | Perl, Moo, ハンドラー |
| 5 | 共通の約束を決めよう | requires | 各ハンドラークラスに「必ずこのメソッドを持つ」という約束をMoo::Roleのrequiresで定義 | Handler ロールの作成（requires 'run'） | ハンドラークラスでのwith適用 | Perl, Moo::Role, インターフェース |
| 6 | 司令塔クラスを作ろう | Context クラス | ハンドラーを保持するディスパッチャー（Context）クラスを作成。委譲（handles）を活用してハンドラーに処理を振る | Dispatcher クラスと has handler 定義 | dispatch メソッドの実装 | Perl, Moo, ディスパッチャー |
| 7 | 動的に切り替えよう | 動的切り替え | 実行時にハンドラーを切り替える機能を追加。is => 'rw' を使った動的な変更で柔軟性を獲得 | set_handler メソッドの追加 | 実行時にハンドラーを差し替えるデモ | Perl, Moo, 動的切り替え |
| 8 | ハンドラーを登録しよう | レジストリ | 複数のハンドラーを登録して管理する仕組みを追加。ハンドラーのレジストリを構築 | register_handler メソッド | handlers 属性（ハッシュ）の管理 | Perl, Moo, レジストリ |
| 9 | 自動で選ぶ仕組みを作ろう | Factory的生成 | アクション名から自動でハンドラーを選択・生成する仕組みを実装 | handler_for メソッドの実装 | アクション名からハンドラーを選択 | Perl, Moo, Factory |
| 10 | URLで振り分けよう | URLルーティング | URLパターンで振り分ける機能を追加。正規表現マッチングでより柔軟なルーティング | add_route メソッドとURLパターン | パターンマッチでハンドラー選択 | Perl, ルーティング, 正規表現 |
| 11 | 完成！ディスパッチャー | 統合 | これまで作ってきた機能を統合し、完成したディスパッチャーをBBSに組み込んで動作確認 | 完成したDispatcherクラス全体 | BBSでの動作確認と実行例 | Perl, Moo, ディスパッチャー |
| 12 | これがデザインパターンだ！ | Strategy パターン | 実は作ってきたものが「Strategy パターン」だったことを明かす。デザインパターンの世界への入口 | Strategy パターンの構造図解 | 他のパターン（Command等）への展望 | Perl, デザインパターン, Strategy |

---

## 案B：「パターンから始める」アプローチ

### 特徴・アプローチ

最初にデザインパターンの概念と必要性を説明し、その後で具体的な実装に入るアプローチ。「デザインパターンとは何か」「なぜ存在するのか」を理解してから、Strategy パターンを適用したディスパッチャーを構築します。

### メリット

- **全体像が見える**: 最初にゴールが分かるので、学習の方向性が明確
- **体系的理解**: デザインパターンの位置づけを最初に学べる
- **効率的**: 必要な知識を先に学んでから実装に入れる

### デメリット

- **抽象的な導入**: 入門者には最初の数回が難しく感じる可能性
- **動機付けが弱い**: 問題を体験せずにパターンを学ぶため、「なぜ必要か」が実感しにくい
- **教科書的**: 「問題→解決」の流れがなく、発見の喜びが少ない

### デメリットへの対策

- **抽象的な導入への対策**: 第1回・第2回では図解を多用し、日常生活の例え（レストランのメニュー選択など）で概念を伝える
- **動機付けが弱いことへの対策**: 第3回で具体的なif/else問題を見せ、「だからパターンが必要」と実感させる
- **教科書的になることへの対策**: 第4回以降は手を動かす実装中心にし、理論は必要最小限に

### 連載構造

| 回 | タイトル | 新しい概念 | ストーリー | コード例1 | コード例2 | 推奨タグ |
|---|---------|-----------|-----------|----------|----------|---------|
| 1 | デザインパターンって何？ | デザインパターンの概念 | プログラミングには「定石」がある。将棋や囲碁の定石のように、先人の知恵を活用する方法を紹介 | 簡単なif/else問題のコード（予告） | デザインパターンで解決できるという希望 | Perl, デザインパターン, 入門 |
| 2 | Strategyパターンを知ろう | Strategy パターンの構造 | Strategy パターンの構造（Context、Strategy、Concrete Strategy）を図解で説明。「作戦を切り替える」イメージ | Strategy パターンの骨格コード | 構造を示す図と対応するコード | Perl, Strategy, 構造 |
| 3 | BBSの問題を見つけよう | if/elseの問題認識 | 前シリーズのBBSに機能追加。if/elseの問題点を確認し、「これをStrategyで解決しよう」と認識 | 肥大化したif/elseコード | 問題点の整理と解決方針 | Perl, Moo, リファクタリング |
| 4 | ハンドラーを作ろう | Concrete Strategy | 各機能をハンドラークラス（Concrete Strategy）として実装。クラスへの分離 | ListHandler クラス | FormHandler クラス | Perl, Moo, ハンドラー |
| 5 | インターフェースを定義しよう | Strategy Interface | Moo::Roleでハンドラーのインターフェースを定義。requiresで必須メソッドを指定 | Handler ロール（requires 'run'） | ロールを適用したハンドラー | Perl, Moo::Role, インターフェース |
| 6 | Contextを作ろう | Context クラス | ディスパッチャー（Context）クラスを作成。Strategyを保持し、委譲で処理を実行 | Dispatcher クラス | has handler と handles | Perl, Moo, Context |
| 7 | 動的に切り替えよう | 実行時切り替え | Contextに保持するStrategyを動的に変更する仕組みを実装 | set_handler メソッド | 動的切り替えのデモ | Perl, Moo, 動的切り替え |
| 8 | コードリファレンスを使おう | コードリファレンス | Strategyの軽量版としてコードリファレンスを使う方法も紹介。使い分けを学ぶ | コードリファレンスでのハンドラー | ディスパッチテーブル | Perl, コードリファレンス |
| 9 | Factoryで生成しよう | Factory パターン | どのStrategyを使うかを決めるFactory的な仕組みを実装 | handler_for メソッド | アクション名からハンドラー生成 | Perl, Factory |
| 10 | URLルーティングを追加しよう | URLベースの振り分け | URLパターンでStrategyを選択する機能を追加 | add_route メソッド | パターンマッチとハンドラー選択 | Perl, ルーティング |
| 11 | ディスパッチャー完成！ | 統合と完成 | 全機能を統合してディスパッチャーを完成させ、BBSで動作確認 | 完成したDispatcherクラス | BBSでの動作確認 | Perl, Moo, ディスパッチャー |
| 12 | 次のパターンへ | 他のパターン紹介 | Strategy以外のパターン（Command、Chain of Responsibility）を紹介し、次への展望 | Commandパターンの概要 | 発展的な学習リソース紹介 | Perl, デザインパターン, 発展 |

---

## 案C：「ステップバイステップ構築」アプローチ

### 特徴・アプローチ

最小限のディスパッチャーから始めて、少しずつ機能を追加しながら拡張していくアプローチ。毎回「動くもの」を作りながら進むため、実践的で達成感を得やすい構成です。パターンの名前は必要に応じて自然に登場させます。

### メリット

- **常に動くものがある**: 毎回実行可能なコードを書くので達成感がある
- **実践的**: 手を動かしながら学べる
- **段階的成長**: 小さく始めて徐々に拡張する流れが自然
- **入門者フレンドリー**: 抽象的な概念より実装を優先

### デメリット

- **理論的背景が薄い**: なぜその設計が良いのかの説明が後回しになりがち
- **全体像が見えにくい**: 完成形が見えるのが終盤になる
- **リファクタリングが多い**: 毎回コードを書き換えるため、同じ箇所を何度も触る

### デメリットへの対策

- **理論的背景が薄いことへの対策**: 各回の最後に「なぜこうするのか」を短く解説するコラムを追加
- **全体像が見えにくいことへの対策**: 第1回で完成形のイメージ図を先に見せ、「ここを目指す」と示す
- **リファクタリングが多いことへの対策**: 「良くなる過程」を楽しむ視点で構成。Before/Afterを明確にして達成感を演出

### 連載構造

| 回 | タイトル | 新しい概念 | ストーリー | コード例1 | コード例2 | 推奨タグ |
|---|---------|-----------|-----------|----------|----------|---------|
| 1 | 最初のディスパッチャー | 基本的なディスパッチ | if/elseで機能を切り替える最小限のディスパッチャーを作成。完成イメージも先に見せる | 3つのif/elseで振り分け | 実行してみる | Perl, Moo, ディスパッチャー |
| 2 | ハッシュに置き換えよう | ディスパッチテーブル | if/elseをハッシュ（ディスパッチテーブル）に置き換え。コードがスッキリする | ハッシュでの振り分け定義 | 処理の実行 | Perl, ハッシュ, ディスパッチ |
| 3 | 処理を関数にしよう | コードリファレンス | 処理内容をサブルーチンとして切り出し、コードリファレンスで登録 | サブルーチンの定義 | コードリファレンスをハッシュに格納 | Perl, コードリファレンス |
| 4 | クラスに分けよう | ハンドラークラス | 処理をクラスに分離。ListHandler、FormHandler、ThreadHandlerを作成 | ListHandler クラス | FormHandler クラス | Perl, Moo, ハンドラー |
| 5 | 共通ルールを作ろう | Moo::Role と requires | 各ハンドラーが守るべきルール（インターフェース）をRoleで定義 | Handler ロール | requires 'run' と with | Perl, Moo::Role, インターフェース |
| 6 | 中央管理しよう | ディスパッチャークラス | ハンドラーを管理するディスパッチャークラスを作成。登録機能を追加 | Dispatcher クラスの骨格 | register_handler メソッド | Perl, Moo, ディスパッチャー |
| 7 | 委譲で呼び出そう | handles | ディスパッチャーからハンドラーへの処理委譲。handlesを活用してシンプルに | has current_handler | handles での委譲 | Perl, Moo, 委譲 |
| 8 | 実行時に切り替えよう | 動的切り替え | 実行中にハンドラーを切り替える機能を追加。柔軟性の獲得 | switch_handler メソッド | 動的切り替えのデモ | Perl, Moo, 動的切り替え |
| 9 | 自動選択しよう | Factory的生成 | アクション名から自動でハンドラーを選ぶ仕組みを追加 | handler_for メソッド | 自動選択のデモ | Perl, Factory |
| 10 | URLで振り分けよう | URLルーティング | URLパターンマッチングを追加。正規表現でのマッチング | add_route メソッド | URLマッチングロジック | Perl, ルーティング |
| 11 | 完成！ | 統合テスト | 全機能を統合し、BBSで動作確認。完成したディスパッチャーをテスト | 統合テストコード | BBSでの動作確認 | Perl, Moo, テスト |
| 12 | 振り返りとパターン | Strategy パターン | 作ったものがStrategy パターンだったと振り返り。デザインパターンの世界を紹介 | Strategy パターンの解説と図 | 次に学ぶべきパターン | Perl, デザインパターン, Strategy |

---

## 推薦案とその理由

### 推薦：案A「問題発見から解決へ」アプローチ

### 推薦理由

1. **ストーリーとの整合性が最も高い**
   - 「BBSに機能を追加していく過程で、if/elseだけでは解決が難しい状況になり、気がつけばそれがデザインパターンだった」というストーリーに最も合致

2. **想定ペルソナとの適合性**
   - 「ルーターやディスパッチの仕組みに興味がある」読者は、まず動くものを作りながら仕組みを理解したいはず
   - 抽象的なパターンの説明より、具体的な問題解決を通じて学ぶほうが興味を維持できる

3. **入門者への動機付けが強い**
   - 問題を体験してから解決策を学ぶため、「なぜこの方法が必要なのか」が自然に理解できる
   - 「早くパターンを教えて」と感じる読者もいるかもしれないが、前シリーズの読者層は「ゆっくり学ぶ」ことを好む

4. **「気づき」の演出が可能**
   - 第12回で「実はこれがStrategy パターンだった！」と明かす構成は、読者に発見の喜びを与える
   - 「教わった」のではなく「自分で辿り着いた」という感覚が記憶に残りやすい

5. **前シリーズとのトーンの一貫性**
   - 前シリーズも「やってみる→わかる」の流れだったため、同じスタイルを継続できる

6. **実務に近い学習体験**
   - 実際のプログラミングでも「問題に遭遇→解決策を模索→パターンを発見」という流れが多い

### 案Bを選ばなかった理由

- 最初に抽象的な概念（デザインパターン）から入るのは、入門者には敷居が高い
- 「なぜ必要か」を実感する前にパターンを学ぶのは動機付けが弱い

### 案Cを選ばなかった理由

- 毎回「動くもの」を作る点は良いが、リファクタリングが多く、読者が「また書き換えるの？」と感じる可能性
- パターンの解説が最後に集中するため、「気づき」の演出が案Aほど効果的でない

---

## 付記

### 3案の比較表

| 項目 | 案A（問題発見から解決へ） | 案B（パターンから始める） | 案C（ステップバイステップ） |
|-----|------------------------|------------------------|--------------------------|
| **アプローチ** | 問題体験 → 解決策学習 | 理論学習 → 実装 | 実装しながら学習 |
| **デザインパターン登場** | 最終回で明かす | 第1-2回で導入 | 最終回で振り返り |
| **動機付けの強さ** | ◎ 強い | △ やや弱い | ○ 中程度 |
| **入門者の取り組みやすさ** | ◎ 取り組みやすい | △ 最初が難しい | ◎ 取り組みやすい |
| **達成感** | ○ 最後に「気づき」 | ○ 体系的理解 | ◎ 毎回動くもの |
| **前シリーズとの連続性** | ◎ 高い | ○ 中程度 | ○ 中程度 |
| **リファクタリング頻度** | 中程度 | 少ない | 多い |
| **ストーリー適合度** | ◎ 最適 | △ やや不適合 | ○ 適合 |

### 図解の推奨

各回で以下のような図解を含めることを推奨（Mermaidで作成可能）：

#### 第1回: if/elseの分岐図
```
[リクエスト] → [action = "list"?]
                  ├─ Yes → 一覧表示
                  └─ No → [action = "form"?]
                            ├─ Yes → フォーム表示
                            └─ No → [action = "thread"?]
                                      ├─ Yes → スレッド表示
                                      └─ No → エラー
```

#### 第2回: ディスパッチテーブルの概念図
```
%handlers = {
    "list"   → &show_list
    "form"   → &show_form
    "thread" → &show_thread
}

[action] → handlers{action}->()
```

#### 第5回: Roleとクラスの関係図
```
┌─────────────────┐
│  Handler Role   │  ← requires 'run'
│  (インターフェース)  │
└────────┬────────┘
         │ with
    ┌────┴────┬────────────┐
    ↓         ↓            ↓
┌───────┐ ┌───────┐ ┌───────────┐
│ List  │ │ Form  │ │ Thread   │
│Handler│ │Handler│ │ Handler  │
└───────┘ └───────┘ └───────────┘
```

#### 第6-7回: Context-Strategy構造の図
```
┌─────────────────────────────────────────┐
│           Dispatcher (Context)          │
│  ┌─────────────────────────────────┐   │
│  │ has handler => (Strategy)       │   │
│  └─────────────────────────────────┘   │
│                  │                      │
│                  ↓ dispatch()           │
│           handler->run()                │
└─────────────────────────────────────────┘
                   │
      ┌────────────┴────────────┐
      ↓                         ↓
┌───────────┐            ┌───────────┐
│ListHandler│            │FormHandler│
│  (Strat.) │            │  (Strat.) │
└───────────┘            └───────────┘
```

### 前シリーズへのリンク

各回の冒頭で、関連する前シリーズの記事へのリンクを設置することを推奨：

| 本シリーズの回 | 関連する前シリーズの回 | トピック |
|--------------|---------------------|---------|
| 第4回 | 第7回「複数クラスの連携」 | クラスの分割と連携 |
| 第5回 | 第10回「ロール」 | Moo::Roleとwith |
| 第6回 | 第11回「委譲」 | handlesの使い方 |
| 第7回 | 第4回「読み書きを制限する」 | is => 'rw' |

### 発展的な内容

本シリーズ完了後の発展として、以下のトピックを第12回で予告：

- **Commandパターン**: 操作自体をオブジェクトにする
- **Chain of Responsibilityパターン**: 処理を連鎖させる
- **本格的なWebフレームワーク（Mojolicious）でのルーティング**: 実践的なルーター
- **Router::Simple**: CPANモジュールを使った軽量ルーティング

### 各回の想定文字数

入門者向けシリーズのため、各回の本文は以下の範囲に収めることを推奨：

- **本文**: 1,500〜2,500文字程度
- **コード例**: 各20〜50行程度（2例合計で40〜100行）
- **図解**: 1〜2点

### 執筆上の注意点

1. **専門用語の初出時は必ず説明する**（例：「ディスパッチ（振り分け）」）
2. **英語の概念は日本語で言い換える**（例：Context → 司令塔、Strategy → 作戦）
3. **「なぜ」を省略しない**（各改善の理由を必ず述べる）
4. **コードは動作確認済みのものを使用**
5. **毎回冒頭で前回の内容を1-2文で振り返る**

---

**作成日**: 2025年12月30日
**レビュー回数**: 3回（最終版）
**関連ドキュメント**: [調査ドキュメント - Mooを使ってディスパッチャーを作ってみよう](/warehouse/moo-dispatcher-series-research/)
