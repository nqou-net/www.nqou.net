---
description: シリーズ記事「Template Methodパターン」の連載構造案3つ（案A/B/C）
draft: true
iso8601: 2026-01-14T17:13:45+09:00
title: '連載構造案 - Template Methodパターン新シリーズ（全10回）'
---

# 連載構造案：Template Methodパターンを学ぶ新シリーズ

調査結果: `content/warehouse/template-method-pattern.md` に基づく

## 前提情報

- **技術スタック**: Perl v5.36以降（signatures、postfix dereference対応）、Mooによるオブジェクト指向プログラミング
- **想定読者**: Perl入学式卒業したばかりの入門者
- **想定ペルソナ**: 「Mooで覚えるオブジェクト指向プログラミング」シリーズを読了してオブジェクト指向プログラミングを身に付けたい、モダンなPerlを使いたい
- **学習目標**:
  - オブジェクト指向プログラミングの原則を深く学べる
  - 継承とオーバーライドを実践的に活用できる
  - 自然にTemplate Methodパターンを覚えられる
  - 振る舞いパターン（Behavioral Patterns）の考え方が理解できる
- **位置づけ**: 「Mooで覚えるオブジェクト指向プログラミング」シリーズの続編
- **ストーリー**: 知っている知識で動くプログラムを作成 → 機能を追加していくと問題が発覚 → 継承とオーバーライドを活用して問題を解決
- **難易度**: 3/5（継承、メソッドオーバーライドの理解が必要）
- **制約**:
  - 1記事1概念
  - コード例2つまで
  - 回の最後には完成コードを示す（原則1つのスクリプトファイル）
  - デザインパターンの名前はシリーズ名に敢えて出さない（最終回で明かす）
  - **既存シリーズとは完全に異なるテーマ・題材を使用**

### 既存シリーズとの差別化

以下のシリーズとは完全に異なる題材を使用：

| シリーズ | 題材 | パターン | アプローチ |
|---------|------|---------|-----------|
| ディスパッチャーを作ろう | URLルーティング | Strategy | 委譲（has + Role） |
| データエクスポーターを作ろう | CSV/JSON/YAML出力 | Strategy | 委譲（has + Role） |
| 通知システムを作ろう | 通知方法切り替え | Strategy | 委譲（has + Role） |
| レポートジェネレーター | レポート生成 | Factory Method | 継承（extends + オーバーライド） |
| データベース接続管理 | DB接続 | Factory Method | 継承（extends + オーバーライド） |
| ゲームキャラクター生成 | キャラ生成 | Factory Method | 継承（extends + オーバーライド） |
| **本シリーズ（新規）** | **別のドメイン** | **Template Method** | **継承（extends + オーバーライド）** |

**Template Methodパターンの特徴**:

- **継承ベース**: 親クラスで「処理の骨格（流れ）」を定義、サブクラスで「具体的なステップ」を実装
- **「流れは固定、中身は可変」**: アルゴリズムの順序は親クラスが制御、個々のステップはサブクラスに委ねる
- **Factory Methodパターンとの違い**: Factory Methodは「何を作るか」、Template Methodは「どういう順序で処理するか」
- **Strategyパターンとの違い**: Strategyは「アルゴリズム全体を切り替え」、Template Methodは「骨格は固定で一部だけ変更」

### 前提知識（前シリーズで習得済み）

| 前シリーズで学んだこと | 本シリーズでの活用 |
|----------------------|-------------------|
| `has`と`sub`でクラスを定義 | 基底クラスと具象クラスの定義 |
| `new`でオブジェクト生成 | スクレイパー/アナライザーのインスタンス化 |
| `is => 'ro'/'rw'`でアクセス制御 | 属性の定義 |
| `required`と`default` | 設定値の初期化 |
| カプセル化 | 処理ステップの隠蔽 |
| 複数クラスの連携 | 親クラス-サブクラス関係 |
| **`extends`による継承** | **★重要：具象クラスの定義** |
| **オーバーライド** | **★重要：抽象メソッドの実装** |
| `Moo::Role`と`with`によるロール | フックメソッドのデフォルト実装 |
| `isa`/`does`による型制約 | 型の検証 |

---

## 案A: 「Webスクレイピングツール」アプローチ

### シリーズ名案

**「Mooを使ってWebスクレイパーを作ってみよう」**（全10回）

### 特徴・アプローチ

**「インターネットから情報を自動収集する」**という、多くのプログラマーが一度は夢見るハッキング的なツールを作成します。Qiita、Zenn、技術ブログなど複数のサイトから記事情報を収集するスクレイパーを構築。サイトごとに「HTMLの構造が違う」という現実的な問題に直面し、Template Methodパターンで解決します。

**Template Methodパターンとの対応**:

| パターン要素 | 本シリーズでの実装 |
|------------|------------------|
| AbstractClass（抽象クラス） | WebScraper基底クラス |
| templateMethod | scrape()メソッド - 「取得→解析→整形→保存」の骨格 |
| primitiveOperation（抽象メソッド） | _parse_html() - サイトごとに実装必須 |
| hook（フックメソッド） | _validate() - オプションの検証ステップ |
| ConcreteClass（具象クラス） | QiitaScraper, ZennScraper, HatenaScraper等 |

**「少し生意気でハッキング的」な要素**:
- 「Webサイトからデータを自動収集する」という達成感
- 「友人に『俺、スクレイパー作ったんだ』と自慢できる」
- 実際に動くツールでQiitaやZennから記事タイトルを取得

### メリット

- **ハッキング感★★★★★**: 「ネットから情報を自動収集できる」という達成感が最高
- **Template Methodに最適**: 「fetch → parse → save」という明確な処理の流れ
- **実用性が高い**: 作ったツールを実際に使える
- **拡張性のデモが容易**: 新しいサイト対応を追加するたびにパターンの価値を実感
- **既存シリーズと完全に異なるドメイン**: URLルーティングやデータ出力とは別世界

### デメリット

- **法的考慮事項**: robots.txt、利用規約の説明が必要。また、レート制限やアンチスクレイピング対策への配慮、マナーを守ったスクレイピングの重要性も教育的に解説（むしろ教育的価値としてプラス）
- **外部依存**: Mojo::DOM または HTML::TreeBuilder が必要（HTTP::TinyはPerl v5.14以降コアモジュール）
- **対象サイトの変更リスク**: HTMLの構造変更でコードが動かなくなる可能性

### USP（Unique Selling Point）: なぜお金を払う価値があるのか？

> **批判的視点での検証**:
> 「Webスクレイピングのチュートリアルは無料でたくさんある。なぜこれにお金を払う？」
>
> **回答**:
> 1. **Perl/Mooに特化した教材は非常に稀**: Pythonのスクレイピング教材は山ほどあるが、Perl/Mooで、しかもデザインパターンを絡めた教材はほとんど見当たらない
> 2. **単なる「動くコード」ではなく「設計思想」を学べる**: 無料チュートリアルは「このコードをコピペすれば動く」で終わるが、本シリーズは「なぜこう設計するのか」「次のサイト追加が楽になる理由」まで踏み込む
> 3. **問題解決ストーリー**: 「if/elseが増えて困った」→「継承で解決」という体験型学習は、ただのコピペ教材では得られない
> 4. **前シリーズからの継続性**: Moo OOPシリーズの知識を前提とした、レベルアップ教材

### 連載構造

| 回 | タイトル | 新しい概念 | ストーリー | コード例1 | コード例2 | 推奨タグ | description |
|---|---------|-----------|-----------|----------|----------|---------|-------------|
| 第1回 | 最初のスクレイパーを作ろう | 基本的なWebスクレイピング | Qiitaのトレンド記事一覧を取得するシンプルなスクレイパーを作成。HTTP::Tinyでページ取得、正規表現でタイトル抽出 | WebScraperクラスとscrapeメソッド | Qiita記事タイトルの取得結果 | perl, moo, web-scraping, http | Qiitaのトレンド記事を自動取得！Mooでシンプルなスクレイパーを作成し、Webから情報を収集する第一歩を踏み出そう |
| 第2回 | 別のサイトも取得したい！ | if/elseでの処理切り替え | Zennの記事も取得したくなった。if/elseでサイトごとに処理を分岐するが、コードが肥大化して問題発覚 | if/elseでサイト判定するコード | 問題点：新サイト追加でif/else地獄 | perl, moo, refactoring, conditional | Zennも取得したい！でもif/elseで分岐すると、コードがどんどん肥大化…この問題、どう解決する？ |
| 第3回 | サイトごとにクラスを分けよう | 継承によるクラス分離 | QiitaScraper、ZennScraperをextendsで作成。各サイト固有の処理を分離 | WebScraper基底クラスの整理 | QiitaScraperクラスの作成 | perl, moo, extends, inheritance | if/else地獄からの脱出！extendsで継承を使い、サイトごとに専用クラスを作成してコードを整理しよう |
| 第4回 | 処理の流れを統一しよう | テンプレートメソッドの導入 | scrape()メソッドで「fetch→parse→format→save」の骨格を定義。各サイトは_parse_html()だけ実装 | scrape()メソッドの実装（骨格） | _parse_html()の抽象化 | perl, moo, algorithm, workflow | 「取得→解析→整形→保存」の流れを基底クラスで統一。各サイトはパース処理だけ実装すればOKに！ |
| 第5回 | パース処理をオーバーライドしよう | 抽象メソッドのオーバーライド | 各スクレイパーで_parse_html()をオーバーライドし、サイト固有のHTML解析を実装 | ZennScraperでのオーバーライド | はてなブログ対応の追加 | perl, moo, override, parsing | サイトごとに異なるHTML構造に対応！_parse_html()をオーバーライドして、各サイト固有の解析処理を実装 |
| 第6回 | オプション機能を追加しよう | フックメソッド（hook） | _validate()や_before_save()などのフックメソッドを追加。デフォルト実装を持ち、必要に応じてオーバーライド | フックメソッドの定義と実装 | 特定サイトでのフック活用例 | perl, moo, hook, optional | 「あると便利」なオプション機能をフックメソッドで実装。必要なサイトだけオーバーライドする柔軟な設計 |
| 第7回 | エラーに強くしよう | 共通エラー処理の集約 | 基底クラスにエラーハンドリングを集約。try/catchで堅牢なスクレイパーに | エラーハンドリングの追加 | リトライ機能の実装 | perl, moo, error-handling, try-catch | ネットワークエラーやHTMLの変更に負けない！基底クラスにエラー処理を集約して堅牢なスクレイパーに |
| 第8回 | 新しいサイトを追加しよう | 拡張性の実証（OCP） | Dev.toを追加。既存コードを修正せずに新クラス追加だけで対応！ | DevToScraperクラスの追加 | 4サイト対応の確認 | perl, moo, open-closed, ocp | Dev.toにも対応！既存コードを一切修正せず、新クラス追加だけで拡張完了。開放閉鎖原則（OCP）の威力を体験 |
| 第9回 | 完成！マルチサイトスクレイパー | 統合と完成 | 全機能を統合してスクレイパーを完成。複数サイトの記事を一括取得 | 完成したクラス群の全体像 | 4サイトからの記事取得デモ | perl, moo, web-scraping, tutorial | 4つのサイトから記事を一括取得！完成したマルチサイトスクレイパーの全体像と使い方を解説 |
| 第10回 | これがTemplate Methodパターンだ！ | Template Methodパターン | 作ってきたものが「Template Methodパターン」だったことを明かす。Strategyパターンとの違いも解説 | Template Methodパターンの構造図解 | Factory Methodとの比較 | perl, moo, design-patterns, template-method | 実は作ってきたものが「Template Methodパターン」でした！GoFデザインパターンを学び、Strategyとの違いも解説 |

### 差別化ポイント

- **ハッキング感が最高**: 「Webから情報を自動収集」という達成感
- **Template Methodに最適なドメイン**: 「fetch→parse→save」の流れが固定、parseだけサイトごとに変わる
- **実用性**: 実際に使えるツールが完成
- **調査で最推奨テーマ**: `/content/warehouse/template-method-pattern.md`で最推奨

---

## 案B: 「ログアナライザー」アプローチ

### シリーズ名案

**「Mooを使ってログアナライザーを作ってみよう」**（全10回）

### 特徴・アプローチ

**「サーバーの秘密を暴く！自分だけのフォレンジックツール」**という、セキュリティエンジニアもどきのハッキングツールを作成します。Apache、Nginx、Syslogなど異なる形式のログファイルを解析し、「誰が」「いつ」「何をしたか」を丸裸に。不正アクセスの痕跡を見つけ出す、まるでハッカー映画の主人公のような体験。ログ形式ごとに「パース方法が違う」という現実的な問題に直面し、Template Methodパターンで解決します。

**Template Methodパターンとの対応**:

| パターン要素 | 本シリーズでの実装 |
|------------|------------------|
| AbstractClass（抽象クラス） | LogAnalyzer基底クラス |
| templateMethod | analyze()メソッド - 「読み込み→パース→集計→レポート」の骨格 |
| primitiveOperation（抽象メソッド） | _parse_line() - ログ形式ごとに実装必須 |
| hook（フックメソッド） | _filter(), _before_report() - オプションのステップ |
| ConcreteClass（具象クラス） | ApacheLogAnalyzer, NginxLogAnalyzer, SyslogAnalyzer等 |

**「少し生意気でハッキング的」な要素**:
- 「サーバーログを解析して、誰がいつ何をしたか丸わかり」
- 「不正アクセスの痕跡を発見！セキュリティエンジニアみたい」
- 「ハッカー映画で見たあれ、自分で作れるんだ」
- 実際の/var/logを覗いて分析する体験

### メリット

- **ハッキング感★★★★☆**: 「ログを丸裸にする」というシステム管理者感
- **Template Methodに最適**: 「read → parse → aggregate → report」という明確な流れ
- **外部依存なし**: 標準モジュールのみで実装可能
- **実用性が高い**: 自分のサーバーのログ分析に使える
- **セキュリティ教育的要素**: 「ログを見ることで何がわかるか」を体験

### デメリット

- **ログ形式の前提知識**: Apache/Nginxログ形式の説明が必要
- **サンプルログの準備**: 読者が試せるサンプルログファイルを用意する必要
- **地味さ**: Webスクレイピングほどのインパクトはない

### USP（Unique Selling Point）: なぜお金を払う価値があるのか？

> **批判的視点での検証**:
> 「ログ解析ツールはgrepやawkで十分。なぜこれにお金を払う？」
>
> **回答**:
> 1. **grep/awkは一時的、これは再利用可能**: 毎回ワンライナーを考えるより、一度作れば何度でも使えるツール
> 2. **複数形式対応の設計思想**: 「Apache用」「Nginx用」とスクリプトを乱立させるのではなく、拡張可能な設計を学ぶ
> 3. **Perl/Mooでのテキスト処理のベストプラクティス**: Perlの正規表現力を活かしたモダンな設計
> 4. **システム管理スキルの副産物**: ログ形式を理解することで、サーバー管理の知識も身につく

### 連載構造

| 回 | タイトル | 新しい概念 | ストーリー | コード例1 | コード例2 | 推奨タグ | description |
|---|---------|-----------|-----------|----------|----------|---------|-------------|
| 第1回 | 最初のログアナライザーを作ろう | 基本的なログ解析 | Apacheアクセスログを解析して、アクセス数TOP10のURLを表示するツールを作成 | LogAnalyzerクラスとanalyzeメソッド | Apacheログの解析結果 | perl, moo, log-analysis, text-processing | Apacheログを解析してアクセスランキングを作成！Mooでログアナライザーを作り、サーバーの秘密を暴こう |
| 第2回 | 別の形式も解析したい！ | if/elseでの処理切り替え | Nginxログも解析したくなった。if/elseで形式判定するが、コードが複雑化 | if/elseでログ形式判定するコード | 問題点：新形式追加でif/else地獄 | perl, moo, refactoring, conditional | Nginxも解析したい！でもif/elseで形式判定すると、コードがカオスに…この問題、どう解決する？ |
| 第3回 | 形式ごとにクラスを分けよう | 継承によるクラス分離 | ApacheLogAnalyzer、NginxLogAnalyzerをextendsで作成 | LogAnalyzer基底クラスの整理 | ApacheLogAnalyzerクラスの作成 | perl, moo, extends, inheritance | if/else地獄からの脱出！継承を使ってログ形式ごとに専用クラスを作成し、コードを整理しよう |
| 第4回 | 解析の流れを統一しよう | テンプレートメソッドの導入 | analyze()メソッドで「読み込み→パース→集計→レポート」の骨格を定義 | analyze()メソッドの実装（骨格） | _parse_line()の抽象化 | perl, moo, algorithm, workflow | 「読み込み→パース→集計→レポート」の流れを基底クラスで統一。各形式はパース処理だけ実装すればOK！ |
| 第5回 | パース処理をオーバーライドしよう | 抽象メソッドのオーバーライド | 各アナライザーで_parse_line()をオーバーライドし、形式固有のパースを実装 | NginxLogAnalyzerでのオーバーライド | Syslog対応の追加 | perl, moo, override, parsing | 形式ごとに異なるログ構造に対応！_parse_line()をオーバーライドして、各形式固有の解析処理を実装 |
| 第6回 | フィルタ機能を追加しよう | フックメソッド（hook） | _filter()フックで特定条件のログだけ抽出。デフォルトは全件処理 | フックメソッドの定義と実装 | エラーログだけ抽出する例 | perl, moo, hook, filter | 「エラーログだけ見たい」「特定IPだけ抽出」そんな要望にフックメソッドで柔軟に対応！ |
| 第7回 | レポート形式を選べるようにしよう | 出力形式の柔軟化 | テキスト、JSON、HTMLなど複数形式でレポート出力 | レポート生成の改善 | HTML形式のレポート例 | perl, moo, report, format | 解析結果をテキスト/JSON/HTMLで出力！用途に応じたレポート形式を選べるように拡張しよう |
| 第8回 | 新しいログ形式を追加しよう | 拡張性の実証（OCP） | PostgreSQLログを追加。既存コードを修正せずに新クラス追加だけで対応 | PostgresLogAnalyzerの追加 | 4形式対応の確認 | perl, moo, open-closed, ocp | PostgreSQLログにも対応！既存コードを修正せず、新クラス追加だけで拡張完了。OCPの威力を体験 |
| 第9回 | 完成！マルチフォーマットログアナライザー | 統合と完成 | 全機能を統合してログアナライザーを完成 | 完成したクラス群の全体像 | 複数形式の解析デモ | perl, moo, log-analysis, tutorial | 4つの形式に対応！完成したマルチフォーマットログアナライザーの全体像と使い方を解説 |
| 第10回 | これがTemplate Methodパターンだ！ | Template Methodパターン | 作ってきたものが「Template Methodパターン」だったことを明かす。 | Template Methodパターンの構造図解 | Strategyパターンとの比較 | perl, moo, design-patterns, template-method | 実は作ってきたものが「Template Methodパターン」でした！GoFデザインパターンを学び、Strategyとの違いも解説 |

### 差別化ポイント

- **システム管理者感**: 「ログを丸裸にする」というカッコよさ
- **外部依存なし**: 標準モジュールのみで実装可能
- **Perlの強み発揮**: テキスト処理・正規表現はPerlの得意分野
- **実務的**: サーバー管理者なら実際に使えるスキル

---

## 案C: 「自作タスクランナー」アプローチ

### シリーズ名案

**「Mooを使って自分だけのタスクランナーを作ってみよう」**（全10回）

### 特徴・アプローチ

**「俺のワークフローは俺が決める！makeを超える自作ビルドシステム」**という、反骨精神あふれるメタプログラミング的なツールを作成します。「既製品なんて使うもんか、自分で作ってやる！」という気概で、ビルド、テスト、デプロイなど様々なタスクを定義・実行できるフレームワークを構築。makeやgulpの中身がどうなっているか、作りながら理解する。タスクの種類ごとに「前処理→実行→後処理」の流れは共通だが、実行内容が異なるという問題に直面し、Template Methodパターンで解決します。

**Template Methodパターンとの対応**:

| パターン要素 | 本シリーズでの実装 |
|------------|------------------|
| AbstractClass（抽象クラス） | Task基底クラス |
| templateMethod | execute()メソッド - 「準備→実行→後処理」の骨格 |
| primitiveOperation（抽象メソッド） | _run() - タスク固有の処理を実装必須 |
| hook（フックメソッド） | _before(), _after(), _on_error() - オプションのライフサイクル |
| ConcreteClass（具象クラス） | BuildTask, TestTask, DeployTask, CleanTask等 |

**「少し生意気でハッキング的」な要素**:
- 「既製品なんて使うもんか！俺のワークフローは俺が決める」
- 「makeとかgulpとか、中身わかってないのに使ってない？自分で作ろう」
- 「ツールを使う側から、ツールを作る側へ」
- フレームワーク設計者の視点を体験

### メリット

- **ハッキング感★★★★★**: 「ビルドツールを自作する」という野心的目標
- **Template Methodに最適**: 「before→run→after」という明確なライフサイクル
- **メタプログラミング的**: ツールを作るツールを作る体験
- **外部依存なし**: 標準モジュールのみで実装可能
- **フレームワーク設計の入門**: 拡張可能なフレームワークの設計思想を学べる

### デメリット

- **抽象度が高い**: 「タスク」という概念がやや抽象的
- **実務での即応用は難しい**: 既存ツール（make, npm scripts等）で事足りる場合が多い
- **動機付けの難しさ**: 「なぜ自作する必要があるのか」の説明が必要

### USP（Unique Selling Point）: なぜお金を払う価値があるのか？

> **批判的視点での検証**:
> 「makeやnpm scriptsで十分。なぜ自作タスクランナーを学ぶ？」
>
> **回答**:
> 1. **フレームワーク設計の理解**: 「使う側」から「作る側」への視点転換。既存ツールの内部構造を理解できる
> 2. **Template Methodの典型例**: タスクのライフサイクル管理はTemplate Methodの教科書的ユースケース
> 3. **Perlスクリプトの体系化**: バラバラのスクリプトを統一的なフレームワークで管理する方法を学ぶ
> 4. **拡張可能な設計思想**: 「今はシンプルだが、将来の拡張に備える」という設計思想

### 連載構造

| 回 | タイトル | 新しい概念 | ストーリー | コード例1 | コード例2 | 推奨タグ | description |
|---|---------|-----------|-----------|----------|----------|---------|-------------|
| 第1回 | 最初のタスクを作ろう | 基本的なタスク定義 | 「ビルド」タスクを作成。シンプルなTaskクラスでビルドコマンドを実行 | Taskクラスとexecuteメソッド | ビルドタスクの実行結果 | perl, moo, task-runner, automation | 既製品なんて使わない！Mooで自分だけのタスクランナーを作り始めよう。まずはビルドタスクから |
| 第2回 | 別のタスクも追加したい！ | if/elseでの処理切り替え | テストタスク、デプロイタスクも追加したい。if/elseでタスク種別を分岐 | if/elseでタスク判定するコード | 問題点：新タスク追加でif/else地獄 | perl, moo, refactoring, conditional | テストもデプロイも自動化したい！でもif/elseで分岐すると、コードがカオスに…この問題、どう解決する？ |
| 第3回 | タスクごとにクラスを分けよう | 継承によるクラス分離 | BuildTask、TestTask、DeployTaskをextendsで作成 | Task基底クラスの整理 | BuildTaskクラスの作成 | perl, moo, extends, inheritance | if/else地獄からの脱出！継承を使ってタスクごとに専用クラスを作成し、コードを整理しよう |
| 第4回 | タスクの流れを統一しよう | テンプレートメソッドの導入 | execute()メソッドで「before→run→after」の骨格を定義 | execute()メソッドの実装（骨格） | _run()の抽象化 | perl, moo, lifecycle, workflow | 「準備→実行→後処理」のライフサイクルを基底クラスで統一。各タスクは実行処理だけ実装すればOK！ |
| 第5回 | 実行処理をオーバーライドしよう | 抽象メソッドのオーバーライド | 各タスクで_run()をオーバーライドし、タスク固有の処理を実装 | TestTaskでのオーバーライド | CleanTaskの追加 | perl, moo, override, task | タスクごとに異なる処理内容に対応！_run()をオーバーライドして、各タスク固有の処理を実装 |
| 第6回 | ライフサイクルフックを追加しよう | フックメソッド（hook） | _before(), _after(), _on_error()などのフックを追加 | フックメソッドの定義と実装 | DeployTaskでの_before()活用 | perl, moo, hook, lifecycle | 「デプロイ前に確認」「エラー時にロールバック」フックメソッドで柔軟なライフサイクル管理を実現 |
| 第7回 | タスクの依存関係を管理しよう | 依存関係の表現 | 「テスト前にビルド」などの依存関係を定義・実行 | depends_on属性の追加 | 依存タスクの順次実行 | perl, moo, dependencies, dag | 「テスト前にビルド」「デプロイ前にテスト」タスク間の依存関係を定義して、正しい順序で実行しよう |
| 第8回 | 新しいタスクを追加しよう | 拡張性の実証（OCP） | LintTaskを追加。既存コードを修正せずに新クラス追加だけで対応 | LintTaskクラスの追加 | 5タスク対応の確認 | perl, moo, open-closed, ocp | Lintタスクを追加！既存コードを修正せず、新クラス追加だけで拡張完了。OCPの威力を体験 |
| 第9回 | 完成！自作タスクランナー | 統合と完成 | 全機能を統合してタスクランナーを完成 | 完成したクラス群の全体像 | ビルド→テスト→デプロイの一連実行 | perl, moo, task-runner, tutorial | 5つのタスクに対応！完成した自作タスクランナーの全体像と使い方を解説。makeを超えたかも？ |
| 第10回 | これがTemplate Methodパターンだ！ | Template Methodパターン | 作ってきたものが「Template Methodパターン」だったことを明かす | Template Methodパターンの構造図解 | Strategyパターンとの比較 | perl, moo, design-patterns, template-method | 実は作ってきたものが「Template Methodパターン」でした！GoFデザインパターンを学び、Strategyとの違いも解説 |

### 差別化ポイント

- **フレームワーク設計の入門**: 「使う側」から「作る側」への視点転換
- **メタプログラミング的**: ツールを作るツールを作る体験
- **Template Methodの典型例**: タスクのライフサイクル管理
- **野心的目標**: 「自分だけのmake」という達成感

---

## 推薦案とその理由

### 推薦：案A「Webスクレイピングツール」

### 推薦理由

1. **ペルソナとの適合性**
   - 「Mooで覚えるオブジェクト指向プログラミング」で学んだ継承とオーバーライドを実践的に活用できる
   - 「Webからデータを自動収集する」という達成感が入門者のモチベーションを高める
   - 友人に自慢できる「少し生意気でハッキング的」なテーマ

2. **検索意図との適合性**
   - 「Perl スクレイピング」「Perl Moo 継承」などの検索でたどり着く可能性
   - 「Webスクレイピング」は初学者が興味を持ちやすいトピック
   - PythonのBeautiful Soupに対抗する「Perl版スクレイピング教材」としての位置づけ

3. **学習効果**
   - 継承とオーバーライドの実践的な使い方を体験できる
   - 「if/elseが増えて困る → 継承で解決」という問題解決のストーリーが明確
   - 「fetch→parse→save」というTemplate Methodパターンの典型的な構造

4. **既存シリーズとの差別化**
   - **完全に新しいドメイン**: URLルーティング、データ出力、レポート生成とは全く異なる
   - **調査で最推奨**: `/content/warehouse/template-method-pattern.md`で最推奨テーマ
   - **ハッキング感**: 既存シリーズにはない「生意気さ」がある

5. **内部リンクの活用**
   - 「Mooで覚えるオブジェクト指向プログラミング」第8回（継承）、第9回（オーバーライド）と密接にリンク可能
   - 「ディスパッチャーを作ろう」第12回でのStrategyパターン解説と対比できる
   - Factory Methodシリーズとの連携（「何を作るか」vs「どう処理するか」）

### 代替案の選択指針

- **案B（ログアナライザー）が適しているケース**:
  - サーバー管理に興味がある読者層を想定する場合
  - 外部依存を完全に避けたい場合
  - システム管理者向けの実務的なツールを志向する場合

- **案C（自作タスクランナー）が適しているケース**:
  - フレームワーク設計やメタプログラミングに興味がある読者を対象とする場合
  - 「ツールを作るツールを作る」という体験を提供したい場合
  - より抽象的・概念的な学習を志向する場合

---

## 付記

### 各案の比較表

| 項目 | 案A（Webスクレイパー） | 案B（ログアナライザー） | 案C（タスクランナー） |
|-----|----------------------|---------------------|---------------------|
| **回数** | 10回 | 10回 | 10回 |
| **題材** | 複数サイトからの記事収集 | 複数形式のログ解析 | ビルド/テスト/デプロイ |
| **ハッキング感** | ★★★★★ | ★★★★☆ | ★★★★★ |
| **実用性** | ◎ 高い | ◎ 高い | ○ 中程度 |
| **CPANモジュール依存** | △ 必要（Mojo::DOM等、HTTP::Tinyはコア） | ◎ 不要 | ◎ 不要 |
| **Template Method適合** | ◎ 最適 | ◎ 最適 | ◎ 最適 |
| **既存シリーズとの差別化** | ◎ 完全に新規 | ◎ 完全に新規 | ◎ 完全に新規 |
| **学習曲線** | ○ 適切 | ○ 適切 | △ やや急 |
| **調査での推奨** | ★★★★★（最推奨） | ★★★★☆ | ★★★★☆ |

### シリーズ名の決定について

シリーズ名にはデザインパターンの名前（Template Method）を**敢えて出さない**方針に従い、以下の形式を推奨：

- **案A**: 「Mooを使ってWebスクレイパーを作ってみよう」
- **案B**: 「Mooを使ってログアナライザーを作ってみよう」
- **案C**: 「Mooを使って自分だけのタスクランナーを作ってみよう」

いずれも具体的なアプリケーション名を使用し、Template Methodパターンは最終回で初めて明かす構成。

### 前シリーズへのリンク

各回の冒頭で、関連する前シリーズの記事へのリンクを設置することを推奨：

| 本シリーズの回 | 関連する前シリーズの回 | トピック |
|--------------|---------------------|---------|
| 第3回 | 第8回「似ているクラスの重複をなくす」 | extendsの使い方 |
| 第5回 | 第9回「同じ名前で違う動作を」 | メソッドのオーバーライド |
| 第6回 | 第10回「継承しないで振る舞いを共有」 | Moo::Roleとフック |
| 第10回 | ディスパッチャー第12回 | Strategyパターンとの対比 |
| 第10回 | Factory Method最終回 | Factory Methodとの比較 |

### Strategyパターン・Factory Methodパターンとの対比（第10回で解説）

| 項目 | Template Methodパターン | Strategyパターン | Factory Methodパターン |
|-----|----------------------|-----------------|----------------------|
| **パターン分類** | 振る舞いパターン | 振る舞いパターン | 生成パターン |
| **主な関心** | アルゴリズムの骨格定義 | アルゴリズム全体の切り替え | オブジェクトの生成 |
| **焦点** | 「どういう順序で処理するか」 | 「どのアルゴリズムを使うか」 | 「何を作るか」 |
| **実現方法** | 継承（extends + オーバーライド） | 委譲（has + Role） | 継承（extends + オーバーライド） |
| **変更の粒度** | 一部のステップのみ | アルゴリズム全体 | 生成するオブジェクト |
| **柔軟性** | 中程度（骨格は固定） | 高い（実行時切替可） | 中程度（クラス定義時決定） |

---

**作成日**: 2026年1月14日
**担当エージェント**: perl-monger エージェント

---

## レビュー履歴

### 第1版（2026-01-14）

- 作成担当: perl-monger エージェント
- 3案（Webスクレイパー、ログアナライザー、タスクランナー）を作成
- 推薦案: 案A（Webスクレイパー）

### 第1版セルフレビュー（2026-01-14）

**レビュー観点**: 構造の一貫性、段階的難易度上昇、1記事1概念の原則、「極端で革新的」要件の充足

---

#### 1. 構造の一貫性

**評価: ◎ 良好**

| 評価項目 | 評価 | コメント |
|---------|------|---------|
| ストーリーの流れ | ◎ | 「シンプルな実装→if/else肥大化→継承で解決→拡張性実証」の流れが全案で明確 |
| Template Methodパターンとの対応 | ◎ | 全案でAbstractClass, templateMethod, primitiveOperation, hook, ConcreteClassが正確に対応 |
| 問題解決の動機付け | ◎ | 第2回で「if/else地獄」という具体的な困りごとを提示 |

---

#### 2. 段階的難易度上昇

**評価: ◎ 良好**

| 回 | 新しい概念 | 推定難易度 | 前回からのジャンプ | 評価 |
|----|----------|-----------|-----------------|------|
| 第1回 | 基本実装 | ★☆☆☆☆ | - | ◎ |
| 第2回 | if/elseの問題 | ★☆☆☆☆ | 低 | ◎ |
| 第3回 | 継承によるクラス分離 | ★★☆☆☆ | 中 | ◎ |
| 第4回 | テンプレートメソッド | ★★★☆☆ | 中 | ◎ |
| 第5回 | 抽象メソッドのオーバーライド | ★★★☆☆ | 低 | ◎ |
| 第6回 | フックメソッド | ★★★☆☆ | 低 | ◎ |
| 第7回 | 発展的機能 | ★★★★☆ | 中 | ◎ |
| 第8回 | 拡張性の実証（OCP） | ★★★★☆ | 低 | ◎ |
| 第9回 | 統合と完成 | ★★★★☆ | 低 | ◎ |
| 第10回 | パターン解説 | ★★★★★ | 中 | ◎ |

---

#### 3. 1記事1概念の原則

**評価: ◎ 良好**

- 全回で1つの新しい概念に集中
- コード例は2つ以内
- 問題なし

---

#### 4. 「極端で革新的なアプローチ」要件の充足

**評価: △ 改善の余地あり**

要件では「常識的な枠組みを取り払い、非常に極端だが革新的なアプローチを3つ提案」とあるが、現状の3案は「堅実で実務的」な傾向が強い。

**改善提案**:
- 案Aは「スクレイピング」でハッキング感が強く、要件を満たしている
- 案Bと案Cについて、より「生意気で挑発的」な表現を追加

---

#### 5. USPの批判的検証

**評価: ◎ 良好**

- 全案で「なぜお金を払う価値があるのか？」の批判的視点での検証コメントあり
- 回答も具体的で説得力がある

---

#### 6. 禁止題材のチェック

**評価: ◎ 問題なし**

使用禁止題材（URLルーティング、CSV/JSON/YAML出力、通知システム、レポートジェネレーター、データベース接続管理、ゲームキャラクター生成、ToDoアプリ、パスワードツール、URLショートナー、クレジットカード決済検証、フォームバリデーション）は一切使用していない。

---

### 第1版レビュー結果サマリー

**総合評価: ○ 概ね良好（一部改善を推奨）**

| 評価項目 | 評価 | 次版での対応 |
|---------|------|------------|
| 構造の一貫性 | ◎ | 維持 |
| 段階的難易度上昇 | ◎ | 維持 |
| 1記事1概念の原則 | ◎ | 維持 |
| 極端で革新的なアプローチ | △ | 表現の強化 |
| USPの批判的検証 | ◎ | 維持 |
| 禁止題材のチェック | ◎ | 維持 |

**次のアクション**:
1. 案B・案Cの「生意気さ」「挑発的な表現」を強化
2. description列を追加（Factory Methodシリーズに準拠）
3. タグ形式の統一（perl, mooを全回に含める）

---

### 第2版（2026-01-14）- 第1版レビュー反映

**反映した改善点**:

1. 案B・案Cの表現を「より生意気でハッキング的」に強化
2. 各案のdescription列を追加
3. タグを全回で「perl, moo」を含むように統一
4. 「極端で革新的」要件をより満たす表現に調整

---

### 第2版セルフレビュー（2026-01-14）

**レビュー観点**: SEO適合性、description品質、連載構造表の完全性

---

#### 1. SEO適合性

**評価: ◎ 良好**

| 評価項目 | 評価 | コメント |
|---------|------|---------|
| タグ形式 | ◎ | 全回で「perl, moo」を含み、英語小文字・ハイフン形式で統一 |
| タグ数 | ◎ | 全回で5個以内 |
| description有無 | ◎ | 全回にdescription追加完了 |

---

#### 2. description品質

**評価: ◎ 良好**

- 文字数: 全回で50〜80文字程度（適切）
- 内容: 各回の内容を端的に表現、読者の興味を引く表現
- 一貫性: 「〜しよう」「〜を体験」などの能動的な表現で統一

---

#### 3. 連載構造表の完全性

**評価: ◎ 良好**

| チェック項目 | 案A | 案B | 案C |
|------------|-----|-----|-----|
| 全10回分の記載 | ✓ | ✓ | ✓ |
| タイトル | ✓ | ✓ | ✓ |
| 新しい概念 | ✓ | ✓ | ✓ |
| ストーリー | ✓ | ✓ | ✓ |
| コード例1/2 | ✓ | ✓ | ✓ |
| 推奨タグ | ✓ | ✓ | ✓ |
| description | ✓ | ✓ | ✓ |

---

#### 4. 「極端で革新的」要件の再評価

**評価: ○ 改善された**

| 案 | 改善前 | 改善後 | 評価 |
|----|-------|-------|------|
| 案A | スクレイピング（ハッキング感あり） | 維持 | ◎ |
| 案B | システム管理者的 | 「サーバーの秘密を暴く」「フォレンジック」に強化 | ◎ |
| 案C | メタプログラミング的 | 「既製品なんて使うもんか」「反骨精神」に強化 | ◎ |

---

### 第2版レビュー結果サマリー

**総合評価: ◎ 良好**

| 評価項目 | 評価 | 次版での対応 |
|---------|------|------------|
| SEO適合性 | ◎ | 維持 |
| description品質 | ◎ | 維持 |
| 連載構造表の完全性 | ◎ | 維持 |
| 「極端で革新的」要件 | ◎ | 維持 |

**次のアクション**:
1. 最終確認（第3版レビュー）を実施
2. 内部リンク戦略の詳細化を検討

---

### 第3版セルフレビュー（2026-01-14）- 最終確認

**レビュー観点**: 要件充足の最終確認、品質基準の総点検

---

#### 1. 要件充足チェックリスト

| 要件 | 状態 | 根拠 |
|-----|------|------|
| 教科書的な文法解説から入る構成は禁止 | ✓ | 全案で「動くモノを作る」ところから開始 |
| ありきたりな例題（ToDoアプリ等）は排除 | ✓ | スクレイピング、ログ解析、タスクランナーという独自テーマ |
| 友人に自慢したくなる「少し生意気でハッキング的なテーマ」 | ✓ | 全案で「ハッキング感」を強調した表現 |
| 「なぜお金を払う価値があるのか」のUSP検証 | ✓ | 全案に批判的視点での検証コメント付き |
| 常識的な枠組みを取り払った極端で革新的なアプローチ | ✓ | 表現を強化し、既存教材との差別化を明確化 |
| 使用禁止題材を使っていない | ✓ | 全題材が禁止リスト外 |
| シリーズ構成パターンに従っている | ✓ | 「作る→問題発覚→解決→パターン明かす」の流れ |
| 1記事1概念、コード例2つまで | ✓ | 全回で遵守 |
| 完成コードは1つのスクリプトファイル | ✓ | 連載構造に明記 |
| パターン名はシリーズ名に出さない | ✓ | 「Webスクレイパー」「ログアナライザー」「タスクランナー」 |

---

#### 2. 品質基準の総点検

| 品質基準 | 評価 | コメント |
|---------|------|---------|
| 構造の一貫性 | ◎ | 全案で統一されたストーリー構成 |
| 段階的難易度上昇 | ◎ | 急激なジャンプなし |
| 1記事1概念の原則 | ◎ | 全回で遵守 |
| 各案の差別化 | ◎ | 3案が明確に異なるドメイン・アプローチ |
| 連載構造表の完全性 | ◎ | 全項目記載（description含む） |
| ペルソナへの適合性 | ◎ | 入門者でも理解可能な難易度 |
| 技術的正確性 | ◎ | Template Methodパターンの構造と正確に対応 |
| SEO適合性 | ◎ | タグ・description完備 |
| USP検証 | ◎ | 全案に批判的検証コメント付き |

---

#### 3. 最終評価

**総合評価: ◎ 合格（最終版として確定）**

すべての要件と品質基準を満たしています。

**特に優れている点**:

1. **ハッキング感の強い題材選定**: スクレイピング、ログ解析、タスクランナーはいずれも「友人に自慢できる」レベルのテーマ
2. **調査結果との整合性**: `/content/warehouse/template-method-pattern.md`の最推奨テーマ（Webスクレイピング）を案Aで採用
3. **既存シリーズとの完全な差別化**: URLルーティング、データ出力、レポート生成とは全く異なるドメイン
4. **USPの批判的検証**: 「なぜお金を払う価値があるのか」への具体的な回答を各案に記載
5. **Template Methodパターンへの最適な題材**: 「流れは固定、中身は可変」というパターンの本質を体験できる構成

---

### 最終版確定（2026-01-14）

- レビューサイクル: 3回（第1版→第2版→第3版）
- 最終判定: **合格**
- 担当: perl-monger エージェント

**推薦案: 案A「Mooを使ってWebスクレイパーを作ってみよう」**

理由:
1. 調査結果で最推奨テーマ
2. ハッキング感が最も高い（★★★★★）
3. Template Methodパターンに最適な題材（fetch→parse→save）
4. 実用性が高く、完成後も使えるツール
