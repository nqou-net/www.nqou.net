# パターンDNA解析報告書: Flyweight

> 生成元: `agents/prompts/pattern-dna-flyweight.md`
> 担当: Code Doctor Planning Agent

## 1. 症状カタログ

患者（Leo氏）のコードから検出された主な症状は以下の通りです。

| # | 症状名 | 説明 | 重症度 | 処方候補 |
|---|--------|------|--------|---------|
| 1 | **インスタンス増殖症** | 1万本以上の「木」オブジェクト生成により、ヒープメモリが限界に達している。`Tree` クラスのインスタンスが大量にメモリを占有。 | **重症** | Flyweight |
| 2 | **冗長状態肥大化** | 全ての木が同じ「モデルデータ（ポリゴン）」と「テクスチャ」を個別に保持している。`Tree` インスタンスごとのメモリオーバーヘッドが巨大。 | **中症** | Flyweight |
| 3 | **初期化遅延** | ゲーム開始時に1万個のテクスチャ読み込みが発生し、ロード時間が許容範囲を超えている。 | **中症** | Flyweight (Factory) |

---

## 2. DNA解析マップ: Flyweight

今回の症例に対する Flyweight パターンの適用分析結果です。

### パターン: Flyweight
- **メカニズム**:
    - オブジェクトを **Intrinsic State (共有可能/不変)** と **Extrinsic State (固有/可変)** に分離する。
    - Intrinsic State は Factory 経由で共有インスタンスを取得する。
    - Extrinsic State はクライアント（利用側）または軽量なコンテキストオブジェクトが保持し、メソッド呼び出し時に Intrinsic オブジェクトに渡す。

- **適応症状**:
    - **インスタンス増殖症**: オブジェクト総数を物理的に減らす（または軽量化する）ことで劇的に改善。
    - **冗長状態肥大化**: 重いデータ（Intrinsic）をシングルトン的に共有し、重複を排除。

- **禁忌 (Contraindications)**:
    - **状態依存が激しいオブジェクト**: 全てのプロパティが個別に変化する場合、共有できる部分がなく効果が薄い。
    - **プール管理のオーバーヘッド**: オブジェクト数が少ない（数百個程度）場合、Factory の管理コストが上回る可能性がある（過剰処方）。

- **副作用 (Side Effects)**:
    - **コードの複雑化**: 状態の分離により、直感的な `obj->method()` が `obj->method($context)` になり、呼び出しが少し面倒になる。
    - **実行速度の低下**: 都度計算や参照解決が発生する場合、CPU負荷がわずかに増える可能性がある（メモリ vs CPU のトレードオフ）。

---

## 3. 治療計画案

### 案A: 【王道】100万本の森（推奨）

大規模ゲームマップにおける「木」の描画を最適化する、最も視覚的で分かりやすいプラン。

- **テーマ**: オープンワールドゲームの植林
- **ストーリー**: 開発中のRTSゲームで、マップに森を作ったらメモリ不足でクラッシュ。「木」一本一本が重すぎるのが原因。
- **実装**:
    - **Before**: `Tree` クラスが `mesh`, `texture`, `x`, `y` を全て持つ。
    - **After**:
        - `TreeModel` (Intrinsic): `mesh`, `texture` を持つ（種類ごとに1つ）。
        - `Tree` (Extrinsic): `x`, `y`, `model_ref` を持つ軽量オブジェクト。
        - `TreeFactory`: `TreeModel` のキャッシュと提供。
- **Before/After (予測)**:
    - メモリ使用量: 1.2GB → 50MB (95%削減)
    - インスタンス生成時間: 5.0s → 0.2s

### 案B: 【変化球】リッチテキストエディタ

文字（Glyph）をオブジェクトとして扱うエディタ開発。

- **テーマ**: 文字装飾機能付きテキストエディタ
- **ストーリー**: 文字ごとにフォント情報を持つ設計にしたら、長文を開くと重くなる。
- **実装**:
    - **Before**: `Char` オブジェクトが `font`, `size`, `color`, `char_code` を持つ。
    - **After**:
        - `FontData` (Intrinsic): フォントリソース。
        - `GlyphContext`: 文字コードと位置。
- **メリット**: 身近な例だが、Perlの文字列処理と混同しやすいリスクあり。

### 案C: 【実務寄り】パケットヘッダ共有

大量のネットワークパケット処理システム。

- **テーマ**: 高負荷ログ収集サーバー
- **ストーリー**: 毎秒数万件のログパケットをオブジェクト化して処理していたらGCが追いつかない。
- **実装**:
    - 共通するヘッダ情報（送信元IP、プロトコル版数など）を Flyweight 化。
- **メリット**: 硬派でバックエンド寄りだが、地味で視覚的インパクトに欠ける。

---

## 4. 推薦案とその理由

### 推奨: 案A（100万本の森）

**理由**:
1. **「コードドクター」との相性**: メモリリーク（肥大化）という「症状」が視覚的に（森として）イメージしやすく、手術（リファクタリング）の効果が劇的。
2. **患者プロファイル適合**: 患者 Leo はゲーム開発者であり、まさに直面している問題そのもの。
3. **パターンの本質**: 「Intrinsic（共有）」と「Extrinsic（固有）」の分離という概念を、木の種類（共有）と植える場所（固有）という対比で最も直感的に説明できる。

## 5. 選定結果

- **採用案**: 案A
- **選定日**: 2026-02-04
- **選定理由**: ユーザーによる承認。視覚的インパクトが大きく、Flyweightパターンの本質を説明するのに最適。

## 6. 治療設定（案A採用時）

- **タグ**: `flyweight`, `design-patterns`, `perl`, `game-dev`, `optimization`
- **記事構成（統合版）**:
    1. **緊急搬送**: 「先生！森が…森がメモリを食いつくしています！」
    2. **診断**: ヒープダンプを見ると、同じ「杉の木」データが何千個も複製されている。これは「インスタンス増殖症」だ。
    3. **手術 (Phase 1)**: `TreeModel` (Intrinsic) の抽出。共有できるデータを切り出す。
    4. **手術 (Phase 2)**: `TreeFactory` の実装。種類ごとに1つだけ作る仕組み。
    5. **手術 (Phase 3)**: クライアントコードの修正。座標（Extrinsic）だけを渡して描画。
    6. **退院**: 100万本の木を植えてもメモリはスカスカ。ドクター「軽くなったな」助手「先生の財布も軽いですね…」
