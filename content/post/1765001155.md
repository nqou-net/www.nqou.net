---
title: "GitHub Copilot エージェントパネル入門 - 第5回: 複数エージェントの協調動作"
description: "複数のエージェントを連携させるオーケストレーション手法を解説。パイプライン構築、並列実行、エラーハンドリングまで実践的に学ぶ"
date: 2025-12-06T15:00:00+09:00
draft: true
tags:
  - GitHub
  - Copilot
  - Agent Panel
  - オーケストレーション
  - パイプライン
image: /favicon.png
---

## はじめに

[@nqounet](https://x.com/nqounet)です。

第5回では、複数のエージェントを協調動作させる方法を学びます。個々のエージェントを組み合わせることで、より複雑で強力なワークフローを構築できます。

前回のおさらい：エージェント設定ファイルの詳細、パラメータ、環境変数、依存関係について学びました。

## エージェントオーケストレーションとは

複数のエージェントを連携させ、一連の処理を自動化する仕組みです。

### 単一エージェント vs オーケストレーション

```
【単一エージェント】
入力 → エージェントA → 出力

【オーケストレーション】
入力 → エージェントA → エージェントB → エージェントC → 出力
         ↓
       エージェントD
```

## ワークフローの種類

### 1. 直列処理（Sequential）

各エージェントを順番に実行：

```yaml
---
name: code-quality-pipeline
description: コード品質チェックパイプライン
version: 1.0.0

workflow:
  type: sequential
  steps:
    - agent: syntax-checker
      name: "構文チェック"
      continueOnError: false
    
    - agent: style-formatter
      name: "スタイル整形"
      continueOnError: true
      parameters:
        autoFix: true
    
    - agent: security-scanner
      name: "セキュリティスキャン"
      continueOnError: false
    
    - agent: test-generator
      name: "テスト生成"
      continueOnError: true
---
```

実行イメージ：
```
[Step 1/4] 構文チェック実行中...
  ✓ 完了 (2.3s)

[Step 2/4] スタイル整形実行中...
  ✓ 完了 (1.8s) - 15ファイル更新

[Step 3/4] セキュリティスキャン実行中...
  ✓ 完了 (5.1s) - 問題なし

[Step 4/4] テスト生成実行中...
  ✓ 完了 (3.2s) - 8テスト追加

総実行時間: 12.4秒
```

### 2. 並列処理（Parallel）

複数のエージェントを同時実行：

```yaml
workflow:
  type: parallel
  maxConcurrency: 3
  steps:
    - agent: eslint-checker
      name: "ESLint チェック"
    
    - agent: prettier-formatter
      name: "Prettier チェック"
    
    - agent: typescript-checker
      name: "TypeScript型チェック"
    
    - agent: import-sorter
      name: "import文ソート"
  
  # 全並列処理完了後に実行
  finally:
    - agent: report-generator
      name: "レポート生成"
```

実行イメージ：
```
[並列実行] 3エージェント同時実行中...
  [1/4] ESLint チェック... ✓ (3.2s)
  [2/4] Prettier チェック... ✓ (2.1s)
  [3/4] TypeScript型チェック... ✓ (4.5s)
  [4/4] import文ソート... ✓ (1.3s)

[Finally] レポート生成... ✓ (0.8s)

総実行時間: 5.3秒（並列化により高速化）
```

### 3. 条件分岐（Conditional）

条件に応じてエージェントを実行：

```yaml
workflow:
  type: conditional
  steps:
    - agent: file-analyzer
      name: "ファイル解析"
      output: analysis_result
    
    - condition:
        if: "${analysis_result.language} == 'typescript'"
        then:
          - agent: ts-specific-checker
        else:
          - agent: js-checker
    
    - condition:
        if: "${analysis_result.hasTests} == false"
        then:
          - agent: test-generator
            parameters:
              coverage: "high"
```

### 4. ループ処理（Iteration）

複数のファイルやディレクトリに対して繰り返し実行：

```yaml
workflow:
  type: iteration
  iterate:
    over: "${workspace.files}"
    filter: "**/*.ts"
    batchSize: 10
  
  steps:
    - agent: type-checker
      input: "${item}"
    
    - agent: documentation-generator
      input: "${item}"
      parameters:
        outputPath: "${item.dir}/README.md"
```

## データの受け渡し

### エージェント間のデータフロー

```yaml
workflow:
  type: sequential
  steps:
    # Step 1: コード解析
    - agent: code-analyzer
      name: "コード解析"
      output: code_analysis  # 出力を変数に保存
      parameters:
        detailed: true
    
    # Step 2: 解析結果を使用
    - agent: refactoring-suggester
      name: "リファクタリング提案"
      input: "${code_analysis}"  # 前のステップの出力を入力
      output: refactoring_plan
    
    # Step 3: 複数の入力を使用
    - agent: code-transformer
      name: "コード変換"
      parameters:
        analysis: "${code_analysis}"
        plan: "${refactoring_plan}"
        applyChanges: false  # まずは提案のみ
```

### データ変換とフィルタリング

```markdown
---
name: data-pipeline-agent
version: 1.0.0
---

# データパイプラインエージェント

## データ変換

前のエージェントの出力を加工して次に渡します：

### 入力データ（from code-analyzer）
\`\`\`json
{
  "files": ["src/app.ts", "src/utils.ts"],
  "issues": [
    {"file": "src/app.ts", "line": 10, "severity": "high"},
    {"file": "src/utils.ts", "line": 5, "severity": "low"}
  ]
}
\`\`\`

### データ変換処理
\`\`\`javascript
// 重大な問題のみをフィルタ
const criticalIssues = input.issues
  .filter(issue => issue.severity === 'high');

// ファイルごとにグループ化
const issuesByFile = criticalIssues.reduce((acc, issue) => {
  if (!acc[issue.file]) acc[issue.file] = [];
  acc[issue.file].push(issue);
  return acc;
}, {});
\`\`\`

### 出力データ（to next agent）
\`\`\`json
{
  "criticalIssues": {
    "src/app.ts": [
      {"line": 10, "severity": "high", "message": "..."}
    ]
  },
  "totalCritical": 1
}
\`\`\`
```

## 実践例：コードレビューパイプライン

完全なコードレビューワークフローを構築してみましょう。

### パイプライン設計

```
┌────────────────┐
│ ファイル取得    │
└───────┬────────┘
        ↓
┌───────▼────────┐
│ 構文チェック    │────→ エラーなら終了
└───────┬────────┘
        ↓
   ┌────┴────┐
   │         │
┌──▼──┐  ┌──▼──┐
│ESLint│  │Prettier│
└──┬──┘  └──┬──┘
   │         │
   └────┬────┘
        ↓
┌───────▼────────┐
│セキュリティスキャン│
└───────┬────────┘
        ↓
┌───────▼────────┐
│ レポート生成    │
└────────────────┘
```

### ワークフロー定義

```yaml
---
name: comprehensive-code-review
description: 包括的なコードレビューパイプライン
version: 1.0.0

parameters:
  - name: targetBranch
    type: string
    default: "main"
  - name: autoFix
    type: boolean
    default: false

workflow:
  type: hybrid  # 直列と並列の組み合わせ
  
  # Phase 1: 前処理（直列）
  preparation:
    - agent: file-collector
      name: "変更ファイル収集"
      parameters:
        branch: "${parameters.targetBranch}"
        includeUnstaged: false
      output: changed_files
    
    - agent: syntax-validator
      name: "構文検証"
      input: "${changed_files}"
      continueOnError: false
      output: syntax_result
  
  # Phase 2: 並列チェック
  analysis:
    type: parallel
    maxConcurrency: 4
    steps:
      - agent: eslint-checker
        input: "${changed_files}"
        output: eslint_result
      
      - agent: prettier-checker
        input: "${changed_files}"
        parameters:
          autoFix: "${parameters.autoFix}"
        output: prettier_result
      
      - agent: type-checker
        input: "${changed_files}"
        output: type_result
      
      - agent: complexity-analyzer
        input: "${changed_files}"
        output: complexity_result
  
  # Phase 3: セキュリティスキャン（直列）
  security:
    - agent: security-scanner
      name: "セキュリティスキャン"
      input:
        files: "${changed_files}"
        eslintResult: "${eslint_result}"
      continueOnError: true
      output: security_result
  
  # Phase 4: レポート生成
  reporting:
    - agent: report-aggregator
      name: "結果集約"
      input:
        syntax: "${syntax_result}"
        eslint: "${eslint_result}"
        prettier: "${prettier_result}"
        types: "${type_result}"
        complexity: "${complexity_result}"
        security: "${security_result}"
      output: final_report
    
    - agent: markdown-reporter
      name: "Markdownレポート生成"
      input: "${final_report}"
      parameters:
        outputFile: "code-review-report.md"
        includeStats: true
---

# レポート集約エージェント

## 各エージェントの結果を統合

### 入力
- 構文チェック結果
- ESLint結果
- Prettier結果
- 型チェック結果
- 複雑度分析結果
- セキュリティスキャン結果

### 処理
1. すべての問題を収集
2. 重要度でソート
3. ファイルごとにグループ化
4. 統計情報を計算

### 出力形式
\`\`\`json
{
  "summary": {
    "totalFiles": 15,
    "totalIssues": 42,
    "critical": 3,
    "warnings": 25,
    "info": 14
  },
  "issuesByFile": {
    "src/app.ts": [...]
  },
  "recommendations": [...]
}
\`\`\`
```

## エラーハンドリング

### エラー処理戦略

```yaml
workflow:
  # グローバルエラーハンドリング
  errorHandling:
    strategy: "continue-on-error"  # or "fail-fast"
    maxErrors: 5
    notifyOn: ["critical-error", "timeout"]
  
  steps:
    - agent: risky-operation
      name: "リスキーな操作"
      timeout: 30000
      retryOnError: true
      maxRetries: 3
      retryDelay: 1000
      
      # ステップ固有のエラーハンドリング
      onError:
        - action: log
          message: "risky-operation failed: ${error.message}"
        
        - action: notify
          channels: ["slack", "email"]
        
        - action: fallback
          agent: safe-alternative
      
      onTimeout:
        - action: cancel
        - action: log
          message: "Operation timed out after 30s"
```

### エラーの種類と対応

```markdown
## エラー処理ガイド

### 1. バリデーションエラー
\`\`\`
Error: Invalid parameter 'language': expected one of [js, ts], got 'jsx'
\`\`\`
**対応**: パラメータを修正して再実行

### 2. 依存関係エラー
\`\`\`
Error: Required agent 'security-scanner' not found
\`\`\`
**対応**: 依存エージェントをインストール

### 3. タイムアウトエラー
\`\`\`
Error: Agent 'code-analyzer' timed out after 60000ms
\`\`\`
**対応**: 
- タイムアウト時間を延長
- 処理対象を分割
- より効率的なエージェントを使用

### 4. データ形式エラー
\`\`\`
Error: Expected object, got array at step 'report-generator'
\`\`\`
**対応**: データ変換エージェントを挿入

### 5. ランタイムエラー
\`\`\`
Error: Uncaught exception in agent 'custom-analyzer'
\`\`\`
**対応**: エージェントのログを確認し、バグを修正
```

## 実行状態の監視

### リアルタイムモニタリング

```markdown
## パイプライン実行状況

\`\`\`
┌─────────────────────────────────────────┐
│ Code Quality Pipeline                   │
│ Status: Running (Step 3/7)              │
│ Elapsed: 15.3s / Est. Total: 45s       │
└─────────────────────────────────────────┘

[✓] Step 1: File Collection (2.1s)
[✓] Step 2: Syntax Check (3.5s)
[▶] Step 3: Parallel Analysis (running)
    [✓] ESLint (4.2s)
    [▶] Prettier (running, 5.3s)
    [▶] Type Check (running, 5.3s)
    [⏳] Complexity (waiting)
[ ] Step 4: Security Scan
[ ] Step 5: Test Coverage
[ ] Step 6: Report Generation
[ ] Step 7: Notification

Current Memory: 245MB / 512MB
Current CPU: 65%
\`\`\`
```

### ログと診断

```yaml
workflow:
  # ログ設定
  logging:
    level: "info"  # debug, info, warn, error
    destination: ".agent-logs"
    format: "json"
    includeTimestamps: true
    
  # 診断情報
  diagnostics:
    enabled: true
    captureOutput: true
    captureErrors: true
    profilePerformance: true
```

ログ出力例：
```json
{
  "timestamp": "2025-12-06T15:30:45.123Z",
  "level": "info",
  "workflow": "comprehensive-code-review",
  "step": "eslint-checker",
  "message": "Processing 15 files",
  "metadata": {
    "fileCount": 15,
    "estimatedTime": "4.5s"
  }
}
```

## パフォーマンス最適化

### 並列化のベストプラクティス

```yaml
# ❌ 悪い例：すべて直列
workflow:
  type: sequential
  steps:
    - agent: eslint      # 3s
    - agent: prettier    # 2s
    - agent: typescript  # 4s
    - agent: security    # 5s
  # 総時間: 14秒

# ✅ 良い例：独立したタスクを並列化
workflow:
  type: sequential
  steps:
    # 並列化可能なタスク
    - type: parallel
      steps:
        - agent: eslint     # 3s
        - agent: prettier   # 2s
        - agent: typescript # 4s
      # 最長の4秒で完了
    
    # 依存関係があるため直列
    - agent: security  # 5s
  # 総時間: 9秒（36%高速化）
```

### キャッシングの活用

```yaml
workflow:
  # キャッシュ設定
  cache:
    enabled: true
    strategy: "content-hash"
    ttl: 3600
    
  steps:
    - agent: expensive-analyzer
      cache:
        key: "${file.path}-${file.hash}"
        invalidateOn:
          - file-changed
          - dependencies-updated
```

## 動作確認チェックリスト

- [ ] 直列ワークフローを作成し実行した
- [ ] 並列ワークフローを作成し実行した
- [ ] エージェント間でデータを受け渡した
- [ ] 条件分岐を実装した
- [ ] エラーハンドリングを設定した
- [ ] 実行状態をモニタリングした
- [ ] キャッシングを活用した
- [ ] パフォーマンスを最適化した

## 次回予告

第6回では、ツール統合とAPI連携を学びます：

- 外部ツールの統合
- REST API連携
- Webhook設定
- サードパーティサービスとの連携

## まとめ

この記事では、複数エージェントの協調動作について学びました：

1. **ワークフローの種類**
   - 直列処理、並列処理、条件分岐、ループ処理

2. **データの受け渡し**
   - エージェント間のデータフロー
   - データ変換とフィルタリング

3. **エラーハンドリング**
   - エラー処理戦略
   - リトライとフォールバック

4. **パフォーマンス最適化**
   - 並列化のベストプラクティス
   - キャッシングの活用

次回は、外部ツールやAPIとの連携方法を学び、エージェントの可能性をさらに広げます！

## 参考リンク

- [Workflow Orchestration Patterns](https://www.enterpriseintegrationpatterns.com/)
- [Error Handling Best Practices](https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows)
