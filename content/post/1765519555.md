---
title: "GitHub Copilot エージェントパネル入門 - 第11回: 実践パターン集（テスト生成と品質管理）"
description: "ユニットテスト、統合テスト、E2Eテストの自動生成と、継続的な品質管理の実践。カバレッジ向上からメトリクス追跡まで"
date: 2025-12-12T15:00:00+09:00
draft: true
tags:
  - GitHub
  - Copilot
  - Agent Panel
  - テスト
  - 品質管理
image: /favicon.png
---

## はじめに

[@nqounet](https://x.com/nqounet)です。

第11回では、テスト生成と品質管理の実践パターンを学びます。自動テスト生成から継続的な品質追跡まで、高品質なコードベースを維持する方法を解説します。

## ユニットテストの自動生成

### テスト生成エージェント

```yaml
---
name: unit-test-generator
version: 2.0.0

parameters:
  - name: testFramework
    type: string
    required: true
    options: ["jest", "mocha", "pytest", "junit"]
  
  - name: coverageTarget
    type: integer
    default: 80
    min: 0
    max: 100
  
  - name: includeEdgeCases
    type: boolean
    default: true

workflow:
  steps:
    # 1. テスト対象のコードを解析
    - agent: code-analyzer
      output: code_structure
    
    # 2. テストケースを生成
    - agent: test-case-generator
      input: "${code_structure}"
      parameters:
        framework: "${parameters.testFramework}"
        includeEdgeCases: "${parameters.includeEdgeCases}"
      output: test_cases
    
    # 3. モックとフィクスチャを生成
    - agent: mock-generator
      input: "${code_structure}"
      output: mocks
    
    # 4. テストコードを生成
    - agent: test-code-writer
      input:
        testCases: "${test_cases}"
        mocks: "${mocks}"
      output: test_code
    
    # 5. カバレッジを検証
    - agent: coverage-checker
      input: "${test_code}"
      parameters:
        target: "${parameters.coverageTarget}"
---

# Unit Test Generator

## コード解析

### 対象関数
\`\`\`typescript
// src/calculator.ts
export function add(a: number, b: number): number {
  return a + b;
}

export function divide(a: number, b: number): number {
  if (b === 0) {
    throw new Error('Division by zero');
  }
  return a / b;
}

export class Calculator {
  private history: number[] = [];
  
  calculate(a: number, b: number, operation: string): number {
    let result: number;
    switch (operation) {
      case '+':
        result = a + b;
        break;
      case '-':
        result = a - b;
        break;
      case '*':
        result = a * b;
        break;
      case '/':
        result = this.divide(a, b);
        break;
      default:
        throw new Error('Unknown operation');
    }
    this.history.push(result);
    return result;
  }
  
  private divide(a: number, b: number): number {
    return divide(a, b);
  }
  
  getHistory(): number[] {
    return [...this.history];
  }
}
\`\`\`

## 生成されるテスト

### Jest形式
\`\`\`typescript
// src/calculator.test.ts
import { add, divide, Calculator } from './calculator';

describe('add', () => {
  it('should add two positive numbers', () => {
    expect(add(2, 3)).toBe(5);
  });
  
  it('should add negative numbers', () => {
    expect(add(-2, -3)).toBe(-5);
  });
  
  it('should add zero', () => {
    expect(add(0, 5)).toBe(5);
    expect(add(5, 0)).toBe(5);
  });
  
  it('should handle decimal numbers', () => {
    expect(add(0.1, 0.2)).toBeCloseTo(0.3);
  });
});

describe('divide', () => {
  it('should divide two numbers', () => {
    expect(divide(6, 3)).toBe(2);
  });
  
  it('should handle decimal results', () => {
    expect(divide(5, 2)).toBe(2.5);
  });
  
  it('should throw error when dividing by zero', () => {
    expect(() => divide(5, 0)).toThrow('Division by zero');
  });
  
  it('should handle negative numbers', () => {
    expect(divide(-6, 3)).toBe(-2);
    expect(divide(6, -3)).toBe(-2);
  });
});

describe('Calculator', () => {
  let calculator: Calculator;
  
  beforeEach(() => {
    calculator = new Calculator();
  });
  
  describe('calculate', () => {
    it('should perform addition', () => {
      expect(calculator.calculate(2, 3, '+')).toBe(5);
    });
    
    it('should perform subtraction', () => {
      expect(calculator.calculate(5, 3, '-')).toBe(2);
    });
    
    it('should perform multiplication', () => {
      expect(calculator.calculate(2, 3, '*')).toBe(6);
    });
    
    it('should perform division', () => {
      expect(calculator.calculate(6, 3, '/')).toBe(2);
    });
    
    it('should throw error for unknown operation', () => {
      expect(() => calculator.calculate(2, 3, '%'))
        .toThrow('Unknown operation');
    });
    
    it('should throw error when dividing by zero', () => {
      expect(() => calculator.calculate(5, 0, '/'))
        .toThrow('Division by zero');
    });
    
    it('should record history', () => {
      calculator.calculate(2, 3, '+');
      calculator.calculate(5, 2, '-');
      expect(calculator.getHistory()).toEqual([5, 3]);
    });
  });
  
  describe('getHistory', () => {
    it('should return empty array initially', () => {
      expect(calculator.getHistory()).toEqual([]);
    });
    
    it('should return copy of history', () => {
      calculator.calculate(2, 3, '+');
      const history = calculator.getHistory();
      history.push(999);
      expect(calculator.getHistory()).toEqual([5]);
    });
  });
});
\`\`\`

### エッジケースの考慮

テスト生成時に考慮するエッジケース：
1. **境界値**: 0, 最大値、最小値
2. **例外**: null, undefined, 不正な型
3. **特殊な値**: NaN, Infinity
4. **空の状態**: 空配列、空文字列
5. **並行処理**: レースコンディション
```

## モックとスタブの生成

### モック生成エージェント

```yaml
---
name: mock-generator
version: 1.0.0
---

# Mock Generator

## 依存関係の検出

### 対象コード
\`\`\`typescript
// src/userService.ts
import { UserRepository } from './userRepository';
import { EmailService } from './emailService';

export class UserService {
  constructor(
    private userRepo: UserRepository,
    private emailService: EmailService
  ) {}
  
  async createUser(email: string, name: string): Promise<User> {
    const user = await this.userRepo.create({ email, name });
    await this.emailService.sendWelcomeEmail(email);
    return user;
  }
}
\`\`\`

## 生成されるモック

\`\`\`typescript
// src/userService.test.ts
import { UserService } from './userService';
import { UserRepository } from './userRepository';
import { EmailService } from './emailService';

// モックの型定義
jest.mock('./userRepository');
jest.mock('./emailService');

const MockUserRepository = UserRepository as jest.MockedClass<typeof UserRepository>;
const MockEmailService = EmailService as jest.MockedClass<typeof EmailService>;

describe('UserService', () => {
  let userService: UserService;
  let mockUserRepo: jest.Mocked<UserRepository>;
  let mockEmailService: jest.Mocked<EmailService>;
  
  beforeEach(() => {
    // モックインスタンスの作成
    mockUserRepo = new MockUserRepository() as jest.Mocked<UserRepository>;
    mockEmailService = new MockEmailService() as jest.Mocked<EmailService>;
    
    userService = new UserService(mockUserRepo, mockEmailService);
    
    // デフォルトのモック動作を設定
    mockUserRepo.create.mockResolvedValue({
      id: '123',
      email: 'test@example.com',
      name: 'Test User'
    });
    
    mockEmailService.sendWelcomeEmail.mockResolvedValue(undefined);
  });
  
  afterEach(() => {
    jest.clearAllMocks();
  });
  
  describe('createUser', () => {
    it('should create user and send welcome email', async () => {
      const email = 'test@example.com';
      const name = 'Test User';
      
      const result = await userService.createUser(email, name);
      
      // リポジトリが呼ばれたことを検証
      expect(mockUserRepo.create).toHaveBeenCalledWith({ email, name });
      expect(mockUserRepo.create).toHaveBeenCalledTimes(1);
      
      // メール送信が呼ばれたことを検証
      expect(mockEmailService.sendWelcomeEmail).toHaveBeenCalledWith(email);
      expect(mockEmailService.sendWelcomeEmail).toHaveBeenCalledTimes(1);
      
      // 結果を検証
      expect(result).toEqual({
        id: '123',
        email,
        name
      });
    });
    
    it('should not send email if user creation fails', async () => {
      mockUserRepo.create.mockRejectedValue(new Error('Database error'));
      
      await expect(
        userService.createUser('test@example.com', 'Test')
      ).rejects.toThrow('Database error');
      
      expect(mockEmailService.sendWelcomeEmail).not.toHaveBeenCalled();
    });
  });
});
\`\`\`
```

## 統合テストの生成

### 統合テスト生成エージェント

```yaml
---
name: integration-test-generator
version: 1.0.0

parameters:
  - name: testDatabase
    type: string
    default: "testcontainers"
    options: ["testcontainers", "in-memory", "dedicated"]
  
  - name: isolationLevel
    type: string
    default: "test"
    options: ["test", "suite", "file"]
---

# Integration Test Generator

## API エンドポイントのテスト

### 対象コード
\`\`\`typescript
// src/api/users.ts
import { Router } from 'express';
import { UserService } from '../services/userService';

const router = Router();

router.post('/users', async (req, res) => {
  const { email, name } = req.body;
  const user = await userService.createUser(email, name);
  res.status(201).json(user);
});

router.get('/users/:id', async (req, res) => {
  const user = await userService.getUserById(req.params.id);
  if (!user) {
    return res.status(404).json({ error: 'User not found' });
  }
  res.json(user);
});
\`\`\`

## 生成される統合テスト

\`\`\`typescript
// src/api/users.integration.test.ts
import request from 'supertest';
import { app } from '../app';
import { TestDatabase } from '../test-utils/database';

describe('User API Integration Tests', () => {
  let testDb: TestDatabase;
  
  beforeAll(async () => {
    testDb = await TestDatabase.create();
    await testDb.migrate();
  });
  
  afterAll(async () => {
    await testDb.close();
  });
  
  beforeEach(async () => {
    await testDb.clear();
  });
  
  describe('POST /users', () => {
    it('should create a new user', async () => {
      const userData = {
        email: 'test@example.com',
        name: 'Test User'
      };
      
      const response = await request(app)
        .post('/users')
        .send(userData)
        .expect(201);
      
      expect(response.body).toMatchObject({
        email: userData.email,
        name: userData.name
      });
      expect(response.body.id).toBeDefined();
    });
    
    it('should return 400 for invalid email', async () => {
      const response = await request(app)
        .post('/users')
        .send({
          email: 'invalid-email',
          name: 'Test User'
        })
        .expect(400);
      
      expect(response.body.error).toBeDefined();
    });
    
    it('should return 409 for duplicate email', async () => {
      const userData = {
        email: 'test@example.com',
        name: 'Test User'
      };
      
      // 最初のユーザーを作成
      await request(app).post('/users').send(userData);
      
      // 重複を試みる
      const response = await request(app)
        .post('/users')
        .send(userData)
        .expect(409);
      
      expect(response.body.error).toContain('already exists');
    });
  });
  
  describe('GET /users/:id', () => {
    it('should get user by id', async () => {
      // ユーザーを作成
      const createResponse = await request(app)
        .post('/users')
        .send({
          email: 'test@example.com',
          name: 'Test User'
        });
      
      const userId = createResponse.body.id;
      
      // ユーザーを取得
      const response = await request(app)
        .get(\`/users/\${userId}\`)
        .expect(200);
      
      expect(response.body).toMatchObject({
        id: userId,
        email: 'test@example.com',
        name: 'Test User'
      });
    });
    
    it('should return 404 for non-existent user', async () => {
      const response = await request(app)
        .get('/users/non-existent-id')
        .expect(404);
      
      expect(response.body.error).toBe('User not found');
    });
  });
});
\`\`\`
```

## E2Eテストの生成

### E2Eテスト生成エージェント

```yaml
---
name: e2e-test-generator
version: 1.0.0

parameters:
  - name: tool
    type: string
    default: "playwright"
    options: ["playwright", "cypress", "selenium"]
  
  - name: browsers
    type: array
    default: ["chromium"]
    items:
      type: string
      options: ["chromium", "firefox", "webkit"]
---

# E2E Test Generator

## ユーザーフローの解析

### 対象ページ
- ログインページ
- ダッシュボード
- ユーザー作成フォーム

## 生成されるE2Eテスト

### Playwright形式
\`\`\`typescript
// e2e/user-workflow.spec.ts
import { test, expect } from '@playwright/test';

test.describe('User Management Workflow', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('http://localhost:3000');
  });
  
  test('complete user creation flow', async ({ page }) => {
    // Step 1: ログイン
    await page.click('text=Login');
    await page.fill('input[name="email"]', 'admin@example.com');
    await page.fill('input[name="password"]', 'password123');
    await page.click('button[type="submit"]');
    
    // ダッシュボードに遷移したことを確認
    await expect(page).toHaveURL(/.*dashboard/);
    await expect(page.locator('h1')).toContainText('Dashboard');
    
    // Step 2: ユーザー作成画面に移動
    await page.click('text=Create User');
    await expect(page).toHaveURL(/.*users\/new/);
    
    // Step 3: フォームに入力
    await page.fill('input[name="name"]', 'Test User');
    await page.fill('input[name="email"]', 'testuser@example.com');
    await page.selectOption('select[name="role"]', 'user');
    
    // Step 4: 送信
    await page.click('button[type="submit"]');
    
    // Step 5: 成功メッセージを確認
    await expect(page.locator('.success-message'))
      .toContainText('User created successfully');
    
    // Step 6: ユーザー一覧に戻って確認
    await page.click('text=Users');
    await expect(page.locator('table')).toContainText('testuser@example.com');
  });
  
  test('should show validation errors', async ({ page }) => {
    await page.click('text=Login');
    await page.fill('input[name="email"]', 'admin@example.com');
    await page.fill('input[name="password"]', 'password123');
    await page.click('button[type="submit"]');
    
    await page.click('text=Create User');
    
    // 空のフォームで送信
    await page.click('button[type="submit"]');
    
    // バリデーションエラーを確認
    await expect(page.locator('.error'))
      .toContainText('Name is required');
    await expect(page.locator('.error'))
      .toContainText('Email is required');
  });
  
  test('should handle duplicate email error', async ({ page }) => {
    // 既存ユーザーと同じメールで作成を試みる
    // ...
  });
});
\`\`\`
```

## 品質メトリクスの追跡

### メトリクス収集エージェント

```yaml
---
name: quality-metrics-tracker
version: 1.0.0

metrics:
  coverage:
    - unit-test-coverage
    - integration-test-coverage
    - e2e-test-coverage
  
  quality:
    - code-complexity
    - code-duplication
    - technical-debt
  
  performance:
    - build-time
    - test-execution-time
    - bundle-size

workflow:
  steps:
    # 1. テストカバレッジ収集
    - shell:
        command: "npm run test:coverage"
      output: coverage_report
    
    # 2. 複雑度分析
    - agent: complexity-analyzer
      output: complexity_metrics
    
    # 3. 重複コード検出
    - agent: duplication-detector
      output: duplication_metrics
    
    # 4. メトリクスを集約
    - agent: metrics-aggregator
      input:
        coverage: "${coverage_report}"
        complexity: "${complexity_metrics}"
        duplication: "${duplication_metrics}"
      output: quality_metrics
    
    # 5. レポート生成と保存
    - agent: metrics-reporter
      input: "${quality_metrics}"
      output: metrics_report
    
    # 6. トレンド分析
    - agent: trend-analyzer
      input: "${metrics_report}"
      output: trend_report
---
```

## 動作確認チェックリスト

- [ ] ユニットテストを自動生成した
- [ ] モックとスタブを生成した
- [ ] 統合テストを生成した
- [ ] E2Eテストを生成した
- [ ] テストカバレッジを測定した
- [ ] 品質メトリクスを収集した
- [ ] トレンドを分析した

## 次回予告

第12回（最終回）では、運用のベストプラクティスとまとめを学びます：

- エージェントの保守と更新
- チーム運用のガイドライン
- セキュリティとコンプライアンス
- 連載全体の総括

## まとめ

この記事では、テスト生成と品質管理について学びました：

1. **ユニットテスト生成**
   - コード解析とテストケース生成
   - エッジケースの考慮

2. **モックとスタブ**
   - 依存関係の自動モック化
   - テストの独立性確保

3. **統合/E2Eテスト**
   - API統合テスト
   - エンドツーエンドのユーザーフロー

4. **品質メトリクス**
   - カバレッジ測定
   - トレンド分析

次回は、連載の最終回として、運用のベストプラクティスと全体のまとめを行います！
