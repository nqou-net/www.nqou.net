---
comments: true
date: 2025-12-22T12:00:00+09:00
description: エージェント運用で発生する一般的な問題とその解決方法、デバッグ手法、パフォーマンス最適化のテクニックを学びます
draft: true
hidden: false
image: /favicon.png
iso8601: 2025-12-22T12:00:00+09:00
license: ~
math: ~
tags:
  - github
  - copilot
  - ai
  - agent
  - troubleshooting
  - debugging
  - hands-on
series: "GitHub エージェントパネル実践ガイド"
title: 【第11回】トラブルシューティング - よくある問題と解決策

---

[@nqounet](https://x.com/nqounet)です。

GitHub エージェントパネル実践ガイド第11回です。今回は、エージェント運用で発生する一般的な問題とその解決方法を学びます。

## この記事で学べること

- よくある問題とその解決策
- デバッグ手法
- パフォーマンス最適化
- エラーメッセージの読み方
- サポートへの効果的な問い合わせ方法

## よくある問題と解決策

### 問題1: エージェントが期待通りに動作しない

#### 症状
```
タスク: "ユーザー管理APIを実装してください"

期待: CRUD API の完全な実装
実際: 一部の機能のみ実装される、または全く異なるコードが生成される
```

#### 原因と対策

**原因1: プロンプトが曖昧**

```markdown
❌ 悪い例:
「ユーザー管理APIを作って」

✅ 良い例:
「Node.js + Express でユーザー管理APIを実装してください。

要件:
- GET /api/users - ユーザー一覧取得（ページネーション対応）
- GET /api/users/:id - ユーザー詳細取得
- POST /api/users - ユーザー作成（メール重複チェック）
- PUT /api/users/:id - ユーザー更新
- DELETE /api/users/:id - ユーザー削除

技術仕様:
- データベース: PostgreSQL (pg ライブラリ)
- バリデーション: Joi
- 認証: JWT ミドルウェア
- エラーハンドリング: 統一フォーマット

ファイル構成:
- src/routes/users.js
- src/controllers/userController.js
- src/validators/userValidator.js
```

**原因2: AGENTS.md の設定不足**

```markdown
AGENTS.md に以下を追加:

## implementation-agent

### コーディング規約
- ES6+ モジュール構文
- async/await によるエラーハンドリング
- JSDoc コメント必須

### ファイル構造
```
src/
  ├─ controllers/
  ├─ routes/
  ├─ models/
  └─ validators/
```

### デフォルトパターン
- Controller: ビジネスロジック
- Route: エンドポイント定義のみ
- Validator: Joi スキーマ
```

**原因3: コンテキスト不足**

```markdown
既存のコードパターンを示す:

「以下の既存コードと同じパターンで実装してください：

[既存の posts.js のコードを貼り付け]

これと同じ構造で users.js を実装してください。」
```

### 問題2: エージェントの実行が途中で停止する

#### 症状
```
[00:00] task-planner 開始
[00:02] ✓ タスク分解完了

[00:03] implementation-agent 開始
[00:15] ⚠ タイムアウトにより停止
```

#### 原因と対策

**原因1: タスクが大きすぎる**

```markdown
対策: タスクを分割する

❌ 1つの大きなタスク:
「ECサイト全体を実装」

✅ 小さなタスクに分割:
1. 「商品一覧表示機能を実装」
2. 「商品詳細表示機能を実装」
3. 「カート機能を実装」
4. 「注文処理機能を実装」
```

**原因2: リソース不足**

```markdown
対策: 並列実行数を制限

AGENTS.md に追加:

```yaml
performance:
  max_concurrent_agents: 2  # 同時実行エージェント数
  timeout_seconds: 300      # タイムアウト時間
  memory_limit_mb: 2048     # メモリ制限
```
```

**原因3: 外部API の応答遅延**

```javascript
// ツールにリトライ機能を追加
class APIClient {
  async callWithRetry(apiCall, maxRetries = 3) {
    let lastError;
    
    for (let i = 0; i < maxRetries; i++) {
      try {
        return await apiCall();
      } catch (error) {
        lastError = error;
        
        // 指数バックオフ
        const delayMs = Math.pow(2, i) * 1000;
        await new Promise(resolve => setTimeout(resolve, delayMs));
        
        console.log(`Retry ${i + 1}/${maxRetries} after ${delayMs}ms`);
      }
    }
    
    throw lastError;
  }
}
```

### 問題3: 生成されたコードにバグがある

#### 症状
```
生成されたコードを実行すると:
- TypeError: Cannot read property 'x' of undefined
- ReferenceError: variable is not defined
- エッジケースで予期しない動作
```

#### 原因と対策

**対策1: テスト駆動開発（TDD）**

```markdown
プロンプト修正:

「ユーザー作成APIを実装してください。

まず、以下のテストケースを満たすコードを生成してください:

1. 正常系:
   - 有効なデータでユーザー作成成功
   - 201ステータスとユーザー情報を返す

2. 異常系:
   - メールアドレス形式が不正 → 400エラー
   - メールアドレス重複 → 409エラー
   - 必須フィールド欠損 → 400エラー

3. エッジケース:
   - 名前が空文字列
   - 年齢が負の数
   - 極端に長いメールアドレス

テストコードも一緒に生成してください。」
```

**対策2: 段階的なレビュー**

```markdown
ワークフロー:
1. implementation-agent で実装
2. code-reviewer で即座にレビュー
3. 問題があれば implementation-agent で修正
4. testing-agent でテスト生成
5. テスト実行
6. 失敗したら修正ループ
```

**対策3: 型安全性の向上**

```markdown
TypeScript を使用する場合:

「TypeScript で実装してください。

型安全性の要件:
- すべての関数に型注釈
- strict モード有効
- any 型の使用禁止
- null/undefined チェック必須
```

### 問題4: エージェント間のデータ受け渡しエラー

#### 症状
```
[00:10] task-planner 完了
         出力: {"tasks": [...]}

[00:11] implementation-agent 開始
         エラー: "入力データが不正です"
```

#### 原因と対策

**原因: データフォーマットの不一致**

```markdown
対策: 標準フォーマットを定義

AGENTS.md に追加:

## エージェント間データフォーマット

### task-planner → implementation-agent

```json
{
  "task_id": "string",
  "title": "string",
  "description": "string",
  "requirements": {
    "functional": ["string"],
    "technical": ["string"]
  },
  "files": [
    {
      "path": "string",
      "action": "create|modify|delete"
    }
  ],
  "dependencies": ["task_id"]
}
```

すべてのエージェントはこの形式に従うこと。
```

## デバッグ手法

### 1. 詳細ログの有効化

```markdown
AGENTS.md に追加:

```yaml
logging:
  level: debug  # info, debug, trace
  output:
    - console
    - file: logs/agent-{date}.log
  
  include:
    - agent_thoughts    # エージェントの思考プロセス
    - api_calls        # 外部API呼び出し
    - data_flow        # データの流れ
    - performance      # パフォーマンスメトリクス
```
```

### 2. ステップバイステップ実行

```markdown
プロンプトに追加:

「以下のタスクを実行してください。

デバッグモード: ON
各ステップの後に以下を出力してください:
1. 実行内容
2. 現在の状態
3. 次のステップの計画
4. 懸念事項があれば報告

ステップごとに確認を待ってください。」
```

### 3. エラーの詳細分析

```javascript
// デバッグヘルパー
class DebugHelper {
  /**
   * エラーの詳細情報を収集
   */
  static analyzeError(error, context = {}) {
    const analysis = {
      timestamp: new Date().toISOString(),
      errorType: error.constructor.name,
      message: error.message,
      stack: error.stack,
      context: context,
      systemInfo: {
        nodeVersion: process.version,
        platform: process.platform,
        memory: process.memoryUsage()
      }
    };

    // ログファイルに保存
    this.saveToLog(analysis);

    // エラー分類
    const category = this.categorizeError(error);
    analysis.category = category;
    analysis.suggestedFix = this.getSuggestedFix(category);

    return analysis;
  }

  /**
   * エラーを分類
   */
  static categorizeError(error) {
    if (error.message.includes('timeout')) {
      return 'TIMEOUT';
    } else if (error.message.includes('permission')) {
      return 'PERMISSION';
    } else if (error.message.includes('not found')) {
      return 'NOT_FOUND';
    } else if (error.code === 'ECONNREFUSED') {
      return 'CONNECTION';
    }
    return 'UNKNOWN';
  }

  /**
   * 修正案を提案
   */
  static getSuggestedFix(category) {
    const fixes = {
      TIMEOUT: [
        'タスクを小さく分割する',
        'timeout値を増やす',
        '並列実行数を減らす'
      ],
      PERMISSION: [
        'アクセス権限を確認',
        'GitHub Secretsを確認',
        'RBACロール設定を確認'
      ],
      NOT_FOUND: [
        'ファイルパスを確認',
        'リソース名を確認',
        '事前に必要なリソースを作成'
      ],
      CONNECTION: [
        'ネットワーク接続を確認',
        'APIエンドポイントURLを確認',
        'ファイアウォール設定を確認'
      ]
    };

    return fixes[category] || ['エラーログを確認', 'サポートに連絡'];
  }

  /**
   * ログファイルに保存
   */
  static saveToLog(analysis) {
    const fs = require('fs');
    const logDir = './logs/errors';
    
    if (!fs.existsSync(logDir)) {
      fs.mkdirSync(logDir, { recursive: true });
    }

    const filename = `${logDir}/error-${Date.now()}.json`;
    fs.writeFileSync(filename, JSON.stringify(analysis, null, 2));
    
    console.log(`Error details saved to: ${filename}`);
  }
}

// 使用例
try {
  await agent.execute(task);
} catch (error) {
  const analysis = DebugHelper.analyzeError(error, {
    agentName: 'implementation-agent',
    taskId: task.id,
    userId: user.id
  });

  console.error('Error Analysis:', analysis);
  console.error('Suggested Fixes:', analysis.suggestedFix);
}
```

## パフォーマンス最適化

### 1. キャッシング戦略

```javascript
// エージェント結果のキャッシュ
class AgentCache {
  constructor() {
    this.cache = new Map();
    this.ttl = 60 * 60 * 1000; // 1時間
  }

  /**
   * キャッシュキーを生成
   */
  generateKey(agentName, input) {
    const crypto = require('crypto');
    const data = JSON.stringify({ agentName, input });
    return crypto.createHash('sha256').update(data).digest('hex');
  }

  /**
   * キャッシュから取得
   */
  get(agentName, input) {
    const key = this.generateKey(agentName, input);
    const cached = this.cache.get(key);

    if (!cached) {
      return null;
    }

    // TTLチェック
    if (Date.now() - cached.timestamp > this.ttl) {
      this.cache.delete(key);
      return null;
    }

    console.log(`Cache hit for ${agentName}`);
    return cached.result;
  }

  /**
   * キャッシュに保存
   */
  set(agentName, input, result) {
    const key = this.generateKey(agentName, input);
    this.cache.set(key, {
      result,
      timestamp: Date.now()
    });
  }

  /**
   * キャッシュをクリア
   */
  clear() {
    this.cache.clear();
  }
}

// 使用例
const cache = new AgentCache();

async function executeWithCache(agentName, input) {
  // キャッシュチェック
  const cached = cache.get(agentName, input);
  if (cached) {
    return cached;
  }

  // エージェント実行
  const result = await agent.execute(input);

  // キャッシュに保存
  cache.set(agentName, input, result);

  return result;
}
```

### 2. 並列実行の最適化

```javascript
// 効率的な並列実行
class ParallelExecutor {
  constructor(maxConcurrent = 3) {
    this.maxConcurrent = maxConcurrent;
    this.queue = [];
    this.running = 0;
  }

  /**
   * タスクを追加
   */
  async add(taskFn) {
    return new Promise((resolve, reject) => {
      this.queue.push({ taskFn, resolve, reject });
      this.process();
    });
  }

  /**
   * キューを処理
   */
  async process() {
    while (this.running < this.maxConcurrent && this.queue.length > 0) {
      const { taskFn, resolve, reject } = this.queue.shift();
      this.running++;

      taskFn()
        .then(resolve)
        .catch(reject)
        .finally(() => {
          this.running--;
          this.process();
        });
    }
  }
}

// 使用例
const executor = new ParallelExecutor(3);

const tasks = [
  () => implementationAgent.execute(task1),
  () => implementationAgent.execute(task2),
  () => implementationAgent.execute(task3),
  () => implementationAgent.execute(task4),
  () => implementationAgent.execute(task5)
];

const results = await Promise.all(
  tasks.map(task => executor.add(task))
);
```

### 3. メモリ最適化

```javascript
// 大きなデータの処理
class StreamProcessor {
  /**
   * ストリーム処理
   */
  async processLargeFile(filePath, processChunk) {
    const fs = require('fs');
    const readline = require('readline');

    const fileStream = fs.createReadStream(filePath);
    const rl = readline.createInterface({
      input: fileStream,
      crlfDelay: Infinity
    });

    let processed = 0;

    for await (const line of rl) {
      await processChunk(line);
      processed++;

      if (processed % 1000 === 0) {
        console.log(`Processed ${processed} lines`);
      }
    }

    return processed;
  }
}
```

## サポートへの問い合わせ

### 効果的な問い合わせの作成

```markdown
## バグレポートテンプレート

### 環境情報
- OS: macOS 13.0
- Node.js: 18.17.0
- GitHub Copilot: v1.2.3
- リポジトリ: https://github.com/org/repo

### 問題の説明
エージェントが期待通りに動作しません。

### 再現手順
1. エージェントパネルを開く
2. 以下のプロンプトを入力:
   ```
   [プロンプト全文]
   ```
3. implementation-agent を選択
4. 実行ボタンをクリック

### 期待される動作
CRUD APIの完全な実装が生成される

### 実際の動作
一部の関数のみが生成される

### エラーメッセージ
```
[エラーログ全文]
```

### AGENTS.md 設定
```markdown
[関連する設定]
```

### スクリーンショット
[画面キャプチャを添付]

### 試したこと
- タスクを小さく分割 → 改善せず
- プロンプトを詳細化 → 若干改善
- キャッシュクリア → 変化なし
```

## 次回予告

第12回「実践プロジェクト」では、これまで学んだすべてのテクニックを活用して、実際のプロジェクトをエンドツーエンドで構築します。

## チェックリスト

- [ ] よくある問題の解決方法を理解した
- [ ] デバッグ手法を習得した
- [ ] パフォーマンス最適化ができるようになった
- [ ] 効果的なバグレポートを作成できるようになった

---

**シリーズ目次**
1. [エージェントパネル入門](../1764676800/)
2. [エージェントパネルの基本操作](../1764849600/)
3. [最初のエージェント設定](../1765022400/)
4. [タスクプランニングエージェントの活用](../1765195200/)
5. [コード生成エージェントの実践](../1765368000/)
6. [レビューエージェントの構築](../1765540800/)
7. [ドキュメント生成エージェントの設定](../1765713600/)
8. [マルチエージェント連携](../1765886400/)
9. [カスタムツール統合](../1766059200/)
10. [セキュリティとベストプラクティス](../1766232000/)
11. **トラブルシューティング**（本記事）
12. 実践プロジェクト

質問や感想は [@nqounet](https://x.com/nqounet) までお気軽にどうぞ！
