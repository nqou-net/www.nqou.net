---
comments: true
description: GitHub Copilotカスタムエージェントの応用編。MCPサーバー連携、外部ツール統合、発展的な活用方法を解説します。
draft: true
hidden: false
tags:
  - ai
  - copilot
  - programming
title: 【連載第5回】GitHub Copilotカスタムエージェント ― 応用編：MCPサーバー連携

---

[@nqounet](https://x.com/nqounet)です。

カスタムエージェント連載の最終回です。今回は、MCP（Model Context Protocol）サーバーを使った外部ツール連携と、発展的な活用方法を解説します。

## MCPとは何か

MCP（Model Context Protocol）は、AIエージェントと外部ツールを接続するための標準プロトコルです。

これにより、カスタムエージェントは以下のような外部サービスと連携できます。

| 連携先 | できること |
|-------|----------|
| クラウドインフラ | Terraform、AWS、Azure、GCPの操作 |
| データベース | SQLクエリの実行、スキーマ確認 |
| API | 外部APIの呼び出し |
| 独自ツール | 社内ツールとの連携 |

## MCPサーバーの種類

MCPサーバーには2つのタイプがあります。

### ローカルMCPサーバー

同じマシン上でプロセスとして動作するサーバーです。

```yaml
mcp-servers:
  terraform:
    type: local
    command: docker
    args: ["run", "-i", "hashicorp/terraform-mcp-server"]
```

特徴:
- 低遅延
- ローカルリソースにアクセス可能
- DockerやNode.jsで実行

### リモートMCPサーバー

HTTP経由で通信するサーバーです。

```yaml
mcp-servers:
  api-service:
    type: http
    url: https://mcp.example.com
    headers:
      Authorization: Bearer $COPILOT_MCP_TOKEN
```

特徴:
- スケーラブル
- 中央集中管理が可能
- ファイアウォールの設定が必要

## MCPサーバーの設定方法

### 方法1: リポジトリ設定（JSON）

GitHub.comのリポジトリ設定で、MCPサーバーを定義します。

**設定場所**: Settings > Code & automation > Copilot > Coding agent > MCP configuration

```json
{
  "mcpServers": {
    "terraform": {
      "command": "docker",
      "args": ["run", "-i", "hashicorp/terraform-mcp-server"],
      "type": "local"
    },
    "database": {
      "url": "https://db-mcp.example.com",
      "headers": {
        "Authorization": "Bearer $COPILOT_MCP_DB_TOKEN"
      },
      "type": "http"
    }
  }
}
```

### 方法2: エージェントファイル内（YAML）

`.agent.md` ファイル内でMCPサーバーを定義します。

```yaml
---
name: infra-manager
description: クラウドインフラを管理します
mcp-servers:
  terraform:
    type: local
    command: npx
    args: ["-y", "@terraform/mcp-server"]
    tools: ["plan", "apply", "destroy"]
  aws:
    type: http
    url: https://aws-mcp.example.com
    headers:
      Authorization: Bearer $COPILOT_MCP_AWS_TOKEN
    tools: ["describe-instances", "list-buckets"]
---
```

## 実践例1: Terraform連携

### ユースケース

インフラの変更をCopilotエージェントに依頼し、Terraformを自動実行する。

### エージェント設定

```markdown
---
name: terraform-operator
description: >-
  Terraformを使用してインフラストラクチャを管理します。
  plan、apply、destroyの各操作をサポートします。
tools: ["read", "edit"]
mcp-servers:
  terraform:
    type: local
    command: docker
    args: ["run", "-i", "hashicorp/terraform-mcp-server"]
    tools: ["plan", "apply"]
metadata:
  category: infrastructure
  requires_approval: true
---

# Terraformオペレーター

あなたはインフラストラクチャの専門家です。

## 主な責務

1. Terraformファイルの作成・編集
2. `terraform plan` による変更確認
3. `terraform apply` による変更適用

## ワークフロー

1. 変更内容を確認
2. `terraform plan` を実行
3. 計画結果をユーザーに報告
4. 承認を得てから `terraform apply` を実行

## 安全ガイドライン

- `destroy` は絶対に自動実行しない
- 本番環境への変更は必ず承認を得る
- 変更前にバックアップ計画を確認する
```

### 使用例

Issueやチャットで以下のように依頼します。

```
@terraform-operator

EC2インスタンスのサイズをt3.microからt3.smallに変更してください。
変更前にplanで影響を確認したいです。
```

## 実践例2: データベース連携

### ユースケース

データベースのスキーマ確認やクエリ実行をエージェントに依頼する。

### エージェント設定

```markdown
---
name: db-assistant
description: >-
  データベースの操作を支援します。
  スキーマ確認、クエリ作成、データ分析をサポートします。
tools: ["read"]
mcp-servers:
  postgres:
    type: http
    url: https://db-mcp.example.com
    headers:
      Authorization: Bearer $COPILOT_MCP_DB_TOKEN
    tools: ["query", "schema"]
metadata:
  category: database
---

# データベースアシスタント

あなたはSQLの専門家です。

## 主な責務

1. テーブルスキーマの確認
2. SELECTクエリの作成と実行
3. クエリ結果の分析

## 安全ガイドライン

- SELECT文のみ実行可能
- INSERT、UPDATE、DELETE、DROPは禁止
- 機密データのマスキングを必ず行う
- クエリ結果は必要最小限に絞る

## 禁止事項

- データの変更
- スキーマの変更
- 機密情報（個人情報、認証情報等）の表示
```

## 実践例3: 社内ツール連携

### ユースケース

社内のチケットシステムやナレッジベースと連携する。

### 独自MCPサーバーの構築

Node.jsで簡単なMCPサーバーを構築できます。

```javascript
// mcp-server.js
import { Server } from '@modelcontextprotocol/sdk/server/index.js';

const server = new Server({
  name: 'internal-tools',
  version: '1.0.0'
});

// ツールの定義
server.tool('get-ticket', async (params) => {
  const { ticketId } = params;
  // チケット情報を取得するロジック
  return { ticket: await fetchTicket(ticketId) };
});

server.tool('search-docs', async (params) => {
  const { query } = params;
  // ドキュメントを検索するロジック
  return { results: await searchDocs(query) };
});

// サーバーの起動
server.start();
```

### エージェント設定

```markdown
---
name: support-agent
description: 社内サポート業務を支援します
tools: ["read"]
mcp-servers:
  internal:
    type: local
    command: node
    args: ["./mcp-server.js"]
    tools: ["get-ticket", "search-docs"]
---

# サポートエージェント

あなたはカスタマーサポートの専門家です。

## 主な責務

1. チケット情報の確認
2. 関連ドキュメントの検索
3. 回答案の作成
```

## ツールの制限

MCPサーバーのすべてのツールを公開する必要はありません。必要なツールのみを指定できます。

```yaml
mcp-servers:
  terraform:
    type: local
    command: docker
    args: ["run", "hashicorp/terraform-mcp-server"]
    # planのみ許可、applyは禁止
    tools: ["plan"]
```

ツール名の指定方法:
- `tools: ["*"]` - すべてのツールを許可
- `tools: ["plan", "apply"]` - 特定のツールのみ許可
- `tools: ["terraform/plan"]` - サーバー名/ツール名 形式も可能

## シークレットの管理

MCPサーバーで使用するシークレットは、以下のルールに従って管理します。

### プレフィックスルール

```yaml
headers:
  Authorization: Bearer $COPILOT_MCP_TOKEN
```

**重要**: `COPILOT_MCP_` プレフィックスが付いた環境変数のみ、エージェントからアクセス可能です。

### GitHubシークレットの設定

```bash
# GitHub CLIを使用
gh secret set COPILOT_MCP_TOKEN --body "your-secret-token"

# または、GitHub.comのSettings > Secrets and variablesから設定
```

### 環境変数の使用

```yaml
mcp-servers:
  api:
    type: http
    url: https://api.example.com
    headers:
      Authorization: Bearer $COPILOT_MCP_API_KEY
      X-Custom-Header: $COPILOT_MCP_CUSTOM_VALUE
```

## 高度なパターン

### パターン1: マルチサーバー連携

複数のMCPサーバーを組み合わせて、複雑なワークフローを実現します。

```markdown
---
name: full-stack-operator
description: フルスタック開発を支援します
mcp-servers:
  terraform:
    type: local
    command: docker
    args: ["run", "hashicorp/terraform-mcp-server"]
    tools: ["plan", "apply"]
  database:
    type: http
    url: https://db-mcp.example.com
    tools: ["migrate", "seed"]
  monitoring:
    type: http
    url: https://monitoring-mcp.example.com
    tools: ["check-status", "get-logs"]
---
```

### パターン2: 環境別設定

開発環境と本番環境で異なるMCPサーバーを使用します。

```json
{
  "mcpServers": {
    "database-dev": {
      "url": "https://dev-db-mcp.example.com",
      "headers": {
        "Authorization": "Bearer $COPILOT_MCP_DEV_DB_TOKEN"
      }
    },
    "database-prod": {
      "url": "https://prod-db-mcp.example.com",
      "headers": {
        "Authorization": "Bearer $COPILOT_MCP_PROD_DB_TOKEN"
      }
    }
  }
}
```

### パターン3: カスタムツールチェーン

複数のツールを組み合わせたワークフローを定義します。

```markdown
## デプロイワークフロー

1. `terraform/plan` でインフラ変更を確認
2. 承認を得る
3. `terraform/apply` で変更を適用
4. `monitoring/check-status` で状態を確認
5. 問題があれば `monitoring/get-logs` でログを取得
```

## 現在の制限事項

MCPサーバー連携には、いくつかの制限があります。

1. **OAuthサポートなし**: 現時点では静的トークンのみ対応
2. **ツールのみ対応**: MCPのresourcesやpromptsは未サポート
3. **レート制限**: APIコールにはレート制限がある
4. **タイムアウト**: 長時間の処理はタイムアウトする可能性

## 今後の展望

カスタムエージェントとMCPの機能は急速に進化しています。

### 期待される機能

- **OAuthサポート**: より安全な認証方式
- **双方向通信**: サーバーからエージェントへの通知
- **リソース共有**: ファイルやデータの共有
- **プロンプトテンプレート**: MCPサーバーからのプロンプト提供

### コミュニティの動向

- **公式MCPサーバー**: GitHubやMicrosoftが公式サーバーを提供
- **サードパーティ連携**: 各種SaaSとの連携が増加中
- **標準化の進展**: MCPプロトコル自体の進化

## 連載のまとめ

全5回の連載を通じて、GitHub Copilotカスタムエージェントについて解説しました。

| 回 | 内容 | ポイント |
|---|------|---------|
| 第1回 | 概要とできること | カスタムエージェントの基本概念 |
| 第2回 | セットアップ・基本設定 | `.github/agents/` の構成と設定 |
| 第3回 | 具体的ユースケース | ドキュメント、レビュー、テスト、セキュリティ |
| 第4回 | 保守・管理・セキュリティ | ベストプラクティスと注意点 |
| 第5回 | 応用編 | MCPサーバー連携と発展的活用 |

### 始めるためのステップ

1. **まずは簡単なエージェントから**: READMEスペシャリストなど
2. **徐々に機能を追加**: ツール制限、メタデータ
3. **チームで共有**: 組織レベルのエージェント
4. **外部連携**: MCPサーバーの導入

### 最後に

カスタムエージェントは、AIをチームメンバーとして活用するための強力な機能です。適切に設計・運用することで、開発効率を大幅に向上させることができます。

この連載が、皆さんのカスタムエージェント活用の一助となれば幸いです。

## 参考資料

- [Extending GitHub Copilot coding agent with the Model Context Protocol (MCP)](https://docs.github.com/copilot/using-github-copilot/coding-agent/extending-copilot-coding-agent-with-mcp)
- [Copilot coding agent now supports remote MCP servers](https://github.blog/changelog/2025-07-09-copilot-coding-agent-now-supports-remote-mcp-servers/)
- [MCP Server Integration - DeepWiki](https://deepwiki.com/github/awesome-copilot/2.2-mcp-server-integration)
- [Model Context Protocol](https://modelcontextprotocol.io/)
