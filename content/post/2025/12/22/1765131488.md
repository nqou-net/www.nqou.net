---
date: 2025-12-22T00:00:00+09:00
description: JSON-RPC 2.0のエラーオブジェクト仕様を学び、適切なエラーレスポンスを返す実装とクライアント側でのエラー処理を実装します。
draft: true
epoch: 1766361600
iso8601: 2025-12-22T00:00:00+09:00
tags:
  - json-rpc
  - perl
  - error-handling
  - validation
  - exception-handling
title: 'JSON-RPC 2.0入門 - 第4回: エラーハンドリングの基礎'

---

## JSON-RPC 2.0入門 - 第4回: エラーハンドリングの基礎

JSON-RPCでは、エラーは必ず発生するものとして適切に扱う必要があります。この記事では、JSON-RPC 2.0のエラーオブジェクト仕様を学び、サーバー側で適切なエラーレスポンスを返し、クライアント側でそれを正しく処理する方法を実装します。

## JSON-RPC 2.0のエラーオブジェクト

JSON-RPC 2.0では、エラーは次の構造を持つオブジェクトで表現されます。

```json
{
  "jsonrpc": "2.0",
  "error": {
    "code": -32600,
    "message": "Invalid Request",
    "data": "追加のエラー情報（オプション）"
  },
  "id": null
}
```

エラーオブジェクトの必須フィールド:
- **code**: 整数のエラーコード
- **message**: エラーの簡潔な説明文字列

オプションフィールド:
- **data**: エラーに関する追加情報（任意の型）

## 標準エラーコード

JSON-RPC 2.0仕様では、以下の標準エラーコードが定義されています:

| コード | メッセージ | 意味 |
|-------|----------|------|
| -32700 | Parse error | JSONのパースに失敗 |
| -32600 | Invalid Request | リクエストオブジェクトが不正 |
| -32601 | Method not found | メソッドが存在しない |
| -32602 | Invalid params | パラメータが不正 |
| -32603 | Internal error | 内部エラー |

**-32000から-32099**の範囲は、実装定義のサーバーエラー用に予約されています。

## エラーハンドリングの実装

### サーバー側の実装

まず、エラーレスポンスを生成するヘルパー関数を作成します:

```perl
#!/usr/bin/env perl
use v5.38;
use JSON::MaybeXS;

# エラーコード定数の定義
use constant {
    ERROR_PARSE_ERROR      => -32700,
    ERROR_INVALID_REQUEST  => -32600,
    ERROR_METHOD_NOT_FOUND => -32601,
    ERROR_INVALID_PARAMS   => -32602,
    ERROR_INTERNAL_ERROR   => -32603,
    
    # カスタムエラーコード（-32000 ~ -32099）
    ERROR_VALIDATION_FAILED => -32001,
    ERROR_INSUFFICIENT_FUNDS => -32002,
    ERROR_UNAUTHORIZED       => -32003,
};

# エラーレスポンスを生成
sub create_error_response {
    my ($code, $message, $id, $data) = @_;
    
    my $error = {
        code    => $code,
        message => $message,
    };
    
    # dataフィールドはオプション
    $error->{data} = $data if defined $data;
    
    return {
        jsonrpc => '2.0',
        error   => $error,
        id      => $id,
    };
}

# 標準エラーレスポンスのヘルパー関数
sub parse_error {
    my ($id, $data) = @_;
    return create_error_response(
        ERROR_PARSE_ERROR,
        'Parse error',
        $id,
        $data
    );
}

sub invalid_request {
    my ($id, $data) = @_;
    return create_error_response(
        ERROR_INVALID_REQUEST,
        'Invalid Request',
        $id,
        $data
    );
}

sub method_not_found {
    my ($id, $method) = @_;
    return create_error_response(
        ERROR_METHOD_NOT_FOUND,
        'Method not found',
        $id,
        "Method '$method' does not exist"
    );
}

sub invalid_params {
    my ($id, $data) = @_;
    return create_error_response(
        ERROR_INVALID_PARAMS,
        'Invalid params',
        $id,
        $data
    );
}

sub internal_error {
    my ($id, $data) = @_;
    return create_error_response(
        ERROR_INTERNAL_ERROR,
        'Internal error',
        $id,
        $data
    );
}

# カスタムエラーのヘルパー
sub validation_error {
    my ($id, $errors) = @_;
    return create_error_response(
        ERROR_VALIDATION_FAILED,
        'Validation failed',
        $id,
        { errors => $errors }
    );
}

# 使用例
say encode_json(parse_error(undef, 'Unexpected token'));
say encode_json(method_not_found(1, 'unknownMethod'));
say encode_json(invalid_params(2, 'Required parameter "amount" is missing'));
```

### パラメータのバリデーション

バリデーションエラーを適切に返す実装:

```perl
#!/usr/bin/env perl
use v5.38;
use JSON::MaybeXS;

# バリデーション関数
sub validate_transfer_params {
    my ($params) = @_;
    my @errors;
    
    # fromアカウントのチェック
    if (!defined $params->{from}) {
        push @errors, { field => 'from', message => 'Required field' };
    } elsif ($params->{from} !~ /^\d+$/) {
        push @errors, { field => 'from', message => 'Must be a numeric account ID' };
    }
    
    # toアカウントのチェック
    if (!defined $params->{to}) {
        push @errors, { field => 'to', message => 'Required field' };
    } elsif ($params->{to} !~ /^\d+$/) {
        push @errors, { field => 'to', message => 'Must be a numeric account ID' };
    }
    
    # 金額のチェック
    if (!defined $params->{amount}) {
        push @errors, { field => 'amount', message => 'Required field' };
    } elsif ($params->{amount} !~ /^\d+(?:\.\d+)?$/) {
        push @errors, { field => 'amount', message => 'Must be a positive number' };
    } elsif ($params->{amount} <= 0) {
        push @errors, { field => 'amount', message => 'Must be greater than 0' };
    }
    
    return @errors;
}

# transfer メソッドの実装（バリデーション付き）
sub method_transfer {
    my ($params, $id) = @_;
    
    # パラメータのバリデーション
    my @errors = validate_transfer_params($params);
    if (@errors) {
        return validation_error($id, \@errors);
    }
    
    # ビジネスロジックのバリデーション
    my $balance = get_balance($params->{from});
    if ($balance < $params->{amount}) {
        return create_error_response(
            ERROR_INSUFFICIENT_FUNDS,
            'Insufficient funds',
            $id,
            {
                available => $balance,
                requested => $params->{amount},
            }
        );
    }
    
    # 送金処理を実行
    my $transaction_id = perform_transfer(
        $params->{from},
        $params->{to},
        $params->{amount}
    );
    
    return {
        jsonrpc => '2.0',
        result  => {
            transaction_id => $transaction_id,
            status         => 'completed',
        },
        id => $id,
    };
}

# ダミー関数（実際のDBアクセスに置き換え）
sub get_balance { return 1000 }
sub perform_transfer {
    my ($from, $to, $amount) = @_;
    return sprintf("TXN-%08d", int(rand(99999999)));
}

# テスト
my $request1 = {
    jsonrpc => '2.0',
    method  => 'transfer',
    params  => { from => 'abc', to => '456', amount => 100 },
    id      => 1,
};

my $request2 = {
    jsonrpc => '2.0',
    method  => 'transfer',
    params  => { from => '123', to => '456', amount => 5000 },
    id      => 2,
};

my $request3 = {
    jsonrpc => '2.0',
    method  => 'transfer',
    params  => { from => '123', to => '456', amount => 50 },
    id      => 3,
};

say "=== バリデーションエラー ===";
say encode_json(method_transfer($request1->{params}, $request1->{id}));

say "\n=== 残高不足エラー ===";
say encode_json(method_transfer($request2->{params}, $request2->{id}));

say "\n=== 成功 ===";
say encode_json(method_transfer($request3->{params}, $request3->{id}));
```

### エラーハンドリング付きのサーバー実装

完全なエラーハンドリングを含むJSON-RPCサーバー:

```perl
#!/usr/bin/env perl
use v5.38;
use JSON::MaybeXS;
use Try::Tiny;

# メソッドのレジストリ
my %methods = (
    'add'      => \&method_add,
    'subtract' => \&method_subtract,
    'transfer' => \&method_transfer,
    'divide'   => \&method_divide,
);

# リクエストを処理
sub handle_request {
    my ($json_text) = @_;
    
    # JSONパース（エラーハンドリング）
    my $request;
    try {
        $request = decode_json($json_text);
    } catch {
        # JSONパースエラー
        return encode_json(parse_error(undef, "Invalid JSON: $_"));
    };
    
    # リクエストのバリデーション
    if (ref $request ne 'HASH') {
        return encode_json(invalid_request(undef, 'Request must be an object'));
    }
    
    if (!exists $request->{jsonrpc} || $request->{jsonrpc} ne '2.0') {
        return encode_json(invalid_request($request->{id}, 'Invalid jsonrpc version'));
    }
    
    if (!exists $request->{method}) {
        return encode_json(invalid_request($request->{id}, 'Missing method field'));
    }
    
    my $method = $request->{method};
    my $params = $request->{params} // {};
    my $id     = $request->{id};
    
    # メソッドの存在チェック
    if (!exists $methods{$method}) {
        return encode_json(method_not_found($id, $method));
    }
    
    # メソッドを実行（エラーハンドリング）
    my $response;
    try {
        $response = $methods{$method}->($params, $id);
    } catch {
        # 予期しないエラー
        warn "Internal error in method '$method': $_";
        $response = internal_error($id, 'An unexpected error occurred');
    };
    
    return encode_json($response);
}

# 各メソッドの実装
sub method_add {
    my ($params, $id) = @_;
    
    return invalid_params($id, 'Params must be an array of two numbers')
        unless ref $params eq 'ARRAY' && @$params == 2;
    
    return invalid_params($id, 'All params must be numbers')
        unless looks_like_number($params->[0]) && looks_like_number($params->[1]);
    
    return {
        jsonrpc => '2.0',
        result  => $params->[0] + $params->[1],
        id      => $id,
    };
}

sub method_subtract {
    my ($params, $id) = @_;
    
    return invalid_params($id, 'Params must be an object with "minuend" and "subtrahend"')
        unless ref $params eq 'HASH' && exists $params->{minuend} && exists $params->{subtrahend};
    
    return {
        jsonrpc => '2.0',
        result  => $params->{minuend} - $params->{subtrahend},
        id      => $id,
    };
}

sub method_divide {
    my ($params, $id) = @_;
    
    return invalid_params($id, 'Params must be an array of two numbers')
        unless ref $params eq 'ARRAY' && @$params == 2;
    
    # ゼロ除算のカスタムエラー
    if ($params->[1] == 0) {
        return create_error_response(
            -32000,  # カスタムエラーコード
            'Division by zero',
            $id,
            { dividend => $params->[0], divisor => $params->[1] }
        );
    }
    
    return {
        jsonrpc => '2.0',
        result  => $params->[0] / $params->[1],
        id      => $id,
    };
}

sub looks_like_number {
    my $val = shift;
    return defined $val && $val =~ /^-?\d+(?:\.\d+)?$/;
}

# テスト実行
say "=== 正常なリクエスト ===";
say handle_request('{"jsonrpc": "2.0", "method": "add", "params": [5, 3], "id": 1}');

say "\n=== JSONパースエラー ===";
say handle_request('{"jsonrpc": "2.0", "method": "add", "params": [5, 3], "id": 1');

say "\n=== メソッドが存在しない ===";
say handle_request('{"jsonrpc": "2.0", "method": "unknown", "params": [], "id": 2}');

say "\n=== パラメータが不正 ===";
say handle_request('{"jsonrpc": "2.0", "method": "add", "params": [5], "id": 3}');

say "\n=== ゼロ除算エラー ===";
say handle_request('{"jsonrpc": "2.0", "method": "divide", "params": [10, 0], "id": 4}');
```

## クライアント側のエラーハンドリング

クライアント側では、レスポンスに`error`フィールドが含まれているかをチェックし、適切に処理します:

```perl
#!/usr/bin/env perl
use v5.38;
use HTTP::Tiny;
use JSON::MaybeXS;
use Try::Tiny;

my $client = HTTP::Tiny->new(timeout => 10);
my $url = 'http://localhost:8080/jsonrpc';

# JSON-RPCリクエストを送信して結果を取得
sub call_jsonrpc {
    my ($method, $params, $id) = @_;
    $id //= int(rand(10000));
    
    my $request = {
        jsonrpc => '2.0',
        method  => $method,
        params  => $params,
        id      => $id,
    };
    
    my $json_request = encode_json($request);
    
    # HTTPリクエストを送信
    my $response = $client->post(
        $url,
        {
            content => $json_request,
            headers => { 'Content-Type' => 'application/json' },
        }
    );
    
    # HTTP エラーチェック
    unless ($response->{success}) {
        die "HTTP Error: $response->{status} $response->{reason}\n";
    }
    
    # JSON レスポンスをパース
    my $result;
    try {
        $result = decode_json($response->{content});
    } catch {
        die "Failed to parse JSON response: $_\n";
    };
    
    # エラーレスポンスのチェック
    if (exists $result->{error}) {
        my $error = $result->{error};
        
        # エラー情報を構造化
        my $error_info = {
            code    => $error->{code},
            message => $error->{message},
            data    => $error->{data},
        };
        
        # エラーをdie（例外として投げる）
        die bless $error_info, 'JSONRPCError';
    }
    
    # 正常な結果を返す
    return $result->{result};
}

# カスタム例外クラス
package JSONRPCError {
    use overload '""' => sub {
        my $self = shift;
        my $msg = "JSON-RPC Error $self->{code}: $self->{message}";
        $msg .= "\nData: " . encode_json($self->{data}) if $self->{data};
        return $msg;
    };
    
    sub is_parse_error      { shift->{code} == -32700 }
    sub is_invalid_request  { shift->{code} == -32600 }
    sub is_method_not_found { shift->{code} == -32601 }
    sub is_invalid_params   { shift->{code} == -32602 }
    sub is_internal_error   { shift->{code} == -32603 }
}

package main;

# エラーハンドリングの例
sub transfer_money {
    my ($from, $to, $amount) = @_;
    
    try {
        my $result = call_jsonrpc('transfer', {
            from   => $from,
            to     => $to,
            amount => $amount,
        });
        
        say "Transfer successful!";
        say "Transaction ID: $result->{transaction_id}";
        say "Status: $result->{status}";
        
    } catch {
        my $error = $_;
        
        if (ref $error eq 'JSONRPCError') {
            # JSON-RPCエラーを詳細に処理
            given ($error->{code}) {
                when (-32602) {
                    say "Invalid parameters:";
                    if (ref $error->{data}{errors} eq 'ARRAY') {
                        for my $err (@{$error->{data}{errors}}) {
                            say "  - $err->{field}: $err->{message}";
                        }
                    }
                }
                when (-32002) {  # 残高不足
                    say "Insufficient funds!";
                    say "Available: $error->{data}{available}";
                    say "Requested: $error->{data}{requested}";
                }
                when (-32003) {  # 認証エラー
                    say "Unauthorized: $error->{message}";
                }
                default {
                    say "Error: $error";
                }
            }
        } else {
            # その他のエラー（HTTP、ネットワークなど）
            warn "Unexpected error: $error";
        }
    };
}

# 使用例
say "=== 正常なケース ===";
transfer_money(123, 456, 100);

say "\n=== バリデーションエラー ===";
transfer_money('abc', 456, 100);

say "\n=== 残高不足エラー ===";
transfer_money(123, 456, 10000);
```

## エラーハンドリングのベストプラクティス

### 1. 適切なエラーコードを使用する

```perl
# 良い例: 標準エラーコードを使用
if (!exists $methods{$method}) {
    return method_not_found($id, $method);
}

# 悪い例: カスタムコードで標準エラーを表現
if (!exists $methods{$method}) {
    return create_error_response(-32000, 'No such method', $id);
}
```

### 2. エラーメッセージは明確に

```perl
# 良い例: 具体的なメッセージ
return invalid_params($id, 'Parameter "email" must be a valid email address');

# 悪い例: 曖昧なメッセージ
return invalid_params($id, 'Bad input');
```

### 3. dataフィールドで詳細情報を提供

```perl
# バリデーションエラーでフィールド別のエラーを返す
return validation_error($id, [
    { field => 'email', message => 'Invalid format' },
    { field => 'age', message => 'Must be 18 or older' },
]);

# ビジネスロジックエラーで関連データを返す
return create_error_response(
    ERROR_INSUFFICIENT_FUNDS,
    'Insufficient funds',
    $id,
    { available => 100, requested => 500 }
);
```

### 4. 内部エラーは隠す

```perl
# 良い例: 詳細は隠してログに記録
try {
    # 危険な処理
} catch {
    warn "Internal error: $_";  # ログに記録
    return internal_error($id, 'An unexpected error occurred');  # クライアントには概要のみ
};

# 悪い例: 内部情報を露出
catch {
    return internal_error($id, "SQL error: $_");  # セキュリティリスク
};
```

## まとめ

- **標準エラーコード**: -32700〜-32603を仕様通りに使用
- **カスタムエラー**: -32000〜-32099の範囲を使用
- **エラー構造**: code、message は必須、data はオプション
- **バリデーション**: パラメータは受け取った時点で検証
- **クライアント**: error フィールドの有無をチェックして分岐
- **セキュリティ**: 内部エラーの詳細は隠し、ログに記録

適切なエラーハンドリングにより、クライアントは問題を正確に把握し、ユーザーに適切なフィードバックを提供できます。次回は、バッチリクエストとノーティフィケーション（通知）について解説します。
