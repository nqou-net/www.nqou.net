---
title: "【企画書】PerlでJSON-RPC 2.0のオブジェクトを値オブジェクトとして定義してみた - 全3回シリーズ"
draft: true
tags:
- perl
- json-rpc
- value-object
- test-driven-development
- design-pattern
description: "Perlで値オブジェクトパターンを用いたテスト駆動開発を学ぶ技術シリーズの企画書。JSON-RPC 2.0を題材に、基礎から実践まで段階的に学習できる構成を提案します。"
---

## シリーズ企画の概要

この企画書では、「PerlでJSON-RPC 2.0のオブジェクトを値オブジェクトとして定義してみた」をテーマとした全3回の技術シリーズ記事を提案します。

### シリーズ全体の狙いと学習の流れ

値オブジェクトという設計パターンを知らない読者が、Perlでテスト駆動開発ができるようになることを目指します。第1回で値オブジェクトの概念と基本的な実装方法を理解し、第2回・第3回でJSON-RPC 2.0という具体的な仕様を題材に実践的な実装を学びます。シリーズを通して、「複雑に見える仕様も、値オブジェクトで分解するとシンプルになる」という発見を体験できる構成にします。各回は独立して読めますが、連続して読むことで、設計思想の理解が深まり、実践力が身につきます。

---

## 第1回：値オブジェクトの基礎 - データの信頼性を高める設計パターン

### タイトル案

「Perlで始める値オブジェクト入門 - プリミティブ型の呪縛から解放されよう」

### 要約

値オブジェクト（Value Object）とは何か、なぜ必要なのかを初心者にもわかりやすく解説します。文字列や数値といったプリミティブ型をそのまま使う問題点を具体例で示し、値オブジェクトを導入することで得られるメリット（型安全性、バリデーションの一元化、テストの容易さ）を実感してもらいます。Perlでの基本的な実装パターンとテストコードの書き方を紹介し、次回以降のJSON-RPC実装への土台を築きます。

### 主要トピック

1. **値オブジェクトとは何か**
   - プリミティブ型（文字列、数値）を使った従来のコードの問題点
   - 値オブジェクトの定義と特徴（不変性、等価性、自己バリデーション）
   - ドメイン駆動設計（DDD）における位置づけ

2. **Perlでの値オブジェクトの基本実装**
   - シンプルな例：`EmailAddress` 値オブジェクト
   - コンストラクタでのバリデーション実装
   - 不変性の確保（再代入の防止）
   - 等価性の比較（オーバーロードの活用）

3. **値オブジェクトのテスト駆動開発**
   - Test::More を使った基本的なテストの書き方
   - 正常系・異常系のテストケース設計
   - バリデーションルールごとのテスト分割
   - テストファーストの開発フロー体験

4. **値オブジェクトを使うメリット**
   - ビジネスルールのカプセル化
   - コードの可読性向上
   - バグの早期発見
   - リファクタリングの安全性

5. **次回への橋渡し**
   - JSON-RPC 2.0 仕様の簡単な紹介
   - 値オブジェクトで表現できそうな要素の示唆

### 推定文字数

約 4,000〜5,000文字（コード例含む）

### コード例の構成

- **悪い例**: メールアドレスを文字列で扱うコード（バリデーション分散）
- **良い例**: `EmailAddress` 値オブジェクトの実装
- **テストコード**: `EmailAddress` のユニットテスト（正常系・異常系）
- **応用例**: 複数の値オブジェクトを組み合わせた `User` クラス

---

## 第2回：JSON-RPC 2.0 Request と Error を値オブジェクトで実装する

### タイトル案

「JSON-RPC 2.0のリクエストとエラーを値オブジェクトで堅牢に実装する」

### 要約

JSON-RPC 2.0仕様から、Request object と Error object を取り上げ、値オブジェクトとして実装します。仕様書を読み解きながら、各フィールドの制約条件（必須・オプション、型、値の範囲）を値オブジェクトのバリデーションとして表現します。特にError objectの構造的な複雑さ（code、message、data）を、小さな値オブジェクトに分解することでシンプルに扱える設計手法を学びます。テスト駆動開発で進めることで、仕様への理解が深まる体験を提供します。

### 主要トピック

1. **JSON-RPC 2.0 仕様の概要**
   - JSON-RPC 2.0とは（リモートプロシージャコールの標準規格）
   - 仕様書の構造と読み方のコツ
   - Request、Response、Errorの関係性

2. **Request object の値オブジェクト実装**
   - 仕様の詳細確認（jsonrpc、method、params、id）
   - `JsonRpcVersion` 値オブジェクト（"2.0"固定値の表現）
   - `MethodName` 値オブジェクト（文字列バリデーション）
   - `RequestParams` 値オブジェクト（構造化データまたは配列）
   - `RequestId` 値オブジェクト（文字列、数値、nullの扱い）
   - `JsonRpcRequest` 値オブジェクト（全体を組み立て）

3. **Error object の値オブジェクト実装**
   - 仕様の詳細確認（code、message、data）
   - `ErrorCode` 値オブジェクト（整数、予約済みコード範囲）
   - `ErrorMessage` 値オブジェクト（簡潔な説明文字列）
   - `ErrorData` 値オブジェクト（オプショナルな追加情報）
   - `JsonRpcError` 値オブジェクト（全体を組み立て）

4. **テスト駆動で実装を進める**
   - 仕様書の各項目をテストケースに変換
   - 境界値テスト（文字列長、数値範囲）
   - 不正な入力に対するエラーハンドリング
   - JSONシリアライゼーション・デシリアライゼーションのテスト

5. **設計のポイント**
   - 小さな値オブジェクトに分解する利点
   - 値オブジェクト間の関係性の整理
   - 再利用可能な部品としての設計

### 推定文字数

約 5,500〜6,500文字（コード例含む）

### コード例の構成

- **仕様書抜粋**: JSON-RPC 2.0のRequest/Error部分の要約
- **値オブジェクト実装**: `JsonRpcVersion`, `MethodName`, `RequestId`, `JsonRpcRequest`
- **値オブジェクト実装**: `ErrorCode`, `ErrorMessage`, `JsonRpcError`
- **テストコード**: 各値オブジェクトのユニットテスト
- **統合例**: Requestオブジェクトの生成とバリデーション

---

## 第3回：JSON-RPC 2.0 Response を排他的な値オブジェクトで表現する

### タイトル案

「JSON-RPC 2.0 Responseの成功とエラーを型で区別する - 排他的な値オブジェクト設計」

### タイトル案

「JSON-RPC 2.0のレスポンスを値オブジェクトで完成させる - 排他性と型安全性の実現」

### 要約

JSON-RPC 2.0のResponse objectは、成功時とエラー時で排他的な構造を持ちます（resultとerrorは同時に存在しない）。この仕様上の制約を、Perlの型システムと値オブジェクトで表現する手法を学びます。`SuccessResponse` と `ErrorResponse` を別々の値オブジェクトとして定義し、共通のインターフェースで扱えるように設計します。シリーズの集大成として、Request/Response/Errorすべてを値オブジェクトで実装し、堅牢なJSON-RPCクライアント/サーバーの基盤を完成させます。

### 主要トピック

1. **Response object の仕様理解**
   - 仕様の詳細確認（jsonrpc、result、error、id）
   - resultとerrorの排他性（MUST NOT contain both）
   - 成功時とエラー時の構造の違い

2. **排他的な値オブジェクトの設計**
   - なぜ1つのResponseクラスではダメなのか
   - `SuccessResponse` 値オブジェクトの実装
   - `ErrorResponse` 値オブジェクトの実装
   - 共通インターフェースの定義（ポリモーフィズム）

3. **Result と Response の値オブジェクト実装**
   - `ResponseResult` 値オブジェクト（任意のJSON値）
   - `ResponseId` 値オブジェクト（Requestとの対応）
   - `JsonRpcSuccessResponse` 値オブジェクト
   - `JsonRpcErrorResponse` 値オブジェクト（第2回のErrorを再利用）

4. **型安全性の確保**
   - 実行時の型チェック
   - パターンマッチング的なディスパッチ
   - 静的解析ツールとの連携（Perl::Critic等）

5. **シリーズの総まとめ**
   - Request → Response のフルサイクル実装例
   - すべての値オブジェクトを使った統合テスト
   - 値オブジェクトパターンの応用範囲
   - 実務での活用シーン（API設計、ドメインモデル）

6. **さらなる学習へ**
   - 参考書籍・記事の紹介
   - 他の言語での値オブジェクト実装
   - ドメイン駆動設計への発展

### 推定文字数

約 6,000〜7,000文字（コード例含む）

### コード例の構成

- **仕様書抜粋**: JSON-RPC 2.0のResponse部分の要約と排他性の強調
- **値オブジェクト実装**: `ResponseResult`, `JsonRpcSuccessResponse`, `JsonRpcErrorResponse`
- **ポリモーフィズム例**: 共通インターフェースでの扱い
- **統合テストコード**: Request送信からResponse受信までのフルサイクル
- **実践例**: 簡易的なJSON-RPCクライアントの実装

---

## シリーズ全体を通した技術タグの提案

1. **perl** - メイン言語
2. **json-rpc** - 題材となる技術仕様
3. **value-object** - 核心となる設計パターン
4. **test-driven-development** - 開発手法
5. **design-pattern** - 設計思想全般

### 補足タグ候補（記事ごとに追加）

- 第1回: `beginner`, `refactoring`
- 第2回: `api-design`, `validation`
- 第3回: `type-safety`, `polymorphism`

---

## 企画のポイント

### 段階的な学習設計

- **第1回**: 概念理解（Why）+ 基礎実装（How）
- **第2回**: 実践応用（Request/Error）+ 設計手法
- **第3回**: 高度な設計（排他性）+ 総合演習

### 読者の成長曲線

各回を読み進めるごとに、以下のスキルが身につきます：

1. 値オブジェクトの概念と基本実装
2. 仕様書を読み解き、制約を値オブジェクトで表現する力
3. 複雑なドメインモデルを型安全に設計する力

### 独立性と連続性の両立

- 各回は独立したトピックとして完結
- しかし、前回の知識を前提に深掘りする構成
- 第1回だけ読んでも価値がある
- 全3回読むと体系的な理解が得られる

### 実践重視

- すべてのコードは実行可能
- テストコードを必ず含める
- GitHubリポジトリでの公開を推奨
- 読者が手を動かして学べる

---

## 想定される読者の反応

### 第1回後

「値オブジェクトって便利！今すぐ既存コードに導入したい」

### 第2回後

「仕様書を値オブジェクトに落とし込む手順がわかった。他のAPI仕様でも試せそう」

### 第3回後

「排他性を型で表現する設計が美しい。Perlでもここまでできるんだ」

---

## まとめ

この企画は、「値オブジェクト」という普遍的な設計パターンを、「JSON-RPC 2.0」という具体的な題材で学ぶシリーズです。Perlという言語の制約の中で、いかに型安全で堅牢なコードを書くかという挑戦を通じて、読者は設計力とテスト駆動開発のスキルを身につけられます。

シリーズ完走後、読者は自信を持って「Perlで値オブジェクトを使ったテスト駆動開発ができる」と言えるようになるでしょう。

---

**企画者コメント**

JSON-RPC 2.0という仕様は、シンプルに見えて実は排他性や型制約など、設計上の学びが詰まった良い題材です。「複雑な仕様も値オブジェクトで分解するとシンプルになる」という発見を、読者に体験してもらいたいと考えています。

Perlという言語は型システムが弱いと言われがちですが、値オブジェクトパターンを使えば、十分に堅牢なコードが書けることを示したいです。そして、この手法は他の動的型付け言語（Python、Ruby、JavaScriptなど）にも応用可能です。

このシリーズが、「アイデア生成」のように、読者の設計思考に新しい視点を提供できれば幸いです。

