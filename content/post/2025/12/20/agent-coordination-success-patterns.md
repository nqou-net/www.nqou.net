---
title: "なぜエージェント連携がうまくいくようになったのか - 観察から見えた3つの成功パターン"
draft: true
tags:
- ai
- copilot
- prompt
description: "エージェント連携の成功パターンを実体験から解説。AGENTS.md作成の試行錯誤から見えた名前の一致・定義場所・ワークフロー定義の3つのポイント。DeNA LLM勉強会の知見も活用した実践ガイド。"
---

## はじめに - 試行錯誤の先に見えたもの

### 最初はわからなかった

GitHub Copilotを使い始めて、AGENTS.mdという仕組みを知りました。「AIエージェント向けのREADME」という説明を読んで、とりあえずAIに書かせてみたんです。

最初のうちは、うまく動くこともあれば、動かないこともある。なぜうまくいくのか、なぜ失敗するのか、理由がまったくわかりませんでした。でも、使い続けているうちに、少しずつパターンが見えてきたんです。

「あ、ここを直したら動いた」「この書き方だと連携がスムーズだ」——そんな小さな発見を積み重ねていくうち、3つの成功パターンが浮かび上がってきました。

### 転機：DeNA LLM勉強会の資料

試行錯誤を続けていたある日、{{< linkcard "https://engineering.dena.com/blog/2025/12/llm-study-1201/" >}}の資料を見つけました。

特に15〜22ページの「プロンプトエンジニアリングの基礎」のセクションは目から鱗でした。重要な部分の強調方法、役割付与の効果、ハルシネーション防止のテクニック——これまで感覚的にやっていたことが、理論として体系化されていたんです。

この資料を読んで、自分の試行錯誤が間違っていなかったこと、そして、もっと良い方向に進める余地があることに気づきました。

### この記事で共有すること

この記事では、私が観察から学んだ3つの成功パターンと、DeNA勉強会資料から学んだプロンプト技術を共有します。

- 観察からわかった3つの成功パターン
- 勉強会資料から学んだプロンプト技術
- 実際のワークフロー例
- 今後の課題と展望

あなたも、AGENTS.mdやカスタムエージェントを使ってAIエージェントを活用できるようになりましょう。

## 観察してわかった3つの成功パターン

試行錯誤を繰り返す中で、エージェント連携を成功させるための3つのシンプルなパターンが見えてきました。

### パターン1: 名前を一致させる

一番最初に気づいたのは、エージェント同士を連携させる際の**名前の一致**です。

カスタムエージェントの定義ファイルには、YAMLフロントマターで `name` と `handoffs` を設定します。このとき、`handoffs` の `agent` に指定する名前が、参照先エージェントの `name` と完全に一致している必要があるんです。

**良い例**:

```yaml
# tester.agent.md
---
name: tester
handoffs:
  - label: 実装を開始
    agent: implementation  # ← implementation.agent.md の name と一致
---
```

```yaml
# implementation.agent.md
---
name: implementation  # ← tester から参照される名前
---
```

**悪い例**:

```yaml
# tester.agent.md
handoffs:
  - agent: impl  # ← 短縮名を使うと参照できない
```

最初のうちは、「短縮名でも通じるだろう」と思って `impl` とか `test` とか、短い名前を使っていました。でも、これだとエージェント間の連携がうまくいかないんです。

ある日、名前を完全一致させたら、突然連携が動いた瞬間がありました。「こんなシンプルなことだったのか！」と驚きましたが、同時に、見落としやすい罠でもあると感じました。

### パターン2: エージェント定義の場所を示す

2つ目のパターンは、**エージェント定義ファイルの配置場所の統一**です。

カスタムエージェント定義ファイルは、`.github/agents/` ディレクトリに `{role}.agent.md` という形式で配置します。この配置ルールを一貫させることで、エージェント間の連携が安定するんです。

**推奨配置**:

```
.github/
  agents/
    investigative-research.agent.md
    search-engine-optimization.agent.md
    proofreader.agent.md
    reviewer.agent.md
```

**命名規則**:

- `{役割名}.agent.md` の形式
- 役割がわかりやすい名前をつける
- ハイフン区切り（kebab-case）を推奨

この配置ルールを守ることで、「このエージェントはどこに定義されているのか」が明確になり、AIが自律的にエージェントを見つけられるようになります。

発見したのは、場所を明示するだけで連携が安定するということです。AIは思った以上に「構造」や「規則性」を理解してくれます。

### パターン3: ワークフローとして定義する

3つ目のパターンは、**エージェント間の連携をワークフローとして定義する**ことです。

エージェントは単発のタスクを実行するだけでなく、次のエージェントへ引き継ぐことができます。この引き継ぎを `handoffs` で定義することで、複数のエージェントが協力して大きなタスクを達成できるようになります。

**記事作成ワークフローの実例**:

```
1. investigative-research（調査エージェント）
   ↓ handoff
2. search-engine-optimization（アウトライン作成エージェント）
   ↓ handoff
3. 専門家エージェント（記事作成）
   ↓ handoff
4. layout-and-content-harmonization（整形エージェント）
   ↓ handoff
5. proofreader（校正エージェント）
   ↓ handoff
6. reviewer（最終確認エージェント）
```

各エージェントは自分の専門分野に集中し、完了したら次のエージェントへバトンタッチします。まるでリレーのように、タスクが次々と引き継がれていくんです。

このワークフローを定義することで気づいたのは、「**正しく情報を与えてあげるだけ**」でAIが自律的に動いてくれるということです。複雑な制御ロジックは不要で、シンプルな定義だけでうまく連携してくれます。

## DeNA勉強会資料から学んだプロンプト技術

試行錯誤を続けていた私にとって、{{< linkcard "https://engineering.dena.com/blog/2025/12/llm-study-1201/" >}}の資料は大きな転機になりました。

### ベストプラクティスの重要性

勉強会資料を読んで最初に感じたのは、「基礎を押さえることの大切さ」でした。

私はこれまで、感覚的にプロンプトを書いていました。「こう書いたらうまくいった」という経験則だけが頼りだったんです。でも、資料を読むことで、なぜうまくいったのか、どうすればもっと良くなるのかが理論的に理解できるようになりました。

基礎を押さえれば、応用はその先にあります。エージェント定義にも、プロンプトエンジニアリングの知見を活かせることがわかりました。

### 重要な部分を強調する方法

プロンプトでは、重要な部分を明示的に強調することが大切です。勉強会資料で学んだテクニックをいくつか紹介します。

#### 優先順位の明示

```markdown
【優先順位】
1. 正確性
2. 簡潔性
3. 応答速度
```

AIに「何を最優先すべきか」を明確に伝えることで、期待する出力に近づきます。

#### 出力形式の指定

```markdown
【出力形式】
- Markdown形式で出力
- コードブロックには言語タグを付与
- 見出しはH2/H3のみ使用
```

形式を明示することで、出力のばらつきを抑え、一貫性のある結果を得られます。

#### 太字や箇条書きの効果的な使い方

AGENTS.mdでも、**重要な制約**や**絶対にしてはいけないこと**を太字で強調したり、箇条書きで整理したりすることで、AIが重要なポイントを見逃しにくくなります。

### 役割付与の効果

勉強会資料で特に印象的だったのは、「あなたは専門家です」という一文の効果です。

AIに明確な役割や専門性を付与することで、回答の質が大きく変わります。これを「役割付与（Role Prompting）」と呼びます。

**基本形**:

```
あなたは10年以上の経験を持つ[専門分野]の専門家です。
[専門分野]に深い愛とこだわりを持っています。
```

私はこのリポジトリで `perl-monger` というカスタムエージェントを定義しています（詳しくは[perl-mongerをカスタムエージェントとして定義した](/2025/12/07/012345/)をご覧ください）。

```markdown
You are "perl-monger", a Perl-obsessed specialist. 
Be enthusiastic and geeky but helpful.
```

試しに、この `perl-monger` にRubyについて聞いてみました。すると、「Perl好きから見て一言」という独自の視点で回答してくれたんです。単なる技術比較ではなく、「魔術性」「アプローチの違い」といった本質的な特徴を指摘しつつ、「どちらも愛でる派です :)」と寛容さも示してくれました。

ペルソナが回答の質を変える——この発見は、カスタムエージェント設計において非常に重要でした。

### ハルシネーション防止

AIの「ハルシネーション（もっともらしい嘘）」を防ぐためのテクニックも学びました。

#### 出典を明示させる

```
必ず公式ソースのURLを併記してください。
引用する場合は出典を明記してください。
```

これにより、AIが推測で回答することを防ぎ、根拠のある情報だけを提供させることができます。

#### 不明点は「わからない」と答えさせる

```
根拠がない場合は「わからない」と答えてください。
推測で回答しないでください。
```

AIは質問に答えようとするあまり、知らないことでも推測で答えてしまうことがあります。この指示を加えることで、AIが正直に「わからない」と答えるようになります。

#### エージェント定義での実践例

実際にカスタムエージェントを定義する際、以下のような指示を含めています。

```yaml
---
name: investigative-research
description: 調査専門のエージェント。情報の正確性を最優先する。
---

## 行動指針
- 根拠が不明な情報は推測しない
- 不明点は必ず質問して明確化
- 出典はMarkdown形式で明記
- わからない場合は「わからない」と答える
```

このように、ハルシネーション防止のテクニックをエージェント定義に組み込むことで、信頼性の高い出力を得られるようになりました。

## ドメイン特化型AIという選択

エージェント連携を設計する際、重要なのは「専門性」です。

### なぜ専門性を高めるのか

汎用的なAIは便利ですが、特定の分野では限界があります。ドメイン特化型AIには、研究で裏付けられた5つのメリットがあります。

1. **ドメイン内性能の向上** - 特定領域に特化することで、より正確で詳細な回答が可能
2. **ハルシネーションとリスク低減** - 専門知識に絞ることで、誤情報生成の確率が低下
3. **専門知識・語彙のキャプチャ** - ドメイン固有の用語や概念を適切に理解
4. **少量データでの有効性** - 微調整手法により、少ないデータでも高性能
5. **コストと効率のトレードオフ** - 必要な機能に絞ることで効率的に動作

（参考：{{< linkcard "https://www.getguru.com/reference/domain-specific-ai" >}}）

「GitHub Copilotの awesome-copilot」については、[GitHub Copilot の awesome-copilot で開発体験を向上させる](/2025/12/06/212332/)の記事でも詳しく解説しています。

### Less is More - 定義の粒度

エージェントを定義する際、最初は「細かく定義した方が良い」と思っていました。でも、実際に運用してみると、**定義しすぎると柔軟性が失われる**ことがわかりました。

**失敗例（定義しすぎ）**:

```yaml
---
name: perl-expert
---
推奨フレームワーク: Catalyst, Mojolicious, Dancer
推奨モジュール: Plack, DBIx::Class, Moo
推奨スタイル: PBP（Perl Best Practices）
テストツール: Test::More, Test::Deep
```

この場合、定義にないフレームワークやモジュールについて聞かれると、対応が硬直化してしまいます。

**成功例（シンプル）**:

```yaml
---
name: perl-monger
description: Perl愛好家。熱狂的でオタク的だが役に立つ
---

イディオマティックなPerlを優先
必要に応じてバージョンやCPANモジュールに言及
```

シンプルな性格設定だけで、AIの基礎知識と推論能力が適切な回答を導いてくれます。

**教訓**: **定義しすぎない感じが良い**

### カスタムエージェントの実例

実際に `perl-monger` を使ってみると、シンプルな定義でも効果的に動くことがわかります。

ペルソナが生む独自の視点は、単なる技術解説を超えた深い洞察を提供してくれます。Rubyについて聞いたときの「Perl好きとして一言」という切り口は、まさにペルソナの力です。

## 実践：このリポジトリでのワークフロー

ここまで理論を説明してきましたが、実際のワークフローを見てみましょう。

### 記事作成フローの全体像

このリポジトリでは、記事作成に6つのエージェントが連携しています。

```
1. investigative-research（調査エージェント）
   ↓ 調査結果をまとめる
2. search-engine-optimization（アウトライン作成エージェント）
   ↓ アウトラインを作成
3. 専門家エージェント（記事執筆）
   ↓ 記事本文を執筆
4. layout-and-content-harmonization（整形エージェント）
   ↓ レイアウトと内容を調整
5. proofreader（校正エージェント）
   ↓ 誤字脱字や表現をチェック
6. reviewer（最終確認エージェント）
   ↓ 最終確認して完了
```

各エージェントは `handoffs` で次のエージェントへ自動的に引き継ぎます。まるでベルトコンベアのように、タスクがスムーズに流れていくんです。

### 定義ファイルを見てみる

実際のエージェント定義ファイルはシンプルです。

**YAMLフロントマター**:

```yaml
---
name: proofreader
description: 校正専門のエージェント。誤字脱字や表現をチェックする。
tools: ["read", "edit"]
handoffs:
  - label: 最終確認へ
    agent: reviewer
    prompt: 最終確認をお願いします
---
```

**本文**:

```markdown
あなたは10年以上の経験を持つ校正者です。
誤字脱字、表記ゆれ、不自然な表現を見つけることに情熱を注いでいます。

## チェック項目
- 誤字脱字
- 表記ゆれ
- 文法的な誤り
- 読みやすさ
```

シンプルですが、これで十分に機能します。

### 運用してわかったこと

実際に運用してみて、いくつかの重要なことがわかりました。

#### 完璧を目指さない

最初から完璧なエージェントを作ろうとすると、定義が複雑になりすぎて逆効果です。まずはシンプルに始めて、必要に応じて調整していく方がうまくいきます。

#### 小さく始めて観察する

1つのエージェントから始めて、動作を観察しながら少しずつ改善していくアプローチが有効です。観察することで、どこを改善すればいいかが見えてきます。

#### 改善は段階的に

一度にたくさんの変更をすると、何が効果的だったのかがわからなくなります。1つずつ変更して、その効果を確認する——この繰り返しが大切です。

## 今後の課題と展望

エージェント連携はまだ発展途上の分野です。今後の課題と展望について考えてみます。

### まだ標準化とは言えない

エージェント配置（`.github/agents/*.md`）については、60,000以上のリポジトリで採用される業界標準「AGENTS.md」（詳しくは{{< linkcard "https://agents.md/" >}}を参照）として確立されつつあります。

しかし、エージェント間の連携パターンについては、まだ模索中の段階です。コミュニティでベストプラクティスを共有し、標準化を進めていく必要があります。

AGENTS.mdについて最初に試したときの記事は、[エージェントガイドラインを作成するプロンプトを試してみた](/2025/11/27/233234/)で詳しく書いています。また、[エージェントパネルから記事を生成してみた](/2025/11/29/010643/)では、エージェントパネルを使った実践例を紹介しています。

### A2Aプロトコルの可能性

将来的には、「A2A（Agent to Agent）プロトコル」（{{< linkcard "https://a2a-protocol.org/latest/" >}}）のような標準化された通信プロトコルが重要になるかもしれません。

A2Aプロトコルは、異なるベンダーや実装のAIエージェント同士が標準化された方法で連携するための仕様です。主な特徴は以下の通りです。

- **Agent Card** - エージェントの能力を公開
- **Task** - 作業単位の定義
- **Message/Parts** - 多モーダルなやり取り
- **Artifact** - 成果物の受け渡し

これにより、マイクロサービスのようにエージェントを組み合わせることが可能になります。将来的には、異なるAIサービスのエージェントを自由に組み合わせて使える時代が来るかもしれません。

### 継続的な観察と改善

エージェント連携は、使いながら学んでいくものです。

- フィードバックループを回す
- うまくいったパターンを記録する
- 失敗から学ぶ
- 知見を共有する文化を作る

この記事も、私の観察結果を共有する試みの1つです。あなたも、自分の経験を共有してみてください。コミュニティ全体で知見が蓄積されれば、エージェント連携はもっと使いやすくなるはずです。

## まとめ - 正しく情報を与えてあげるだけ

長い記事になりましたが、最後にポイントを整理します。

### 成功の3つのパターン再確認

エージェント間連携を成功させるための3つのシンプルなパターン:

1. **名前を一致させる** - `handoffs` の `agent` 名と参照先の `name` を完全一致
2. **定義の場所を示す** - `.github/agents/{role}.agent.md` に統一配置
3. **ワークフローとして定義する** - `handoffs` で次のエージェントへの引き継ぎを明示

### プロンプトエンジニアリングの基礎

DeNA勉強会資料から学んだ重要なポイント:

- **役割付与** - 「あなたは専門家です」でペルソナを与える
- **ハルシネーション防止** - 出典の明示、「わからない」と答えさせる
- **強調方法** - 優先順位、出力形式、良例・悪例の提示

### あなたも今日から始められる

エージェント連携は難しくありません。以下のステップで始めてみてください。

1. **AGENTS.mdを作成してみる**
   - リポジトリのルートに `AGENTS.md` を配置
   - プロジェクトの概要、技術スタック、制約を記述
   - GitHub Copilot公式ドキュメント（{{< linkcard "https://docs.github.com/ja/copilot/concepts/agents/coding-agent/about-custom-agents" >}}）も参考に

2. **シンプルなカスタムエージェントを定義する**
   - `.github/agents/` ディレクトリを作成
   - 1つの専門性に絞ったエージェントから始める
   - 細かく定義しすぎない（Less is More）

3. **観察しながら改善していく**
   - 実際に使ってみる
   - うまくいったこと、いかなかったことを記録する
   - 少しずつ改善を重ねる

**重要なのは、正しく情報を与えてあげるだけ**です。複雑な制御ロジックは不要で、シンプルな定義だけでAIは自律的に動いてくれます。

あなたの試行錯誤が、新しい発見につながることを願っています。

## 参考リンク

- {{< linkcard "https://engineering.dena.com/blog/2025/12/llm-study-1201/" >}}
- {{< linkcard "https://docs.github.com/ja/copilot" >}}
- {{< linkcard "https://agents.md/" >}}
