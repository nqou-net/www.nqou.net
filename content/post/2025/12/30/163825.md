---
title: 'PerlでTODOリスト（CLI）を作成する - 第5回: ファイル版の限界とデータベースへの移行'
draft: true
tags:
  - perl
  - dbi
  - sqlite
description: PerlでCLIベースのTODOリストアプリを作る連載の第5回。テキストファイルによるデータ管理の限界を理解し、DBIとSQLiteを使ったデータベースへの移行準備を学びます。
---

[@nqounet](https://x.com/nqounet)です。

「PerlでTODOリスト（CLI）を作成する」シリーズの第5回です。

## 前回のおさらい

[第4回](/2025/12/30/163824/)では、`open`を使ってファイルからタスクを読み込み、アプリ起動時に保存済みタスクを復元する機能を実装しました。これでタスクの永続化が完成しました。

## 今回のゴール

今回は、以下の2点を達成します。

- テキストファイルによるデータ管理の限界を理解する
- DBIを使ってSQLiteデータベースに接続し、タスクを保存するテーブルを作成する

## ファイル版の限界

これまで「1行1タスク」のテキストファイルでタスクを管理してきましたが、実用的なアプリケーションを作ろうとすると、いくつかの問題に直面します。

### タスクの検索が困難

特定のタスクを探すには、ファイル全体を読み込んで`grep`や正規表現で検索する必要があります。タスク数が増えると、この処理は非効率になります。

```perl
# ファイル全体を読み込んで検索する必要がある
my @found;
for my $task (@tasks) {
    push @found, $task if $task =~ /買い物/;
}
```

### タスクの更新が困難

1件のタスクを更新するだけでも、ファイル全体を読み込み、該当箇所を書き換え、再度ファイル全体を書き出す必要があります。

```perl
# 1件更新するだけなのに全件書き直し
$tasks[$index] = $new_task;
open my $fh, '>:encoding(UTF-8)', $file or die $!;
print $fh "$_\n" for @tasks;
close $fh;
```

### タスクの削除も同様に面倒

削除も更新と同じく、配列から要素を取り除いた後、ファイル全体を書き直す必要があります。

### 完了/未完了の状態管理が難しい

「1行1タスク」のシンプルな形式では、完了/未完了の状態を管理するのが困難です。たとえば`[x] 牛乳を買う`のような形式にすると、パース処理が複雑になります。

これらの問題を解決するために、データベースを導入します。

## なぜSQLiteなのか

データベースにはMySQL、PostgreSQL、SQLiteなどさまざまな選択肢がありますが、今回はSQLiteを採用します。

SQLiteを選ぶ理由は以下の通りです。

- **サーバー不要**: ファイルベースで動作し、別途サーバーを起動する必要がない
- **インストールが簡単**: CPANモジュールをインストールするだけで使える
- **学習コストが低い**: SQL構文は他のデータベースと共通
- **本番でも十分使える**: 中小規模のアプリケーションであれば十分な性能

## DBIとDBD::SQLiteのインストール

PerlからSQLiteを使うには、DBIとDBD::SQLiteという2つのモジュールが必要です。

- **DBI**: Perlのデータベースアクセスの標準インターフェース
- **DBD::SQLite**: SQLite用のデータベースドライバ

### cpanmでインストールする場合

```bash
cpanm DBI DBD::SQLite
```

### Carton（cpanfile）でインストールする場合

[cpanfile](/2025/12/10/000000/)を使っている場合は、以下のように記述します。

```perl
# cpanfile
requires 'DBI';
requires 'DBD::SQLite';
```

その後、`carton install`でインストールします。

```bash
carton install
```

## コード例1: DBIでSQLiteに接続する

まずはデータベースへの接続方法を学びましょう。

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use utf8;
use open ':std', ':encoding(UTF-8)';
use DBI;

# SQLiteデータベースに接続
my $dbh = DBI->connect(
    'dbi:SQLite:dbname=todo.db',  # データソース名（DSN）
    '',                            # ユーザー名（SQLiteでは不要）
    '',                            # パスワード（SQLiteでは不要）
    {
        RaiseError => 1,           # エラー時に例外を投げる
        AutoCommit => 1,           # 自動コミット
        sqlite_unicode => 1,       # UTF-8を有効にする
    }
) or die "データベース接続エラー: $DBI::errstr";

print "データベースに接続しました\n";

# 接続を閉じる
$dbh->disconnect;
print "接続を閉じました\n";
```

このコードのポイントは以下の通りです。

- `DBI->connect`でデータベースに接続し、データベースハンドル（`$dbh`）を取得する
- 第1引数はDSN（Data Source Name）で、`dbi:ドライバ名:接続情報`の形式
- `dbi:SQLite:dbname=todo.db`は「SQLiteドライバでtodo.dbファイルに接続」の意味
- `$dbh->disconnect`で接続を閉じる

### 接続オプションについて

`DBI->connect`の第4引数にはハッシュリファレンスで接続オプションを指定します。

| オプション | 意味 |
|:-----------|:-----|
| `RaiseError => 1` | エラー発生時に`die`で例外を投げる。これを設定しないと、エラーを見逃す可能性がある |
| `AutoCommit => 1` | 各SQL文の実行後に自動的にコミットする。トランザクション制御が不要な場合に便利 |
| `sqlite_unicode => 1` | SQLite固有のオプション。UTF-8文字列を正しく扱うために必要 |

`RaiseError => 1`を設定することで、SQLの実行エラーを確実に検出できます。設定しない場合、`or die`を毎回書く必要があります。

## コード例2: タスク用のテーブルを作成する

次に、タスクを保存するためのテーブルを作成します。

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use utf8;
use open ':std', ':encoding(UTF-8)';
use DBI;

my $dbh = DBI->connect(
    'dbi:SQLite:dbname=todo.db',
    '',
    '',
    {
        RaiseError     => 1,
        AutoCommit     => 1,
        sqlite_unicode => 1,
    }
) or die "データベース接続エラー: $DBI::errstr";

# タスクテーブルを作成
$dbh->do(q{
    CREATE TABLE IF NOT EXISTS tasks (
        id          INTEGER PRIMARY KEY AUTOINCREMENT,
        title       TEXT NOT NULL,
        completed   INTEGER DEFAULT 0,
        created_at  TEXT DEFAULT CURRENT_TIMESTAMP
    )
});

print "tasksテーブルを作成しました\n";

$dbh->disconnect;
```

このコードのポイントは以下の通りです。

- `$dbh->do`で任意のSQL文を実行する
- `CREATE TABLE IF NOT EXISTS`でテーブルが存在しない場合のみ作成する
- `INTEGER PRIMARY KEY AUTOINCREMENT`で自動採番のIDを設定する
- `completed`カラムで完了/未完了の状態を管理する（0:未完了、1:完了）

### テーブル設計の解説

| カラム名 | 型 | 説明 |
|:---------|:---|:-----|
| `id` | INTEGER | 自動採番の主キー |
| `title` | TEXT | タスクのタイトル（必須） |
| `completed` | INTEGER | 完了フラグ（0:未完了、1:完了） |
| `created_at` | TEXT | 作成日時（自動設定） |

ファイル版では難しかった「完了/未完了の状態管理」が、`completed`カラムで簡単に実現できます。

## ファイル版からデータベース版への移行メリット

データベースを導入することで、以下のメリットが得られます。

- **検索が高速**: `SELECT * FROM tasks WHERE title LIKE '%買い物%'`で瞬時に検索
- **更新が効率的**: `UPDATE tasks SET completed = 1 WHERE id = 1`で1件だけ更新
- **削除も簡単**: `DELETE FROM tasks WHERE id = 1`で1件だけ削除
- **状態管理が容易**: `completed`カラムで完了/未完了を管理
- **拡張性が高い**: カラムの追加や変更が容易

## 関連リンク

DBIやデータベースについて、詳しくは以下の記事も参考にしてください。

- [第1回: TODOリストアプリを作ろう - 完成イメージと設計](/2025/12/30/163821/)
- [第4回: ファイルからタスクを読み込む](/2025/12/30/163824/)
- [Perlでのデータベース操作 — DBI / DBIx::Class 入門](/2025/12/13/000000/)
- [PerlのCPANモジュール20選](/2025/12/03/041603/)
- [Carton/cpanfileによる依存管理](/2025/12/10/000000/)

## まとめ

- テキストファイルでのデータ管理は、検索・更新・削除が非効率である
- SQLiteはサーバー不要で手軽に使えるデータベースである
- DBIとDBD::SQLiteをインストールしてPerlからSQLiteを操作する
- `DBI->connect`でデータベースに接続し、`$dbh->do`でSQLを実行する
- `RaiseError => 1`でエラーを確実に検出し、`AutoCommit => 1`で自動コミットする

## 次回予告

次回は、タスクをデータベースに追加する方法（INSERT）を学びます。プレースホルダを使った安全なSQL実行についても解説します。お楽しみに！
