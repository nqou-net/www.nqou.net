---
title: 'PerlでTODOリスト（CLI）を作成する - 第2回: ユーザーからの入力を受け取る'
draft: true
tags:
  - perl
  - cli
  - user-input
description: PerlでCLIベースのTODOリストアプリを作る連載の第2回。<STDIN>を使ったユーザー入力の受け取り方、chompによる改行除去、入力バリデーションを学びます。
---

[@nqounet](https://x.com/nqounet)です。

「PerlでTODOリスト（CLI）を作成する」シリーズの第2回です。

## 前回のおさらい

[第1回](/2025/12/30/163821/)では、TODOリストアプリの完成形をデモし、`while`無限ループを使ったメニュー形式のCLI UIを設計しました。今回は、ユーザーからの入力を受け取る仕組みを詳しく見ていきます。

## 今回のゴール

今回は、以下の2点を達成します。

- `<STDIN>`を使ってユーザーからの入力を受け取る方法を理解する
- `chomp`と入力バリデーションで安全に入力を処理する

## `<STDIN>`とは

Perlでユーザーからの入力を受け取るには、`<STDIN>`を使います。`STDIN`は「Standard Input（標準入力）」の略で、通常はキーボードからの入力を指します。

`<STDIN>`を使うと、ユーザーがEnterキーを押すまでの入力を1行読み取ることができます。この時、入力の末尾には改行文字（`\n`）が含まれます。

## コード例1: メニュー表示と入力ループ

実際に対話型のメニューを実装してみましょう。

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use utf8;
use open ':std', ':encoding(UTF-8)';

print "=== TODO リスト メニュー ===\n\n";

while (1) {
    # メニューを表示
    print "----------------------\n";
    print "メニュー:\n";
    print "  a: タスク追加\n";
    print "  l: タスク一覧\n";
    print "  q: 終了\n";
    print "----------------------\n";
    print "選択してください > ";

    # ユーザーからの入力を受け取る
    my $input = <STDIN>;

    # 入力がない場合（Ctrl+D など）はループを抜ける
    if (!defined $input) {
        print "\n終了します。\n";
        last;
    }

    # 改行を除去
    chomp $input;

    # 入力に応じた処理を実行
    if ($input eq 'a') {
        print "\n→ タスク追加を選択しました\n\n";
    }
    elsif ($input eq 'l') {
        print "\n→ タスク一覧を選択しました\n\n";
    }
    elsif ($input eq 'q') {
        print "\n終了します。お疲れ様でした！\n";
        last;
    }
    else {
        print "\n→ 不明なコマンドです: '$input'\n\n";
    }
}
```

このコードのポイントは以下の通りです。

- `<STDIN>`でユーザーの入力を1行読み取る
- `defined`で入力の有無をチェックする（EOF対策）
- `chomp`で末尾の改行を除去する
- `if-elsif-else`で入力に応じた分岐処理を行う

### `defined`によるEOFチェック

`<STDIN>`は、ユーザーがCtrl+D（Unix系）やCtrl+Z（Windows）を押してEOF（End Of File）を送信すると、`undef`を返します。`defined`でチェックしないと、`undef`に対して`chomp`を実行しようとして警告が出ます。

## コード例2: chompと入力バリデーション

ユーザー入力は「何が入力されるか分からない」という前提で処理する必要があります。空白のみの入力や、想定外の文字列に対応するバリデーションを追加しましょう。

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use utf8;
use open ':std', ':encoding(UTF-8)';

print "タスク名を入力してください\n";
print "(空白のみ、または空の入力は無効です)\n\n";

while (1) {
    print "タスク名 > ";
    my $input = <STDIN>;

    # EOF チェック
    if (!defined $input) {
        print "\n入力がキャンセルされました。\n";
        last;
    }

    # 改行を除去
    chomp $input;

    # バリデーション: 空文字チェック
    if ($input eq '') {
        print "エラー: 何も入力されていません。\n\n";
        next;  # ループの先頭に戻る
    }

    # バリデーション: 空白のみチェック
    if ($input =~ /^\s+$/) {
        print "エラー: 空白のみの入力は無効です。\n\n";
        next;
    }

    # 前後の空白を除去（トリム）
    $input =~ s/^\s+//;
    $input =~ s/\s+$//;

    # 有効な入力を処理
    print "タスク「$input」を登録しました！\n";
    last;
}
```

このコードのポイントは以下の通りです。

- `chomp`で改行を除去してから処理を行う
- 空文字チェックは`eq ''`で行う
- 空白のみのチェックは正規表現`/^\s+$/`を使用する
- `next`でループの先頭に戻り、再入力を促す
- 正規表現の置換`s///`で前後の空白を除去（トリム）する

### `chomp`の役割

`chomp`は、文字列の末尾にある改行文字を1つだけ除去します。ユーザーがEnterキーを押すと、入力の末尾に`\n`が付くため、これを除去しないと比較が正しく動作しません。

```perl
my $input = <STDIN>;  # ユーザーが "hello" と入力してEnter
# この時点で $input は "hello\n"

chomp $input;
# この時点で $input は "hello"
```

`chomp`は破壊的に（元の変数を直接変更して）動作するため、戻り値を使う必要はありません。

## 関連リンク

入力処理に関連する技術について、詳しくは以下の記事も参考にしてください。

- [Perlでのコマンドライン引数処理 - Getopt::Long](/2025/12/21/000000/)
- [Perlでのデータベース操作 — DBI / DBIx::Class 入門](/2025/12/13/000000/)

## まとめ

- `<STDIN>`でユーザーからの入力を1行読み取ることができる
- `chomp`で入力末尾の改行を除去する必要がある
- `defined`でEOF（入力終了）をチェックすることで堅牢なコードになる
- 空文字・空白のみのチェックなど、バリデーションは必須である
- `next`でループの先頭に戻り、再入力を促すことができる

## 次回予告

次回は、配列を使ってタスクの追加と一覧表示を実装します。今回学んだ入力処理を活かして、実際にタスクを追加できるようにしていきましょう。お楽しみに！
