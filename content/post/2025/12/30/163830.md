---
title: 'PerlでTODOリスト（CLI）を作成する - 第10回（最終回）: コマンドライン引数でサクサク操作'
draft: true
tags:
  - perl
  - cli
  - getopt-long
description: PerlでCLIベースのTODOリストアプリを作る連載の最終回。Getopt::Longを使って、メニュー形式からサブコマンド形式（add/list/done/rm）に進化させます。連載全体のまとめと今後の発展についても触れます。
---

[@nqounet](https://x.com/nqounet)です。

「PerlでTODOリスト（CLI）を作成する」シリーズの第10回（最終回）です。

## 前回のおさらい

[第9回](/2025/12/30/163829/)では、DELETE文を使ってタスクを削除する機能を実装しました。削除前にユーザー確認を求めるベストプラクティスも学びました。

## 今回のゴール

今回は、以下の2点を達成します。

- `Getopt::Long`を使ってコマンドライン引数を処理する
- メニュー形式からサブコマンド形式（add/list/done/rm）に進化させる

## メニュー形式の限界

これまでのTODOリストアプリは、メニュー形式で対話的に操作していました。しかし、毎回メニューを選択するのは手間がかかります。

例えば、タスクを1つ追加するだけでも以下の操作が必要でした。

1. `perl todo.pl`でアプリを起動
2. メニューから`a`を選択
3. タスク名を入力
4. `q`で終了

サブコマンド形式なら、1行で完結します。

```bash
perl todo.pl add "牛乳を買う"
```

この形式は、`git add`や`docker run`のように、多くのCLIツールで採用されています。

## Getopt::Longとは

`Getopt::Long`は、Perlの標準モジュールで、コマンドライン引数を解析するためのモジュールです。CPANからインストールする必要はなく、Perlに付属しています。

主な機能は以下の通りです。

- 長いオプション名（`--help`）と短いオプション名（`-h`）の両方をサポート
- オプションに値を指定できる（`--id=3`）
- 必須オプションと任意オプションを区別できる
- ブール型、文字列型、整数型など、様々な型をサポート

詳しくは[Getopt::Longの記事](/2025/12/21/000000/)も参照してください。

## サブコマンドの設計

今回実装するサブコマンドは以下の4つです。

| サブコマンド | 説明 | 使用例 |
|:-------------|:-----|:-------|
| `add` | タスクを追加 | `perl todo.pl add "買い物に行く"` |
| `list` | タスク一覧を表示 | `perl todo.pl list` |
| `done` | タスクを完了にする | `perl todo.pl done --id=3` |
| `rm` | タスクを削除する | `perl todo.pl rm --id=3` |

サブコマンドは`@ARGV`の最初の要素として取得し、残りの引数を`Getopt::Long`で解析します。

## コード例1: Getopt::Longでサブコマンド処理

サブコマンドを解析して、それぞれの処理に振り分けるコードです。

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use utf8;
use open ':std', ':encoding(UTF-8)';
use Getopt::Long qw(:config no_ignore_case bundling);
use DBI;

# サブコマンドを取得（なければヘルプを表示）
my $subcommand = shift @ARGV // 'help';

# サブコマンドに応じて処理を振り分け
if ($subcommand eq 'add') {
    my $title = shift @ARGV;
    if (!defined $title || $title eq '') {
        die "使い方: perl todo.pl add \"タスク名\"\n";
    }
    cmd_add($title);
}
elsif ($subcommand eq 'list') {
    cmd_list();
}
elsif ($subcommand eq 'done') {
    my $id;
    GetOptions('id=i' => \$id) or die "オプション解析エラー\n";
    if (!defined $id) {
        die "使い方: perl todo.pl done --id=タスクID\n";
    }
    cmd_done($id);
}
elsif ($subcommand eq 'rm') {
    my $id;
    GetOptions('id=i' => \$id) or die "オプション解析エラー\n";
    if (!defined $id) {
        die "使い方: perl todo.pl rm --id=タスクID\n";
    }
    cmd_rm($id);
}
elsif ($subcommand eq 'help' || $subcommand eq '--help' || $subcommand eq '-h') {
    cmd_help();
}
else {
    print "不明なサブコマンド: $subcommand\n\n";
    cmd_help();
}

sub get_dbh {
    return DBI->connect(
        'dbi:SQLite:dbname=todo.db',
        '', '',
        { RaiseError => 1, AutoCommit => 1, sqlite_unicode => 1 }
    );
}

sub cmd_add {
    my ($title) = @_;
    my $dbh = get_dbh();
    my $sth = $dbh->prepare(q{
        INSERT INTO tasks (title, completed) VALUES (?, 0)
    });
    $sth->execute($title);
    print "タスク「$title」を追加しました\n";
    $dbh->disconnect;
}

sub cmd_list {
    my $dbh = get_dbh();
    my $sth = $dbh->prepare(q{
        SELECT id, title, completed FROM tasks ORDER BY id
    });
    $sth->execute();
    print "=== TODO リスト ===\n\n";
    while (my $row = $sth->fetchrow_hashref) {
        my $mark = $row->{completed} ? 'x' : ' ';
        printf "%d. [%s] %s\n", $row->{id}, $mark, $row->{title};
    }
    $dbh->disconnect;
}

sub cmd_done {
    my ($id) = @_;
    my $dbh = get_dbh();
    my $sth = $dbh->prepare(q{
        UPDATE tasks SET completed = 1 WHERE id = ?
    });
    my $rows = $sth->execute($id);
    if ($rows > 0) {
        print "タスク $id を完了にしました\n";
    } else {
        print "タスク $id は存在しません\n";
    }
    $dbh->disconnect;
}

sub cmd_rm {
    my ($id) = @_;
    my $dbh = get_dbh();
    my $sth = $dbh->prepare(q{
        DELETE FROM tasks WHERE id = ?
    });
    my $rows = $sth->execute($id);
    if ($rows > 0) {
        print "タスク $id を削除しました\n";
    } else {
        print "タスク $id は存在しません\n";
    }
    $dbh->disconnect;
}

sub cmd_help {
    print <<'HELP';
使い方: perl todo.pl <サブコマンド> [オプション]

サブコマンド:
  add "タスク名"   タスクを追加
  list             タスク一覧を表示
  done --id=N      タスクNを完了にする
  rm --id=N        タスクNを削除する
  help             このヘルプを表示
HELP
}
```

このコードのポイントは以下の通りです。

- `shift @ARGV`でサブコマンドを取得する
- `GetOptions`でオプション（`--id`）を解析する
- 各サブコマンドに対応するサブルーチンを呼び出す
- ヘルプメッセージにはヒアドキュメント（`<<'HELP'`）を使用する

## コード例2: 完成したtodo.plの全体像

連載を通じて作成したTODOリストアプリの完成形です。サブコマンド形式で操作でき、データはSQLiteに永続化されます。

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use utf8;
use open ':std', ':encoding(UTF-8)';
use Getopt::Long qw(:config no_ignore_case bundling);
use DBI;
use Try::Tiny;

my $DB_FILE = 'todo.db';

# データベース初期化
init_db();

# サブコマンドを取得
my $subcommand = shift @ARGV // 'help';

# サブコマンドに応じた処理
my %commands = (
    add  => \&cmd_add,
    list => \&cmd_list,
    done => \&cmd_done,
    rm   => \&cmd_rm,
    help => \&cmd_help,
);

if (exists $commands{$subcommand}) {
    try {
        $commands{$subcommand}->();
    } catch {
        print "エラー: $_\n";
    };
} else {
    print "不明なサブコマンド: $subcommand\n\n";
    cmd_help();
}

sub get_dbh {
    return DBI->connect(
        "dbi:SQLite:dbname=$DB_FILE",
        '', '',
        { RaiseError => 1, AutoCommit => 1, sqlite_unicode => 1 }
    );
}

sub init_db {
    my $dbh = get_dbh();
    $dbh->do(q{
        CREATE TABLE IF NOT EXISTS tasks (
            id        INTEGER PRIMARY KEY AUTOINCREMENT,
            title     TEXT NOT NULL,
            completed INTEGER DEFAULT 0
        )
    });
    $dbh->disconnect;
}

sub cmd_add {
    my $title = shift @ARGV;
    die "使い方: perl todo.pl add \"タスク名\"\n" unless defined $title && $title ne '';

    my $dbh = get_dbh();
    $dbh->prepare(q{ INSERT INTO tasks (title) VALUES (?) })->execute($title);
    print "タスク「$title」を追加しました\n";
    $dbh->disconnect;
}

sub cmd_list {
    my $dbh = get_dbh();
    my $sth = $dbh->prepare(q{ SELECT id, title, completed FROM tasks ORDER BY id });
    $sth->execute();

    print "=== TODO リスト ===\n\n";
    my $count = 0;
    while (my $row = $sth->fetchrow_hashref) {
        my $mark = $row->{completed} ? 'x' : ' ';
        printf "%d. [%s] %s\n", $row->{id}, $mark, $row->{title};
        $count++;
    }
    print "(タスクはありません)\n" if $count == 0;
    $dbh->disconnect;
}

sub cmd_done {
    my $id;
    GetOptions('id=i' => \$id) or die "オプション解析エラー\n";
    die "使い方: perl todo.pl done --id=タスクID\n" unless defined $id;

    my $dbh = get_dbh();
    my $rows = $dbh->prepare(q{ UPDATE tasks SET completed = 1 WHERE id = ? })->execute($id);
    print $rows > 0 ? "タスク $id を完了にしました\n" : "タスク $id は存在しません\n";
    $dbh->disconnect;
}

sub cmd_rm {
    my $id;
    GetOptions('id=i' => \$id) or die "オプション解析エラー\n";
    die "使い方: perl todo.pl rm --id=タスクID\n" unless defined $id;

    my $dbh = get_dbh();
    my $rows = $dbh->prepare(q{ DELETE FROM tasks WHERE id = ? })->execute($id);
    print $rows > 0 ? "タスク $id を削除しました\n" : "タスク $id は存在しません\n";
    $dbh->disconnect;
}

sub cmd_help {
    print <<'HELP';
TODO リスト CLI アプリ

使い方: perl todo.pl <サブコマンド> [オプション]

サブコマンド:
  add "タスク名"   タスクを追加する
  list             タスク一覧を表示する
  done --id=N      タスクNを完了にする
  rm --id=N        タスクNを削除する
  help             このヘルプを表示する

例:
  perl todo.pl add "牛乳を買う"
  perl todo.pl list
  perl todo.pl done --id=1
  perl todo.pl rm --id=2
HELP
}
```

このコードのポイントは以下の通りです。

- `%commands`ハッシュでサブコマンドとサブルーチンを対応付ける
- `Try::Tiny`でエラーハンドリングを行う
- `init_db`でテーブルが存在しない場合は自動作成する
- タスクがない場合のメッセージも表示する

## 連載全体のまとめ

全10回の連載を通じて、実用的なCLIアプリケーションを一から作り上げました。学んだ主要なトピックを振り返りましょう。

### CRUD操作

データベースの基本操作であるCRUD（Create, Read, Update, Delete）を実装しました。

- **Create（作成）**: INSERT文でタスクを追加
- **Read（読み取り）**: SELECT文でタスク一覧を取得
- **Update（更新）**: UPDATE文で完了フラグを更新
- **Delete（削除）**: DELETE文でタスクを削除

### 学んだ技術・概念

連載を通じて学んだ主な技術と概念は以下の通りです。

- `while`無限ループによるCLI UIの基本構造
- `<STDIN>`を使ったユーザー入力の処理
- 配列操作によるタスク管理
- ファイル入出力によるデータ永続化
- [cpanfile](/2025/12/10/000000/)による依存モジュール管理
- [DBI](/2025/12/13/000000/)を使ったSQLiteデータベース操作
- プレースホルダによるSQLインジェクション対策
- `execute`の戻り値による処理結果の確認
- 削除前のユーザー確認によるUX向上
- [Getopt::Long](/2025/12/21/000000/)によるコマンドライン引数処理
- サブコマンド形式への進化

### 連載で作成したファイル構成

最終的なプロジェクト構成は以下の通りです。

```text
todo-app/
├── cpanfile        # 依存モジュール定義
├── todo.db         # SQLiteデータベース（自動生成）
└── todo.pl         # メインスクリプト
```

## 今後の発展

このTODOリストアプリは、さらに機能を追加して発展させることができます。以下はアイデアの一例です。

- **期限機能**: タスクに期限を設定し、期限順でソート
- **優先度**: 高・中・低の優先度を設定
- **カテゴリ/タグ**: タスクをカテゴリ別に分類
- **検索機能**: タスク名でキーワード検索
- **完了済み非表示**: `list --active`で未完了のみ表示
- **Web UI**: Mojoliciousを使ってWeb版を作成
- **テストコード**: Test::Moreを使った自動テスト

Perlには、これらの機能を実現するためのモジュールがCPANに豊富に揃っています。ぜひ、自分なりのカスタマイズを加えて、より便利なアプリに育ててください。

## 関連リンク

連載で使用したモジュールや技術について、詳しくは以下の記事も参考にしてください。

- [第1回: TODOリストアプリを作ろう - 完成イメージと設計](/2025/12/30/163821/)
- [第9回: タスクを削除する（Delete）](/2025/12/30/163829/)
- [Perlでのコマンドライン引数処理 - Getopt::Long](/2025/12/21/000000/)
- [Perlでのデータベース操作 — DBI / DBIx::Class 入門](/2025/12/13/000000/)
- [Carton/cpanfileによる依存管理](/2025/12/10/000000/)

## まとめ

- `Getopt::Long`でコマンドライン引数を解析できる
- サブコマンド形式は`shift @ARGV`で取得し、`%commands`ハッシュで振り分ける
- メニュー形式からサブコマンド形式に進化させることで、より効率的に操作できる
- 連載を通じてCRUD操作、データベース、コマンドライン処理など実践的な技術を学んだ
- 今後は期限、優先度、Web UIなど様々な拡張が可能である

## おわりに

全10回の連載、お疲れ様でした！

シンプルなメニュー形式のアプリから始めて、最終的にはサブコマンド形式で操作できる実用的なCLIアプリが完成しました。この連載で学んだ知識は、他のCLIツールやWebアプリケーションの開発にも応用できます。

Perlの楽しさが少しでも伝わっていれば幸いです。Happy Hacking!
