---
title: 'PerlでTODOリスト（CLI）を作成する - 第4回: ファイルからタスクを読み込む'
draft: true
tags:
  - perl
  - file-io
  - read
description: PerlでCLIベースのTODOリストアプリを作る連載の第4回。openによるファイル読み込みとwhile (<$fh>)による行ごと処理を学びます。ファイルが存在しない場合のエラーハンドリングも解説します。
---

[@nqounet](https://x.com/nqounet)です。

「PerlでTODOリスト（CLI）を作成する」シリーズの第4回です。

## 前回のおさらい

[第3回](/2025/12/30/163823/)では、`open`を使ってタスクをテキストファイルに保存する方法を学びました。`print $fh`でファイルハンドルに出力し、UTF-8エンコーディングを指定して日本語を正しく保存できるようになりました。

## 今回のゴール

今回は、以下の2点を達成します。

- `open`の読み込みモードでファイルからタスクを読み込む方法を理解する
- アプリ起動時に保存済みタスクを復元して一覧表示する

## なぜファイル読み込みが必要なのか

前回、タスクをファイルに保存できるようになりました。しかし、アプリを再起動すると`@tasks`配列は空の状態からスタートします。せっかく保存したタスクを活用するには、起動時にファイルから読み込む必要があります。

今回実装する機能により、TODOリストアプリが「永続化」に対応します。

## コード例1: openでファイルを読み込む

ファイルから読み込むには、`open`関数を読み込みモード（`<`）で使います。

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use utf8;
use open ':std', ':encoding(UTF-8)';

my @tasks;
my $file = 'todo.txt';

# ファイルが存在するか確認
if (-e $file) {
    # ファイルを読み込みモードで開く
    open my $fh, '<:encoding(UTF-8)', $file
        or die "ファイルを開けません: $file ($!)";

    # 1行ずつ読み込む
    while (my $line = <$fh>) {
        chomp $line;           # 改行を除去
        push @tasks, $line;    # 配列に追加
    }

    close $fh;
    print "タスクを $file から読み込みました（", scalar(@tasks), "件）\n";
}
else {
    print "保存ファイルがありません。新規作成します。\n";
}

# 読み込んだタスクを表示
for my $i (0 .. $#tasks) {
    print $i + 1, ". $tasks[$i]\n";
}
```

このコードのポイントは以下の通りです。

- `open my $fh, '<:encoding(UTF-8)', $file`で読み込みモードでファイルを開く
- `<`は「読み込みモード」を意味する
- `while (my $line = <$fh>)`で1行ずつ読み込む
- `<$fh>`はファイルの終端に達すると`undef`を返し、ループが終了する
- `-e $file`でファイルの存在を確認してからopenする

### ファイルが存在しない場合の対処

ファイルが存在しない状態で`open`を読み込みモードで実行すると、エラーになります。これを避けるために、`-e`演算子でファイルの存在を確認してから開くのが安全です。

```perl
if (-e $file) {
    open my $fh, '<:encoding(UTF-8)', $file or die "...";
    # ファイル処理
}
else {
    # ファイルがない場合の処理（初回起動時など）
}
```

他にも`-r`（読み取り可能か）や`-f`（通常ファイルか）といったファイルテスト演算子があります。

## コード例2: TODOリストアプリに読み込み機能を組み込む

実際のTODOリストアプリに、起動時のタスク読み込み機能を組み込んでみましょう。

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use utf8;
use open ':std', ':encoding(UTF-8)';

my @tasks;
my $file = 'todo.txt';

# 起動時にファイルから読み込む
load_tasks();

# メインループ
while (1) {
    print "\n=== TODO リスト ===\n";
    show_tasks();
    print "メニュー: a:追加 s:保存 q:終了\n";
    print "選択 > ";

    my $input = <STDIN>;
    last unless defined $input;
    chomp $input;

    if ($input eq 'a') {
        print "タスク名 > ";
        my $task = <STDIN>;
        next unless defined $task;
        chomp $task;
        next if $task eq '';
        push @tasks, $task;
        print "「$task」を追加しました\n";
    }
    elsif ($input eq 's') {
        save_tasks();
    }
    elsif ($input eq 'q') {
        print "終了します\n";
        last;
    }
}

sub load_tasks {
    return unless -e $file;

    open my $fh, '<:encoding(UTF-8)', $file
        or do {
            print "警告: ファイルを読み込めません ($!)\n";
            return;
        };

    while (my $line = <$fh>) {
        chomp $line;
        next if $line eq '';    # 空行をスキップ
        push @tasks, $line;
    }

    close $fh;
    print "保存済みタスクを読み込みました（", scalar(@tasks), "件）\n";
}

sub show_tasks {
    if (@tasks == 0) {
        print "(タスクがありません)\n";
        return;
    }
    my $i = 1;
    for my $task (@tasks) {
        print "$i. $task\n";
        $i++;
    }
}

sub save_tasks {
    open my $fh, '>:encoding(UTF-8)', $file
        or do {
            print "エラー: ファイルを開けません ($!)\n";
            return;
        };

    for my $task (@tasks) {
        print $fh "$task\n";
    }

    close $fh;
    print "タスクを $file に保存しました\n";
}
```

このコードのポイントは以下の通りです。

- `load_tasks`サブルーチンで起動時の読み込み処理をカプセル化する
- `return unless -e $file`でファイルがなければ早期リターンする
- `next if $line eq ''`で空行をスキップして堅牢性を高める
- `or do { ... }`でエラー時に`die`せずに警告を出して処理を継続する

## UTF-8エンコーディングについて

前回の書き込みと同様に、読み込み時もUTF-8エンコーディングの指定が重要です。

### 読み込み時のエンコーディング指定

```perl
open my $fh, '<:encoding(UTF-8)', $file;
```

`:encoding(UTF-8)`を指定することで、ファイルから読み込んだバイト列が自動的にPerlの内部文字列にデコードされます。これにより、日本語のタスクが正しく処理されます。

### エンコーディングを指定しない場合の問題

エンコーディングを指定せずに読み込むと、日本語が文字化けしたり、文字列操作で予期しない結果になることがあります。日本語を扱うスクリプトでは、必ずエンコーディングを指定しましょう。

## while (<$fh>)の動作

`while (<$fh>)`はPerlでファイルを1行ずつ処理する定番のイディオムです。

```perl
while (my $line = <$fh>) {
    chomp $line;
    # $lineを処理
}
```

この構文の動作は以下の通りです。

- `<$fh>`は1行読み込んで返す（改行文字を含む）
- ファイルの終端に達すると`undef`を返す
- `while`の条件式で`undef`は偽と評価されるため、ループが終了する
- 読み込んだ行には改行が含まれるので`chomp`で除去する

### 注意: $_への暗黙の代入

`while (<$fh>)`と書くと、読み込んだ行は暗黙的に`$_`に代入されます。

```perl
while (<$fh>) {
    chomp;          # $_をchompする
    push @tasks, $_;
}
```

この書き方も動作しますが、明示的に変数を使う方が可読性が高くなります。

## 関連リンク

ファイル操作に関連する技術について、詳しくは以下の記事も参考にしてください。

- [第1回: TODOリストアプリを作ろう - 完成イメージと設計](/2025/12/30/163821/)
- [第2回: ユーザーからの入力を受け取る](/2025/12/30/163822/)
- [第3回: タスクをファイルに保存する](/2025/12/30/163823/)
- [PerlのCPANモジュール20選（Path::Tiny含む）](/2025/12/03/041603/)
- [Perlのエラー処理 - Try::Tiny](/2025/12/14/000000/)

## まとめ

- `open my $fh, '<:encoding(UTF-8)', $file`でファイルを読み込みモードで開く
- `while (my $line = <$fh>)`で1行ずつ読み込み処理する
- `-e $file`でファイルの存在を確認してからopenする
- `chomp`で読み込んだ行から改行を除去する
- UTF-8エンコーディングを指定することで日本語を正しく読み込める

## 次回予告

次回は、テキストファイルによるデータ管理の限界と、データベースへの移行について学びます。大量のタスクや複雑なデータ構造に対応するため、SQLiteを使ったデータ永続化に挑戦しましょう。お楽しみに！
