---
date: 2025-12-28T03:38:42+09:00
description: GitHub Copilot の Web・エディタ・CLI を徹底比較。プレミアムリクエスト 118/300（活用率 39%）の実測データから、各インターフェースの最適な使い分け戦略と生産性 2 倍化のロードマップを解説します。
draft: false
epoch: 1766860722
image: /public_images/2025/1766860722-image.jpg
iso8601: 2025-12-28T03:38:42+09:00
tags:
  - github-copilot
  - developer-productivity
  - ai-coding
  - premium-requests
  - copilot-interfaces
  - cli
  - web-development
title: GitHub Copilot 使い分けガイド｜118/300 リクエスト実測から学ぶ活用法
---

[@nqounet](https://x.com/nqounet)です。

GitHub Copilot の使い分けに悩んでいませんか？ Web UI・エディタ・CLI という 3 つのインターフェースがありますが、それぞれどう使い分ければ良いのでしょうか。

私は GitHub Copilot Pro を使用していますが、月間 300 のプレミアムリクエストのうち、わずか 118（39%）しか使えていないことに気づきました。しかし、使用状況を詳しく分析してみると、実は 3 つのインターフェースを**無意識に使い分けていた**ことが判明しました。

本記事では、実測データ 118 リクエストの詳細な内訳分析から、GitHub Copilot の Web UI・エディタ・CLI それぞれの最適な使い方、そして生産性を 2 倍にするための実践的なロードマップをお伝えします。

## GitHub Copilot の活用率 39% だった理由と改善策

### 月間 300 リクエストのうち 118（39%）しか使用していない現実

GitHub Copilot の課金ダッシュボードを確認すると、以下の状況でした。

- **月間プレミアムリクエスト**: 118/300（39% 活用）
- **残り日数**: 5 日で 182 リクエスト残
- **月初の目標**: プレミアムリクエストを使い切る

11 月は見事に 100% 使い切りました。しかし、12 月に入って少し冷静になり、「本当に使い切ることが目的なのか」と考え直しました。

### なぜ GitHub Copilot を使いこなせていなかったのか？

振り返ってみると、以下のような状況でした。

- Web UI、エディタ、CLI の特性を理解していなかった
- どのインターフェースが何に向いているかを知らなかった
- プレミアムリクエストの消費パターンを把握していなかった
- 無意識に「もったいない」と思って高度なモデルを避けていた

### 3 つのインターフェースの「無意識な使い分け」を意識化する

しかし、使用状況を詳しく分析すると、実は**直感的に使い分けていた**ことが分かりました。

- **Web UI**: リポジトリ全体の調査や情報整理に使用
- **エディタ**: 実装作業の中心として使用
- **CLI**: 最近導入したばかりで、まだ探り探りの状態

この無意識な使い分けを意識化し、最適化することで、さらに効率的に使えるのではないかと考えました。

## GitHub Copilot 3 つのインターフェースの特徴と使い分け

GitHub Copilot には、それぞれ異なる特性を持つ 3 つのインターフェースがあります。それぞれの核心的な価値と、向いているタスクを整理します。

### Web UI - リポジトリ全体を見渡す「戦略家」

Web UIは、GitHub.comから直接利用できるインターフェースです。

#### 核心価値: Space による永続的なナレッジ管理

Web UI の最大の強みは、**Space** という機能です。Space では以下が可能になります。

- チャット履歴の管理
- プロジェクトごとのコンテキスト保持
- チーム内でのナレッジ共有
- 過去の調査結果の再利用

Space のチャット履歴は**Conversations として残る**ため、後から検索して参照できます。通常の（Spaceではない）チャット履歴では、カラムの幅が変更できないので、タイトルが途中で切れてしまいます。改善が待たれるところですが、Spaceを使うことで回避できています。

他の機能については、ほぼ未使用なのでこれから色々と試していきたいです。

#### 強み: Issue アサインによる自動修正

Web UI では、Issue に Copilot をアサインすることで、自動的にコード修正を行えます。この機能は非常に強力です。

{{< linkcard "https://www.nqou.net/2025/11/29/094241/" >}}

実際に使ってみた体験記事では、その威力と注意点を詳しく解説しています。

- GitHub Actions を使った安全なサンドボックス環境で実行
- 新しいブランチとドラフト PR が自動作成
- マージは必ず人間が行うため、安全性が担保

#### 向いているタスク

Web UIが最も力を発揮するのは、以下のようなタスクです。

- リポジトリ横断的な調査
- チームでの協業とコードレビュー
- 技術調査とドキュメント作成
- Issue の自動修正（単純な修正タスク）

#### 落とし穴

Web UIを使う上で注意すべき点があります。

- **Issue アサインの過信**: 生成されたコードは必ずレビューが必要
- **プレミアムリクエストの大量消費**: 複雑な質問は一度に多くのリクエストを消費
- **ネットワーク依存**: オフラインでは使用不可

#### 私の使い方

私は主に以下の用途で Web UI を使用しています。

- **チャットで調べ物**: 無料モデル（GPT-5 mini）をよく使用
- **Issue アサイン**: プレミアムリクエストを消費するが、効率的
- **Space 内でチャット**: Conversations として履歴が残るのが便利
- **ウェブが最も扱いやすく洗練されている**と感じています

### エディタ拡張 - コーディングの「相棒」

エディタ拡張（VS Code や JetBrains など）は、開発環境に統合されたインターフェースです。

#### 核心価値: リアルタイムのインライン提案（プレミアムリクエスト消費なし）

エディタ拡張の最大の価値は、**インライン提案**です。これは以下の特徴があります。

- コーディング中にリアルタイムで提案
- タブキーで受け入れるだけで使用可能
- **プレミアムリクエストを消費しない**（無制限に使用可能）

#### モデルの指定
エディタ拡張でもモデルが指定可能です。使用するエディタにもよると思いますが、VSCodeでは利用時のプレミアムリクエストの消費倍率が表示されます。2025-12-28時点では、`Claude Opus 4.5`は3倍、`GPT-5 mini`は0倍です。

基本的には倍率が高い方が高性能と考えて良いとは思いますが、依頼の内容によってモデルを頻繁に変えるような使い方はしていないのでわかりません。というか、私はほぼ`GPT-5 mini`固定です。

#### 強み: AgentモードとPlanモードの使い分け

エディタには複数のモードがあり、タスクによって使い分けることができます。

どのように使い分けをしているかを言語化するのは難しいのですが、Agentモードでたくさん失敗すると、どのくらいまでならAgentでも問題なさそうかがわかってきます。これって個人差が多いと思います。私はあまりちゃんとしたプロンプトは書けないのでこんな感じですが。

**Agent モード**
複数ステップのタスクを自律的に実行するモードです。ファイルの読み取り、編集、作成を一括で実行可能です。

指示が少なくて済みそうなタスクを任せる感じです。関数を1つ作成する、とか。

エラーの修正とかは、短い指示でも頑張って実行してくれます。ただし、想像できないような修正をされる場合があるので注意が必要です。

**Plan モード**
とりあえず、何をしたいか、から始めるときはこのモードです。インタラクティブな対話で計画を立てることができます。計画が確定した後、Agent モードに変更して「実装して」と言えば、ほぼ計画した通りに実装してくれます。

指示内容が多くなりそうなタスクはこっちでやる方が安心です。例えば新しいクラスを作成する、とか。AIは、私の暗黙知については知らないので、指示内容が言葉足らずだと、色々と補完されてしまって全然違うものができてしまうことがあります。

完璧を求めるのならば、常に Plan モードからスタートしても良いとは思います。

**Ask モード**
以前は使っていました（クラス名や変数名をよく考えてもらいました）が、最近はほぼ使わなくなりました。調べ物は Web UI でやるようになったので。

**Edit モード**
元々あまり使っていなかったので、なんとも言えません。Edit モードでできそうなことも Agent モードでやってしまいます。

**カスタムエージェントモード**
カスタムエージェントを定義済みの場合、カスタムエージェントを指定してタスクを実行させることができます。

AGENTS.md にワークフローを書くことで連携させるようにするだけでなく、例えば、調査用のエージェントを指定して直接指示できます。

GitHub 公式の awesome-copilot を活用すれば、プロジェクト特有のコーディング規約や技術スタックに最適化されたエージェントを作成できます。

{{< linkcard "https://www.nqou.net/2025/12/06/212332/" >}}

`.github/agents/`ディレクトリにカスタムエージェントを定義することで、プロジェクト固有の知識を持たせることができます。効果的なエージェントを作成するには、アサイン時の指示が非常に重要です。

{{< linkcard "https://www.nqou.net/2025/12/08/003413/" >}}

#### 向いているタスク

エディタ拡張が最も力を発揮するのは、以下のようなタスクです。

- 実装作業全般（新機能開発、バグ修正）
- リファクタリング（小規模から大規模まで）
- テストコード作成
- コードレビューと改善提案

#### 落とし穴

エディタ拡張を使う上で注意すべき点があります。

- **Agent モードのプレミアムリクエスト無意識消費**: 使用するモデル次第ですが、複雑なタスクでは 10-20 リクエストを消費する場合あり
- **過度な期待**: 完璧なコードが生成されるわけではない
- **ワークスペース外の理解不足**: リポジトリ全体のコンテキストは Web UI に劣る

#### 私の使い方

私のエディタの使い方は以下の通りです。

- モデルはほぼ`GPT-5 mini`
- ほぼ Agent モード: Edit モードでも結局 Agent の方が上手く動く
- Ask モードは使わなくなった: 調べ物は Web へ移行
- 短文のプロンプト: プロンプトは使い捨て感覚でサクサク依頼
- 少し大きめのタスク: Plan モードで短文ラリー

### CLI - ターミナルの「執事」

GitHub Copilot CLIは、ターミナルから直接Copilotを利用できるインターフェースです。

CLIも種類がいくつかありそうですが、私は Homebrew で入れています。

#### 核心価値: 簡潔なレスポンスによる高速サイクル

CLIの最大の特徴は、**レスポンスが短く簡潔**であることです。

インターフェースとしては最も軽量なので、パッと使いたい時のために常にインタラクティブモードで開いておきたいところなのですが、レスポンスがチャットとは違うので、私にはインタラクティブモードは合わなさそうな印象です。

相応しい使い方を探っているところですが、コマンドに直接プロンプトを渡す使い方が使いやすそうな気はしています。

```
# Execute a prompt in non-interactive mode (exits after completion)
$ copilot -p "Fix the bug in main.js" --allow-all-tools
```

私の場合は、差分はエディタで見る、って感じになりそうですが、コマンドの履歴が残るので、繰り返すタスクはCLIで実行するのが良さそうな気がします。

例えば、ドキュメントの更新のように、定型文を使うようなものです。

#### 今後どう使うか

最近のアップデート（2025-12-10 v0.0.368）でプレミアムリクエスト表示が修正されて安心して使えるようになりました。

コマンドの履歴が残るので、（私にとっては）再利用がしやすいので、何らかの定型処理を依頼するような使い方をしてみようかなと。

## GitHub Copilot のプレミアムリクエスト基礎知識 - 賢く使うための前提

効率的に使うためには、プレミアムリクエストの仕組みを理解することが重要です。

### プレミアムリクエストとは

プレミアムリクエストは、高度な AI モデルを使用する際に消費される単位です。

- **月間 300 リクエスト** = 1 日平均 10 リクエスト（月額 $10）
- **リセットタイミング**: 毎月 1 日 UTC 00:00:00
- **対象プラン**: Copilot Pro および Business（Enterprise は 1,000 以上）

{{< linkcard "https://docs.github.com/en/billing/concepts/product-billing/github-copilot-premium-requests" >}}

### 使用状況のモニタリング習慣

定期的に使用状況を確認し、振り返ることが重要です。

#### 週 1 回: VS Code ステータスバーで確認

VS Code のステータスバーには、Copilot のアイコンがあり、そこから以下が確認できます。

- プレミアムリクエスト使用状況
- 月間制限までの進捗
- リセット日

#### 月 1 回: GitHub 課金ダッシュボードで振り返り

{{< linkcard "https://github.com/settings/billing" >}}

GitHub 課金ダッシュボードでは、以下が確認できます。

- 総使用量
- ユーザー/モデル/組織別のフィルタリング
- 含まれる/課金されるリクエストの内訳

#### 四半期: CSV レポートで傾向分析

CSV レポートをダウンロードして、以下を分析できます。

- タイムスタンプ別の使用傾向
- モデル別の消費パターン
- インタラクション別の分析

### モデルとプラン（2025年12月時点の概観）

- GitHub Copilot は複数の LLM を切り替えて利用するマルチモデル構成を採用しており、用途に応じて自動で最適モデルを選ぶ `Auto model selection` と、手動で選べる `Model picker` を提供しています
- プラン（Free / Pro / Pro+ / Enterprise）により利用可能なモデル群や「プレミアムリクエスト」の割当が異なります。Pro には一部高精度モデルがプレミアム枠で提供され、Pro+/Enterprise はより多くの枠や組織向けメトリクスを持ちます
- 代表的なモデル例（公式発表の抜粋）: `GPT-5.2`, `GPT-5.1`, `GPT-5 mini`, `Gemini 3 Flash`, `Gemini 3 Pro`, `Claude Opus 4.5`。地域・プラン・プレビュー状態で利用可否が変わります
- コスト最適化のため、重要な推論やデバッグには高精度モデル、反復的な編集には低レイテンシ/低コストモデルを使い分けるのが有効です

> 注意: モデルの名称・課金ルール・消費倍率（マルチプライヤー）は随時更新されます。記事を参照する際は、必ず GitHub のプラン・課金ページおよび changelog を最新確認してください


## シーン別 GitHub Copilot インターフェース選択ガイド - 迷わず選ぶ決定木

どのインターフェースを使うべきか迷ったときの指針を示します。

### コードレビューとPR作業 → Web UI

**なぜ Web UI が最適か**
- リポジトリ全体のコンテキストが必要
- PR の差分を見ながらレビュー可能
- Space で過去のレビューを参照可能

**具体的な使い方**
1. PR 画面で Copilot Chat を開く
2. 「この PR の変更内容を要約して」と依頼
3. 「潜在的な問題点を指摘して」と依頼
4. レビューコメントを下書き

### 新機能の設計と実装 → エディタ（Agent モード）

**なぜエディタが最適か**
- 複数ファイルの変更が必要
- リアルタイムでコードを確認しながら進行可能
- インライン提案（プレミアムリクエスト0消費）も活用可能

**具体的な使い方**
1. Plan モードで設計を固める
   - 「〇〇機能を実装したい。どのような手順で進めるべきか？」
   - 提案された計画をレビュー
2. Agent モードで実装
   - 短文プロンプトで段階的に進める
   - 各ステップで動作確認
3. インライン提案で細部を調整

### バグ修正 → エディタ + Web UI の併用

**なぜ併用が最適か**
- エディタ: 原因特定とデバッグ
- Web UI: 関連 Issue や過去の修正履歴の調査

**具体的な使い方**
1. エディタでエラーログを分析
   - Copilot Chat で「このエラーの原因は？」
2. Web UI でリポジトリ全体を検索
   - 「過去に同様のエラーはあったか？」
   - 関連する Issue や PR を確認
3. エディタで修正を実装
4. Web UI でレビューとドキュメント更新

### ドキュメント作成 → Web UI

**なぜ Web UI が最適か**
- Space でドキュメントテンプレートを管理可能
- チームでの共有が容易
- マークダウンのプレビューが見やすい

**具体的な使い方**
1. Space に「ドキュメントテンプレート」を作成
2. 「〇〇についてのドキュメントを作成して」と依頼
3. 生成されたドキュメントをレビュー
4. リポジトリにコミット

### スクリプトと自動化 → CLI + エディタ

**なぜCLI + エディタが最適か**
- CLI: 基本構造を素早く生成
- エディタ: 詳細を実装し、テスト

**具体的な使い方**
1. CLI でスクリプトの骨格を生成
   ```bash
   gh copilot suggest "GitHub の Issue を一括クローズするスクリプト"
   ```
2. 生成されたコマンドをファイルに保存
3. エディタで詳細を実装
   - エラーハンドリング追加
   - ロギング追加
   - テスト追加

## GitHub Copilot で生産性を 2 倍にする 3 つの実践テクニック

118 リクエストの分析から見えてきた、効率的な使い方のテクニックを紹介します。

### テクニック 1: 「一発必中」プロンプトの作り方

曖昧な指示では、何度も往復することになり、プレミアムリクエストを無駄に消費します。

#### Before（悪い例）

```
このコードをリファクタリングして
```

**問題点**
- 何を改善したいのか不明確
- どのスタイルで書き直すのか分からない
- 何度も往復してしまう

#### After（良い例）

```
このコードを以下の方針でリファクタリングしてください：

1. 関数型プログラミングスタイルに変更
2. 副作用を除去し、純粋関数として実装
3. TypeScriptの型安全性を最大限活用
4. エラーハンドリングを追加（Result型を使用）
5. 各関数に簡潔なJSDocコメントを追加
```

**改善点**
- 具体的な要件が明確
- スタイルや方針が指定されている
- 一度で求める結果が得られる可能性が高い

#### AGENTS.md の活用例

プロジェクト固有のコンテキストを `AGENTS.md` や `.github/copilot-instructions.md` に記載しておくことで、毎回説明する手間が省けます。

```markdown
# Copilot Instructions

## コーディング規約
- TypeScript を使用
- 関数型プログラミングスタイルを優先
- エラーハンドリングは Result 型を使用
- テストは Jest を使用

## アーキテクチャ
- クリーンアーキテクチャを採用
- ドメイン層、ユースケース層、インフラ層に分離
- DI コンテナは tsyringe を使用
```

### テクニック 2: Space を「第二の脳」にする

Space は単なるチャット履歴ではなく、**ナレッジベース**として活用できます。

#### 技術調査結果を Space に蓄積

- 新しい技術を学んだら、Space に要約を残す
- 公式ドキュメントの重要部分を抽出
- ベストプラクティスを記録

#### プロジェクトごとに Space を作成

- プロジェクト A 用の Space
- プロジェクト B 用の Space
- 学習用の Space

#### 過去の成功パターンを再利用

同じような質問を何度もしないように、Space に記録しておきます。

例：
- 「〇〇のエラーが出たときの対処法」
- 「△△を実装するときのベストプラクティス」
- 「□□のテストの書き方」

これにより、プレミアムリクエストを節約しつつ、効率的に開発できます。

### テクニック 3: インライン提案を最大活用（プレミアムリクエスト 0 消費）

エディタのインライン提案は、**プレミアムリクエストを消費しない**ため、積極的に活用すべきです。

#### インライン提案の特徴

- コーディング中にリアルタイムで提案
- タブキーで受け入れるだけ
- 関数全体や複数行のコードを提案可能
- **無制限に使用可能**

#### Agent モードに頼りすぎない

複雑なタスクは Agent モードが便利ですが、プレミアムリクエストを消費します。

- **簡単なタスク**: インライン提案で十分
- **中程度のタスク**: Agent モードで短文プロンプト
- **複雑なタスク**: Plan モードで計画を立ててから Agent モード

#### 具体的な活用シーン

```typescript
// 関数名を書くだけで、実装を提案してくれる
function calculateTotalPrice(

// ここでタブキーを押すと、以下のような提案が表示される
// items: Item[], taxRate: number): number {
//   const subtotal = items.reduce((sum, item) => sum + item.price, 0);
//   return subtotal * (1 + taxRate);
// }
```

このように、**Agent モードを使わずに**コードが書けるため、プレミアムリクエストを節約できます。

## よくある質問（FAQ）

### Q1. GitHub Copilot のプレミアムリクエストは使い切るべきですか？

いいえ、使い切ることが目的ではありません。重要なのは「成果の最大化」です。月間 300 リクエストのうち 118（39%）でも、十分な価値を得られていれば問題ありません。ROI（投資対効果）を意識して、本当に必要なタスクにリクエストを使いましょう。

### Q2. Web UI・エディタ・CLI はどう使い分ければ良いですか？

基本的な使い分けは以下の通りです。

- **Web UI**: リポジトリ全体の調査、コードレビュー、ドキュメント作成、Issue の自動修正
- **エディタ**: 実装作業全般、リファクタリング、テストコード作成
- **CLI**: コマンド生成、スクリプト作成、DevOps 作業

詳細は本記事の「シーン別 GitHub Copilot インターフェース選択ガイド」をご覧ください。

### Q3. プレミアムリクエストを節約するコツはありますか？

はい、以下の方法が効果的です。

1. **エディタのインライン提案を活用**: プレミアムリクエストを消費しません
2. **GPT-5 mini を優先的に使用**: マルチプライヤー 0×（実質無制限）
3. **一発必中プロンプトを心がける**: 明確で具体的な指示で往復を減らす
4. **Space で過去の成功パターンを再利用**: 同じ質問を繰り返さない

### Q4. GitHub Copilot の活用率が低い場合、どう改善すればいいですか？

まずは使用状況をモニタリングすることから始めましょう。

1. VS Code ステータスバーで定期的に確認
2. GitHub 課金ダッシュボードで月次振り返り
3. 3 つのインターフェースを意識的に使い分ける実験
4. Space でナレッジベースを構築

本記事の「まとめ - GitHub Copilot 活用の次の 30 日で実践すること」で詳しいロードマップを紹介しています。

## まとめ - GitHub Copilot 活用の次の 30 日で実践すること

118 リクエストの分析と、3 つのインターフェースの特性を理解したことで、今後の使い方が明確になりました。

### Week 1: 現在の使用状況をモニタリング

まずは自分の使い方を把握することから始めます。

- VS Code ステータスバーで毎日確認
- どのインターフェースを何に使っているか記録
- プレミアムリクエストの消費パターンを分析

### Week 2: 3 つのインターフェースを意識的に使い分ける実験

意識的に使い分けを試してみます。

- 調査は Web UI（Space に記録）
- 実装はエディタ（インライン提案を優先）
- スクリプト生成は CLI
- 各インターフェースの効果を記録

### Week 3: Space でナレッジベース構築を開始

Space を「第二の脳」として育てます。

- プロジェクトごとに Space を作成
- 技術調査結果を蓄積
- 過去の成功パターンをテンプレート化
- チーム内で共有

### Week 4: 振り返りと自分なりのパターン確立

1 ヶ月の実験を振り返り、最適化します。

- 使用状況を分析（CSV レポートダウンロード）
- 効果的だったパターンを文書化
- 改善点を洗い出す
- 次月の目標を設定

### 参考リンク

**公式ドキュメント**

{{< linkcard "https://docs.github.com/en/copilot/get-started/features" >}}

{{< linkcard "https://docs.github.com/en/billing/concepts/product-billing/github-copilot-premium-requests" >}}

{{< linkcard "https://docs.github.com/en/copilot/how-tos/use-copilot-agents/use-copilot-cli" >}}

{{< linkcard "https://docs.github.com/en/copilot/get-started/best-practices" >}}

**関連記事**

{{< linkcard "https://www.nqou.net/2025/11/29/094241/" >}}

{{< linkcard "https://www.nqou.net/2025/12/06/212332/" >}}

**GitHub公式ブログ**

{{< linkcard "https://github.blog/ai-and-ml/github-copilot/" >}}

---

GitHub Copilot の 3 つのインターフェース（Web UI・エディタ・CLI）は、それぞれ異なる強みを持っています。**「選択」ではなく「組み合わせ」**が重要です。

プレミアムリクエストは「節約」ではなく「最適化」を意識し、次の 30 日で自分なりの使い分けパターンを見つけていきましょう。

### 次のステップ

この記事を読んだあなたは、今すぐ以下のアクションを実践してみてください。

1. **VS Code のステータスバーで現在の使用状況を確認**する
2. **GitHub 課金ダッシュボードで過去の使用パターンを分析**する
3. **Space を 1 つ作成して、技術調査結果を蓄積**してみる
4. **エディタのインライン提案を意識的に活用**してみる

小さな一歩から始めることで、GitHub Copilot の真の価値を引き出せるはずです。

最後まで読んでいただき、ありがとうございました。
