---
title: "バッチ処理応用 - トランザクション的な処理"
description: "バッチ処理を使った疑似トランザクション処理を実装し、複数の関連する操作を一括実行、エラー時の対応も学びます。"
tags:
  - json-rpc
  - perl
  - batch-processing
  - transaction
  - error-recovery
draft: true
---

[@nqounet](https://x.com/nqounet)です。

前回の記事では、JSON-RPC 2.0のバッチ処理の基本を学び、複数のリクエストをまとめて送信することで通信を効率化できることがわかりました。

今回は、バッチ処理のさらに実践的な応用として、「疑似トランザクション処理」を実装します。データベースのトランザクションのように、複数の関連する操作を一括実行し、途中でエラーが発生した場合の対応方法も学んでいきます。

ユーザー登録、プロフィール設定、初期データ投入を一括で行う実例を通じて、エラーハンドリングやロールバック的な処理の設計を体験しましょう。

## トランザクション的な処理とは

データベースにおけるトランザクションは、複数の操作をひとまとまりの単位として扱い、すべて成功するか、すべて失敗するかの「原子性（Atomicity）」を保証する機能です。

JSON-RPC 2.0のバッチ処理は、真のトランザクションではありません。仕様上、バッチ内の各リクエストは独立して処理され、一部が失敗しても他は成功する可能性があります。

しかし、適切な設計とエラーハンドリングを行うことで、以下のような「疑似トランザクション的な処理」を実現できます：

- **依存関係のある操作の順序制御**: 先行する操作の結果を後続の操作に渡す
- **エラー時の補償処理**: 失敗した場合に、成功した操作を取り消す処理を実行
- **部分的な成功の検出**: どこまで成功したかを把握し、適切に対応する

## ユースケース: ユーザー登録フロー

今回実装するのは、以下のような新規ユーザー登録フローです：

1. **ユーザーアカウントを作成** (`createUser`)
2. **プロフィール情報を設定** (`setProfile`)
3. **初期データを投入** (`initializeUserData`)
4. **ウェルカムメール送信を通知** (`sendWelcomeEmail` - 通知)

これらの操作は密接に関連しており、途中で失敗した場合は適切な対応が必要です。

## サーバー側の実装

まず、これらの操作を処理するサーバーを実装します。`transaction_server.pl`を作成：

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use JSON::RPC::Spec;

# JSON-RPCサーバーのインスタンスを作成
my $rpc = JSON::RPC::Spec->new;

# データストア（本来はデータベースだが、今回はメモリ上に保持）
my %users;
my %profiles;
my %user_data;
my $user_id_counter = 1000;

# ユーザー作成メソッド
$rpc->register(
    createUser => sub {
        my ($params) = @_;
        
        unless (ref $params eq 'HASH') {
            die "Parameters must be a hash";
        }
        
        my $username = $params->{username} or die "username is required";
        my $email = $params->{email} or die "email is required";
        
        # ユーザー名の重複チェック
        for my $id (keys %users) {
            if ($users{$id}{username} eq $username) {
                die "Username '$username' already exists";
            }
        }
        
        # メールアドレスの重複チェック
        for my $id (keys %users) {
            if ($users{$id}{email} eq $email) {
                die "Email '$email' already exists";
            }
        }
        
        # 新規ユーザーを作成
        my $user_id = $user_id_counter++;
        $users{$user_id} = {
            id       => $user_id,
            username => $username,
            email    => $email,
            created_at => time(),
        };
        
        warn "[INFO] User created: ID=$user_id, username=$username\n";
        
        return {
            user_id => $user_id,
            username => $username,
            email => $email,
        };
    }
);

# プロフィール設定メソッド
$rpc->register(
    setProfile => sub {
        my ($params) = @_;
        
        unless (ref $params eq 'HASH') {
            die "Parameters must be a hash";
        }
        
        my $user_id = $params->{user_id} or die "user_id is required";
        
        # ユーザーの存在確認
        unless (exists $users{$user_id}) {
            die "User with ID $user_id does not exist";
        }
        
        # プロフィール情報を保存
        $profiles{$user_id} = {
            user_id     => $user_id,
            display_name => $params->{display_name} // $users{$user_id}{username},
            bio         => $params->{bio} // '',
            avatar_url  => $params->{avatar_url} // '',
            updated_at  => time(),
        };
        
        warn "[INFO] Profile set for user ID=$user_id\n";
        
        return {
            user_id => $user_id,
            profile => $profiles{$user_id},
        };
    }
);

# 初期データ投入メソッド
$rpc->register(
    initializeUserData => sub {
        my ($params) = @_;
        
        unless (ref $params eq 'HASH') {
            die "Parameters must be a hash";
        }
        
        my $user_id = $params->{user_id} or die "user_id is required";
        
        # ユーザーの存在確認
        unless (exists $users{$user_id}) {
            die "User with ID $user_id does not exist";
        }
        
        # 初期データを設定
        $user_data{$user_id} = {
            preferences => {
                language => $params->{language} // 'en',
                timezone => $params->{timezone} // 'UTC',
                theme    => $params->{theme} // 'light',
            },
            stats => {
                login_count => 0,
                last_login  => undef,
            },
            created_at => time(),
        };
        
        warn "[INFO] User data initialized for user ID=$user_id\n";
        
        return {
            user_id => $user_id,
            data => $user_data{$user_id},
        };
    }
);

# ウェルカムメール送信メソッド（通知用）
$rpc->register(
    sendWelcomeEmail => sub {
        my ($params) = @_;
        
        my $user_id = ref $params eq 'HASH' ? $params->{user_id} : $params->[0];
        
        unless (exists $users{$user_id}) {
            warn "[WARN] Cannot send welcome email: User ID=$user_id does not exist\n";
            return;
        }
        
        my $email = $users{$user_id}{email};
        my $username = $users{$user_id}{username};
        
        # 実際のメール送信処理（今回はログ出力のみ）
        warn "[EMAIL] Sending welcome email to $email (username: $username)\n";
        warn "[EMAIL] Subject: Welcome to our service!\n";
        warn "[EMAIL] Body: Hi $username, welcome aboard!\n";
        
        return;
    }
);

# ユーザー削除メソッド（ロールバック用）
$rpc->register(
    deleteUser => sub {
        my ($params) = @_;
        
        unless (ref $params eq 'HASH') {
            die "Parameters must be a hash";
        }
        
        my $user_id = $params->{user_id} or die "user_id is required";
        
        # ユーザーの存在確認
        unless (exists $users{$user_id}) {
            die "User with ID $user_id does not exist";
        }
        
        # 関連データを削除
        my $deleted = {
            user => delete $users{$user_id},
            profile => delete $profiles{$user_id},
            data => delete $user_data{$user_id},
        };
        
        warn "[INFO] User deleted: ID=$user_id (rollback operation)\n";
        
        return {
            user_id => $user_id,
            deleted => $deleted,
        };
    }
);

# 全ユーザー取得メソッド（デバッグ用）
$rpc->register(
    getAllUsers => sub {
        return {
            users => \%users,
            profiles => \%profiles,
            user_data => \%user_data,
        };
    }
);

# PSGIアプリケーションとして実行
my $app = sub {
    my ($env) = @_;
    return $rpc->handle($env);
};
```

### コードの解説

このサーバーは以下の特徴を持っています：

1. **メモリ上のデータストア**
   - `%users`: ユーザーアカウント情報
   - `%profiles`: プロフィール情報
   - `%user_data`: ユーザー設定や統計情報

2. **重複チェック**
   - ユーザー名とメールアドレスの重複を検証
   - エラー発生時は例外を投げる

3. **依存関係の検証**
   - プロフィール設定や初期データ投入時にユーザーの存在を確認
   - 存在しない場合はエラーを返す

4. **ロールバック用メソッド**
   - `deleteUser`でユーザーと関連データを削除
   - エラー時の補償処理に使用

## クライアント側の実装（成功パターン）

まず、すべてが正常に動作する場合のクライアントを実装します。`transaction_client_success.pl`を作成：

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use JSON::RPC::Spec::Client;
use Data::Dumper;

# クライアントのインスタンスを作成
my $client = JSON::RPC::Spec::Client->new(
    url => 'http://localhost:5000/'
);

print "=== トランザクション的な処理デモ（成功パターン） ===\n\n";

# ユーザー登録に必要な情報
my $username = 'alice_' . time();  # 重複を避けるためタイムスタンプを付加
my $email = $username . '@example.com';

# バッチリクエストを準備
# 注: 依存関係があるため、user_idを事前に決めることはできない
# そのため、2段階のアプローチを取る

print "Step 1: ユーザーを作成中...\n";

# まずユーザーを作成
my $create_result = $client->call('createUser', {
    username => $username,
    email => $email,
});

if (!$create_result->is_success) {
    die "Failed to create user: " . $create_result->error->{message} . "\n";
}

my $user_id = $create_result->result->{user_id};
print "  ✓ ユーザー作成成功: ID=$user_id, username=$username\n\n";

# 作成したuser_idを使って、残りの操作をバッチで実行
print "Step 2: プロフィール設定と初期データ投入をバッチ実行中...\n";

my @batch_requests = (
    {
        jsonrpc => '2.0',
        method  => 'setProfile',
        params  => {
            user_id => $user_id,
            display_name => 'Alice in Wonderland',
            bio => 'I love JSON-RPC and Perl!',
            avatar_url => 'https://example.com/avatars/alice.jpg',
        },
        id => 1,
    },
    {
        jsonrpc => '2.0',
        method  => 'initializeUserData',
        params  => {
            user_id => $user_id,
            language => 'ja',
            timezone => 'Asia/Tokyo',
            theme => 'dark',
        },
        id => 2,
    },
    {
        jsonrpc => '2.0',
        method  => 'sendWelcomeEmail',
        params  => {
            user_id => $user_id,
        },
        # idなし = 通知（レスポンス不要）
    },
);

my $responses = $client->call_batch(@batch_requests);

# 結果を確認
my $all_success = 1;
for my $response (@$responses) {
    if ($response->is_success) {
        printf "  ✓ ID %s: 成功\n", $response->id;
    } else {
        printf "  ✗ ID %s: エラー - %s\n", 
            $response->id, 
            $response->error->{message};
        $all_success = 0;
    }
}

if ($all_success) {
    print "\n=== すべての操作が成功しました！ ===\n\n";
    
    # 最終確認: ユーザー情報を取得
    print "登録されたユーザー情報を確認中...\n";
    my $all_users = $client->call('getAllUsers');
    
    if ($all_users->is_success) {
        my $result = $all_users->result;
        print "\n--- ユーザー情報 ---\n";
        print Dumper($result->{users}{$user_id});
        print "\n--- プロフィール ---\n";
        print Dumper($result->{profiles}{$user_id});
        print "\n--- 初期データ ---\n";
        print Dumper($result->{user_data}{$user_id});
    }
} else {
    print "\n=== エラーが発生しました ===\n";
}
```

### コードの解説

このクライアントの特徴：

1. **2段階アプローチ**
   - まずユーザーを作成して`user_id`を取得
   - 取得した`user_id`を使って残りの操作をバッチ実行

2. **エラーチェック**
   - 各ステップで成功/失敗を確認
   - すべて成功した場合のみ最終確認を実行

3. **通知の活用**
   - ウェルカムメール送信は通知として実行
   - レスポンスを待たずに処理を進められる

## クライアント側の実装（エラーハンドリング）

次に、エラーが発生した場合の対応を含むクライアントを実装します。`transaction_client_with_rollback.pl`を作成：

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use JSON::RPC::Spec::Client;
use Data::Dumper;

# クライアントのインスタンスを作成
my $client = JSON::RPC::Spec::Client->new(
    url => 'http://localhost:5000/'
);

print "=== トランザクション的な処理デモ（エラーハンドリング） ===\n\n";

# ユーザー登録処理を関数化
sub register_user_with_transaction {
    my ($username, $email, $profile, $user_data) = @_;
    
    my $user_id;
    my $created_user = 0;
    
    eval {
        # Step 1: ユーザー作成
        print "Step 1: ユーザーを作成中...\n";
        my $create_result = $client->call('createUser', {
            username => $username,
            email => $email,
        });
        
        if (!$create_result->is_success) {
            die "User creation failed: " . $create_result->error->{message};
        }
        
        $user_id = $create_result->result->{user_id};
        $created_user = 1;
        print "  ✓ ユーザー作成成功: ID=$user_id\n\n";
        
        # Step 2: プロフィール設定と初期データ投入（バッチ）
        print "Step 2: プロフィール設定と初期データ投入中...\n";
        
        my @batch_requests = (
            {
                jsonrpc => '2.0',
                method  => 'setProfile',
                params  => {
                    user_id => $user_id,
                    %$profile,
                },
                id => 1,
            },
            {
                jsonrpc => '2.0',
                method  => 'initializeUserData',
                params  => {
                    user_id => $user_id,
                    %$user_data,
                },
                id => 2,
            },
        );
        
        my $responses = $client->call_batch(@batch_requests);
        
        # エラーチェック
        for my $response (@$responses) {
            if (!$response->is_success) {
                die sprintf("Batch operation failed (ID %s): %s",
                    $response->id,
                    $response->error->{message}
                );
            }
            print "  ✓ ID ", $response->id, ": 成功\n";
        }
        
        # Step 3: ウェルカムメール送信（通知）
        print "\nStep 3: ウェルカムメール送信中...\n";
        $client->call('sendWelcomeEmail', { user_id => $user_id });
        print "  ✓ メール送信リクエスト完了\n";
        
        print "\n=== すべての操作が成功しました！ ===\n";
        return { success => 1, user_id => $user_id };
    };
    
    if (my $error = $@) {
        print "\n!!! エラーが発生しました !!!\n";
        print "エラー内容: $error\n";
        
        # ロールバック処理
        if ($created_user && $user_id) {
            print "\nロールバック処理を実行中...\n";
            
            my $delete_result = $client->call('deleteUser', {
                user_id => $user_id,
            });
            
            if ($delete_result->is_success) {
                print "  ✓ ユーザー ID=$user_id を削除しました（ロールバック完了）\n";
            } else {
                print "  ✗ ロールバック失敗: ", 
                    $delete_result->error->{message}, "\n";
            }
        }
        
        return { success => 0, error => $error };
    }
}

# テストケース1: 正常なユーザー登録
print "=== テストケース1: 正常な登録 ===\n\n";

my $result1 = register_user_with_transaction(
    'bob_' . time(),
    'bob@example.com',
    {
        display_name => 'Bob the Builder',
        bio => 'Can we fix it? Yes we can!',
    },
    {
        language => 'en',
        timezone => 'America/New_York',
    }
);

print "\n結果: ", $result1->{success} ? "成功" : "失敗", "\n";
print "=" x 50, "\n\n";

# テストケース2: 存在しないユーザーIDでプロフィール設定（エラー発生）
print "=== テストケース2: 不正なユーザーIDでの操作 ===\n\n";

eval {
    print "存在しないユーザーID (99999) でプロフィール設定を試行...\n";
    my $invalid_result = $client->call('setProfile', {
        user_id => 99999,
        display_name => 'Ghost User',
    });
    
    if (!$invalid_result->is_success) {
        die "Expected error: " . $invalid_result->error->{message};
    }
};

if (my $error = $@) {
    print "  ✓ 期待通りエラーが発生: $error\n";
}

print "=" x 50, "\n\n";

# テストケース3: 重複ユーザー名での登録試行
print "=== テストケース3: 重複ユーザー名での登録 ===\n\n";

my $username = 'charlie_' . time();
print "最初の登録...\n";
my $result2 = register_user_with_transaction(
    $username,
    'charlie1@example.com',
    { display_name => 'Charlie 1' },
    { language => 'ja' }
);

print "\n同じユーザー名で2回目の登録を試行...\n";
my $result3 = register_user_with_transaction(
    $username,  # 同じユーザー名
    'charlie2@example.com',  # 異なるメールアドレス
    { display_name => 'Charlie 2' },
    { language => 'ja' }
);

print "\n1回目: ", $result2->{success} ? "成功" : "失敗", "\n";
print "2回目: ", $result3->{success} ? "成功" : "失敗 (期待通り)", "\n";

print "\n" . "=" x 50 . "\n";
print "すべてのテストケースが完了しました\n";
```

### コードの解説

このクライアントの重要な特徴：

1. **トランザクション関数**
   - ユーザー登録の一連の流れを1つの関数にまとめる
   - エラーハンドリングとロールバックを含む

2. **evalブロックによるエラーキャッチ**
   - Perlの例外処理機構を活用
   - エラー発生時に`$@`に情報が格納される

3. **ロールバック処理**
   - ユーザー作成後にエラーが発生した場合
   - 作成したユーザーを削除して初期状態に戻す

4. **複数のテストケース**
   - 正常系、異常系の両方をテスト
   - エラーハンドリングが正しく動作することを確認

## 実行とテスト

実際に動作を確認してみましょう。

### サーバーの起動

```bash
plackup transaction_server.pl
```

### 成功パターンの実行

別のターミナルで：

```bash
perl transaction_client_success.pl
```

### 実行結果の例（成功パターン）

```
=== トランザクション的な処理デモ（成功パターン） ===

Step 1: ユーザーを作成中...
  ✓ ユーザー作成成功: ID=1000, username=alice_1702123456

Step 2: プロフィール設定と初期データ投入をバッチ実行中...
  ✓ ID 1: 成功
  ✓ ID 2: 成功

=== すべての操作が成功しました！ ===

登録されたユーザー情報を確認中...

--- ユーザー情報 ---
{
  'created_at' => 1702123456,
  'email' => 'alice_1702123456@example.com',
  'id' => 1000,
  'username' => 'alice_1702123456'
}

--- プロフィール ---
{
  'avatar_url' => 'https://example.com/avatars/alice.jpg',
  'bio' => 'I love JSON-RPC and Perl!',
  'display_name' => 'Alice in Wonderland',
  'updated_at' => 1702123456,
  'user_id' => 1000
}

--- 初期データ ---
{
  'created_at' => 1702123456,
  'preferences' => {
    'language' => 'ja',
    'theme' => 'dark',
    'timezone' => 'Asia/Tokyo'
  },
  'stats' => {
    'last_login' => undef,
    'login_count' => 0
  }
}
```

### エラーハンドリングの実行

```bash
perl transaction_client_with_rollback.pl
```

### 実行結果の例（エラーハンドリング）

```
=== トランザクション的な処理デモ（エラーハンドリング） ===

=== テストケース1: 正常な登録 ===

Step 1: ユーザーを作成中...
  ✓ ユーザー作成成功: ID=1001

Step 2: プロフィール設定と初期データ投入中...
  ✓ ID 1: 成功
  ✓ ID 2: 成功

Step 3: ウェルカムメール送信中...
  ✓ メール送信リクエスト完了

=== すべての操作が成功しました！ ===

結果: 成功
==================================================

=== テストケース2: 不正なユーザーIDでの操作 ===

存在しないユーザーID (99999) でプロフィール設定を試行...
  ✓ 期待通りエラーが発生: Expected error: User with ID 99999 does not exist
==================================================

=== テストケース3: 重複ユーザー名での登録 ===

最初の登録...
Step 1: ユーザーを作成中...
  ✓ ユーザー作成成功: ID=1002

Step 2: プロフィール設定と初期データ投入中...
  ✓ ID 1: 成功
  ✓ ID 2: 成功

Step 3: ウェルカムメール送信中...
  ✓ メール送信リクエスト完了

=== すべての操作が成功しました！ ===

同じユーザー名で2回目の登録を試行...
Step 1: ユーザーを作成中...

!!! エラーが発生しました !!!
エラー内容: User creation failed: Username 'charlie_1702123460' already exists

1回目: 成功
2回目: 失敗 (期待通り)

==================================================
すべてのテストケースが完了しました
```

## バッチ処理におけるエラーハンドリングのパターン

実装を通じて学んだエラーハンドリングのパターンを整理します。

### パターン1: 事前検証

バッチ実行前に検証を行う：

```perl
# ユーザーIDの存在確認を先に実行
my $check = $client->call('getUserById', { user_id => $user_id });

if ($check->is_success) {
    # 検証OK、バッチを実行
    my $responses = $client->call_batch(@batch_requests);
} else {
    die "User does not exist";
}
```

### パターン2: 部分的な成功の検出

バッチ結果を解析して対応を決定：

```perl
my $responses = $client->call_batch(@batch_requests);

my @successful_ids;
my @failed_ids;

for my $response (@$responses) {
    if ($response->is_success) {
        push @successful_ids, $response->id;
    } else {
        push @failed_ids, $response->id;
    }
}

if (@failed_ids) {
    # 一部失敗: 成功した操作をロールバック
    rollback_operations(@successful_ids);
}
```

### パターン3: 段階的なコミット

重要度の高い操作から順に実行：

```perl
# フェーズ1: 必須操作
my $phase1_result = $client->call('criticalOperation', $params);
die "Phase 1 failed" unless $phase1_result->is_success;

# フェーズ2: 重要だがロールバック可能な操作（バッチ）
my $phase2_responses = $client->call_batch(@batch_requests);

# フェーズ3: オプショナルな操作（通知）
$client->call('optionalNotification', $params);
```

## ベストプラクティス

実践的なトランザクション処理を実装する際のポイント：

### 1. 冪等性の確保

同じ操作を複数回実行しても結果が変わらないようにする：

```perl
# 悪い例: 実行のたびにカウンタが増える
sub increment_counter {
    my $count = get_counter();
    set_counter($count + 1);
}

# 良い例: 特定の値に設定する
sub set_counter_value {
    my ($value) = @_;
    set_counter($value);  # 何度実行しても同じ結果
}
```

### 2. タイムアウトの設定

長時間実行される操作にはタイムアウトを設定：

```perl
use Furl;

my $client = JSON::RPC::Spec::Client->new(
    url => 'http://localhost:5000/',
    ua => Furl->new(timeout => 30),  # 30秒でタイムアウト
);
```

### 3. リトライ戦略

一時的なエラーに対応するリトライ：

```perl
sub call_with_retry {
    my ($method, $params, $max_retries) = @_;
    $max_retries //= 3;
    
    for my $attempt (1..$max_retries) {
        my $result = $client->call($method, $params);
        return $result if $result->is_success;
        
        warn "Attempt $attempt failed, retrying...\n";
        sleep(2 ** $attempt);  # 指数バックオフ
    }
    
    die "Failed after $max_retries attempts";
}
```

### 4. 監査ログの記録

重要な操作は記録を残す：

```perl
sub log_transaction {
    my ($operation, $params, $result) = @_;
    
    my $log_entry = {
        timestamp => time(),
        operation => $operation,
        params => $params,
        success => $result->{success},
        error => $result->{error},
    };
    
    # ログファイルやデータベースに記録
    append_to_audit_log($log_entry);
}
```

## まとめ

この記事では、JSON-RPC 2.0のバッチ処理を使った疑似トランザクション処理について学びました：

- **段階的な実行**: 依存関係のある操作を順序制御して実行
- **エラーハンドリング**: evalブロックとロールバックで整合性を保つ
- **部分的な成功への対応**: バッチ内の成功/失敗を個別に検出して対処
- **実践的なパターン**: 事前検証、段階的コミット、冪等性の確保
- **ベストプラクティス**: タイムアウト、リトライ、監査ログ

JSON-RPCのバッチ処理は真のトランザクションではありませんが、適切な設計とエラーハンドリングにより、信頼性の高い複合操作を実現できます。

次回は、JSON-RPCサーバーの認証・認可について学びます。セキュアなAPIを構築するための実践的な方法を紹介します。

## 参考リンク

- {{< linkcard "https://www.jsonrpc.org/specification#batch" >}}
- {{< linkcard "https://metacpan.org/pod/JSON::RPC::Spec::Client" >}}
