---
title: "バッチ処理入門 - 複数リクエストを一度に送る"
description: "JSON-RPC 2.0の強力な機能であるバッチ処理を実装し、複数のリクエストを配列でまとめて送信する効率的な通信を実現します。"
tags:
  - json-rpc
  - perl
  - batch-processing
  - performance
  - optimization
draft: true
---

[@nqounet](https://x.com/nqounet)です。

前回の記事では、通知（Notification）を使った一方向通信について学びました。レスポンスを必要としない処理で通信量を削減できることがわかりました。

今回は、JSON-RPC 2.0のもう一つの強力な機能である「バッチ処理」について深く掘り下げます。バッチ処理を使うと、複数のリクエストを一度にまとめて送信でき、ネットワークのオーバーヘッドを大幅に削減できます。

複数の計算を一括で実行する実例を通じて、バッチ処理の実装方法とパフォーマンスの違いを体験していきましょう。

## バッチ処理とは

バッチ処理は、複数のJSON-RPCリクエストを配列にまとめて、一度のHTTPリクエストで送信する機能です。これにより、以下のようなメリットが得られます：

- **ネットワークオーバーヘッドの削減**: HTTPコネクションの確立やヘッダーの送信が1回で済む
- **レイテンシの改善**: 複数のリクエストを並列処理できる可能性がある
- **通信量の削減**: HTTPヘッダーなどの固定オーバーヘッドが減る

### バッチリクエストの構造

バッチリクエストは、単純にリクエストオブジェクトを配列にまとめたものです：

```json
[
  {
    "jsonrpc": "2.0",
    "method": "sum",
    "params": [1, 2, 4],
    "id": "1"
  },
  {
    "jsonrpc": "2.0",
    "method": "subtract",
    "params": [42, 23],
    "id": "2"
  },
  {
    "jsonrpc": "2.0",
    "method": "multiply",
    "params": {"x": 5, "y": 7},
    "id": "3"
  }
]
```

### バッチレスポンスの構造

サーバーは、各リクエストに対応するレスポンスを配列で返します：

```json
[
  {
    "jsonrpc": "2.0",
    "result": 7,
    "id": "1"
  },
  {
    "jsonrpc": "2.0",
    "result": 19,
    "id": "2"
  },
  {
    "jsonrpc": "2.0",
    "result": 35,
    "id": "3"
  }
]
```

重要なポイント：

- レスポンスの順序は、リクエストの順序と一致する保証はありません
- `id`フィールドでリクエストとレスポンスを対応付けます
- 通知（`id`なし）が含まれる場合、それに対するレスポンスは返されません

## サーバー側の実装

まず、複数の計算メソッドを持つサーバーを実装しましょう。`batch_server.pl`を作成します：

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use JSON::RPC::Spec;

# JSON-RPCサーバーのインスタンスを作成
my $rpc = JSON::RPC::Spec->new;

# 加算メソッド
$rpc->register(
    sum => sub {
        my ($params) = @_;
        
        # 配列形式のパラメータを想定
        unless (ref $params eq 'ARRAY') {
            die "Parameters must be an array";
        }
        
        my $total = 0;
        $total += $_ for @$params;
        return $total;
    }
);

# 減算メソッド
$rpc->register(
    subtract => sub {
        my ($params) = @_;
        
        if (ref $params eq 'ARRAY') {
            # 位置パラメータ: [minuend, subtrahend]
            return $params->[0] - $params->[1];
        } elsif (ref $params eq 'HASH') {
            # 名前付きパラメータ
            return $params->{minuend} - $params->{subtrahend};
        } else {
            die "Invalid parameters";
        }
    }
);

# 乗算メソッド
$rpc->register(
    multiply => sub {
        my ($params) = @_;
        
        if (ref $params eq 'ARRAY') {
            # 位置パラメータ: [x, y]
            return $params->[0] * $params->[1];
        } elsif (ref $params eq 'HASH') {
            # 名前付きパラメータ
            return $params->{x} * $params->{y};
        } else {
            die "Invalid parameters";
        }
    }
);

# 除算メソッド
$rpc->register(
    divide => sub {
        my ($params) = @_;
        
        my ($dividend, $divisor);
        
        if (ref $params eq 'ARRAY') {
            ($dividend, $divisor) = @$params;
        } elsif (ref $params eq 'HASH') {
            $dividend = $params->{dividend};
            $divisor = $params->{divisor};
        } else {
            die "Invalid parameters";
        }
        
        # ゼロ除算チェック
        if ($divisor == 0) {
            die "Division by zero";
        }
        
        return $dividend / $divisor;
    }
);

# ログ記録メソッド（通知用）
$rpc->register(
    log => sub {
        my ($params) = @_;
        my $message = ref $params eq 'HASH' ? $params->{message} : $params->[0];
        warn "[LOG] $message\n";
        return; # 通知なので戻り値は使われない
    }
);

# PSGIアプリケーションとして実行
my $app = sub {
    my ($env) = @_;
    return $rpc->handle($env);
};
```

### コードの解説

このサーバーは5つのメソッドを実装しています：

1. **sum**: 配列の全要素を合計する
2. **subtract**: 2つの数値の差を計算する（位置パラメータと名前付きパラメータの両方に対応）
3. **multiply**: 2つの数値の積を計算する（両形式対応）
4. **divide**: 除算を行う（ゼロ除算のエラーチェック付き）
5. **log**: ログメッセージを記録する（通知用）

各メソッドは、位置パラメータ（配列）と名前付きパラメータ（ハッシュ）の両方に対応しており、実用的な実装例となっています。

## バッチリクエストのクライアント実装

次に、バッチリクエストを送信するクライアントを実装します。`batch_client.pl`を作成：

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use JSON::RPC::Spec::Client;
use Time::HiRes qw(time);

# クライアントのインスタンスを作成
my $client = JSON::RPC::Spec::Client->new(
    url => 'http://localhost:5000/'
);

print "=== バッチリクエストのデモ ===\n\n";

# バッチリクエストを準備
my @batch_requests = (
    {
        jsonrpc => '2.0',
        method  => 'sum',
        params  => [1, 2, 3, 4, 5],
        id      => 1,
    },
    {
        jsonrpc => '2.0',
        method  => 'subtract',
        params  => [100, 42],
        id      => 2,
    },
    {
        jsonrpc => '2.0',
        method  => 'multiply',
        params  => { x => 6, y => 7 },
        id      => 3,
    },
    {
        jsonrpc => '2.0',
        method  => 'divide',
        params  => { dividend => 84, divisor => 2 },
        id      => 4,
    },
    {
        jsonrpc => '2.0',
        method  => 'log',
        params  => { message => 'Batch request executed' },
        # idなし = 通知
    },
);

# バッチリクエストを実行
print "バッチリクエストを送信中...\n";
my $start_time = time();
my $responses = $client->call_batch(@batch_requests);
my $batch_time = time() - $start_time;

print "\n--- バッチリクエストの結果 ---\n";
for my $response (@$responses) {
    if ($response->is_success) {
        printf "ID %s: 結果 = %s\n", 
            $response->id // 'N/A',
            $response->result;
    } else {
        printf "ID %s: エラー = %s\n",
            $response->id // 'N/A',
            $response->error->{message};
    }
}

printf "\nバッチ処理時間: %.4f秒\n", $batch_time;

# 比較: 同じリクエストを個別に送信
print "\n=== 個別リクエストとの比較 ===\n\n";
print "同じリクエストを個別に送信中...\n";

$start_time = time();
my @individual_results;

for my $req (@batch_requests[0..3]) {  # 通知を除く4つのリクエスト
    my $result = $client->call($req->{method}, $req->{params});
    push @individual_results, $result;
}
my $individual_time = time() - $start_time;

print "\n--- 個別リクエストの結果 ---\n";
for my $i (0..$#individual_results) {
    my $result = $individual_results[$i];
    if ($result->is_success) {
        printf "リクエスト %d: 結果 = %s\n",
            $i + 1,
            $result->result;
    } else {
        printf "リクエスト %d: エラー = %s\n",
            $i + 1,
            $result->error->{message};
    }
}

printf "\n個別処理時間: %.4f秒\n", $individual_time;

# パフォーマンス比較
print "\n=== パフォーマンス比較 ===\n";
printf "バッチ処理: %.4f秒\n", $batch_time;
printf "個別処理:   %.4f秒\n", $individual_time;
if ($individual_time > 0) {
    printf "改善率:     %.1f%%\n", 
        (($individual_time - $batch_time) / $individual_time) * 100;
    printf "速度比:     %.2f倍高速\n",
        $individual_time / $batch_time;
}
```

### コードの解説

このクライアントは以下の処理を行います：

1. **バッチリクエストの準備**
   - 5つのリクエスト（4つの計算 + 1つの通知）を配列で定義
   - それぞれ異なるメソッドとパラメータ形式を使用

2. **バッチリクエストの実行**
   - `call_batch`メソッドで一括送信
   - 実行時間を計測

3. **個別リクエストとの比較**
   - 同じリクエストを1つずつ送信
   - 実行時間を計測

4. **パフォーマンス分析**
   - 両方の実行時間を比較
   - 改善率と速度比を計算

## 実行とパフォーマンス測定

それでは実際に動かしてみましょう。

### サーバーの起動

まず、サーバーを起動します：

```bash
plackup batch_server.pl
```

### クライアントの実行

別のターミナルでクライアントを実行します：

```bash
perl batch_client.pl
```

### 実行結果の例

```
=== バッチリクエストのデモ ===

バッチリクエストを送信中...

--- バッチリクエストの結果 ---
ID 1: 結果 = 15
ID 2: 結果 = 58
ID 3: 結果 = 42
ID 4: 結果 = 42

バッチ処理時間: 0.0234秒

=== 個別リクエストとの比較 ===

同じリクエストを個別に送信中...

--- 個別リクエストの結果 ---
リクエスト 1: 結果 = 15
リクエスト 2: 結果 = 58
リクエスト 3: 結果 = 42
リクエスト 4: 結果 = 42

個別処理時間: 0.0876秒

=== パフォーマンス比較 ===
バッチ処理: 0.0234秒
個別処理:   0.0876秒
改善率:     73.3%
速度比:     3.74倍高速
```

この結果から、バッチ処理が個別リクエストと比較して約3.7倍高速であることがわかります。ネットワークのレイテンシが大きい環境では、さらに大きな差が出る可能性があります。

## 通知を含むバッチ処理

バッチリクエストには通知（`id`フィールドなし）を含めることができます。これにより、結果を必要としない処理を効率的に実行できます。

### 通知を含むバッチリクエストの例

```perl
my @batch_with_notifications = (
    # 計算リクエスト（レスポンスあり）
    {
        jsonrpc => '2.0',
        method  => 'sum',
        params  => [10, 20, 30],
        id      => 1,
    },
    # ログ通知（レスポンスなし）
    {
        jsonrpc => '2.0',
        method  => 'log',
        params  => { message => 'Calculation started' },
    },
    # 計算リクエスト（レスポンスあり）
    {
        jsonrpc => '2.0',
        method  => 'multiply',
        params  => [5, 12],
        id      => 2,
    },
    # ログ通知（レスポンスなし）
    {
        jsonrpc => '2.0',
        method  => 'log',
        params  => { message => 'Calculation completed' },
    },
);

my $responses = $client->call_batch(@batch_with_notifications);

# レスポンスは2つのみ（通知には返答なし）
print "レスポンス数: ", scalar(@$responses), "\n";  # 出力: 2
```

サーバーのログには、通知メッセージが記録されます：

```
[LOG] Calculation started
[LOG] Calculation completed
```

## バッチ処理のベストプラクティス

バッチ処理を効果的に使うためのポイントを整理します。

### 1. 適切なバッチサイズを選ぶ

```perl
# 小さすぎる: バッチのメリットが少ない
my @small_batch = (
    { jsonrpc => '2.0', method => 'sum', params => [1, 2], id => 1 },
);

# 大きすぎる: タイムアウトやメモリの問題が発生する可能性
my @huge_batch;
for my $i (1..10000) {
    push @huge_batch, {
        jsonrpc => '2.0',
        method  => 'sum',
        params  => [$i, $i + 1],
        id      => $i,
    };
}

# 適切なサイズ: 10〜100程度が目安
my @optimal_batch;
for my $i (1..50) {
    push @optimal_batch, {
        jsonrpc => '2.0',
        method  => 'sum',
        params  => [$i, $i + 1],
        id      => $i,
    };
}
```

### 2. エラーハンドリングを考慮する

バッチ内の一部のリクエストがエラーになっても、他のリクエストは正常に処理されます：

```perl
my @batch_with_error = (
    {
        jsonrpc => '2.0',
        method  => 'divide',
        params  => [100, 5],
        id      => 1,
    },
    {
        jsonrpc => '2.0',
        method  => 'divide',
        params  => [100, 0],  # エラー: ゼロ除算
        id      => 2,
    },
    {
        jsonrpc => '2.0',
        method  => 'divide',
        params  => [100, 2],
        id      => 3,
    },
);

my $responses = $client->call_batch(@batch_with_error);

for my $response (@$responses) {
    if ($response->is_success) {
        printf "ID %s: 成功 = %s\n", $response->id, $response->result;
    } else {
        printf "ID %s: エラー = %s\n", 
            $response->id, 
            $response->error->{message};
    }
}

# 出力:
# ID 1: 成功 = 20
# ID 2: エラー = Division by zero
# ID 3: 成功 = 50
```

### 3. 処理の独立性を確保する

バッチ内のリクエストは、互いに依存しない処理にするのが理想的です：

```perl
# 良い例: 各リクエストが独立
my @good_batch = (
    { jsonrpc => '2.0', method => 'sum', params => [1, 2], id => 1 },
    { jsonrpc => '2.0', method => 'multiply', params => [3, 4], id => 2 },
    { jsonrpc => '2.0', method => 'subtract', params => [10, 5], id => 3 },
);

# 悪い例: リクエストが相互に依存（避けるべき）
# 注: JSON-RPCではこのような依存関係のある処理は推奨されません
# もし必要なら、個別のリクエストとして順次実行すべき
```

### 4. IDの管理

バッチリクエストでは、各リクエストに一意の`id`を割り当てることが重要です：

```perl
my $id_counter = 1;
my @batch;

for my $value (1..10) {
    push @batch, {
        jsonrpc => '2.0',
        method  => 'sum',
        params  => [$value, $value + 1],
        id      => $id_counter++,  # 一意のIDを生成
    };
}

# レスポンスをIDでマッピング
my $responses = $client->call_batch(@batch);
my %result_by_id = map { $_->id => $_ } @$responses;

# IDで特定のレスポンスにアクセス
if ($result_by_id{5}->is_success) {
    print "ID 5の結果: ", $result_by_id{5}->result, "\n";
}
```

## ネットワーク環境による違い

バッチ処理の効果は、ネットワーク環境に大きく依存します。

### ローカル環境（レイテンシ < 1ms）

```
個別リクエスト: 0.0876秒
バッチリクエスト: 0.0234秒
改善率: 73.3%
```

### リモート環境（レイテンシ 50ms）

```
個別リクエスト: 0.812秒  (4リクエスト × 約200ms)
バッチリクエスト: 0.215秒 (1リクエスト × 約200ms + 処理時間)
改善率: 73.5%
速度比: 約3.8倍
```

### 高レイテンシ環境（レイテンシ 200ms）

```
個別リクエスト: 3.245秒  (4リクエスト × 約800ms)
バッチリクエスト: 0.834秒 (1リクエスト × 約800ms + 処理時間)
改善率: 74.3%
速度比: 約3.9倍
```

レイテンシが大きい環境ほど、バッチ処理の効果が顕著になります。

## まとめ

この記事では、JSON-RPC 2.0のバッチ処理について学びました：

- **バッチリクエストの構造**: 複数のリクエストオブジェクトを配列にまとめる
- **バッチレスポンスの処理**: IDで対応付けられたレスポンス配列を処理する
- **通知との組み合わせ**: バッチに通知を含めることで、さらに効率化できる
- **パフォーマンス改善**: ローカル環境でも3〜4倍、リモート環境ではさらに大きな改善
- **ベストプラクティス**: 適切なバッチサイズ、エラーハンドリング、処理の独立性

バッチ処理は、JSON-RPC 2.0の大きな強みの一つです。複数の処理を効率的に実行したい場合、積極的に活用しましょう。

次回は、より高度なトピックとして、JSON-RPCサーバーの認証・認可について学びます。セキュアなAPIを構築するための実践的な方法を紹介します。

## 参考リンク

- {{< linkcard "https://www.jsonrpc.org/specification#batch" >}}
- {{< linkcard "https://metacpan.org/pod/JSON::RPC::Spec::Client" >}}
