---
title: "ç·ã¾ã¨ã‚ã¨å®Ÿè·µçš„ãªã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³é–‹ç™º"
description: "ã“ã‚Œã¾ã§å­¦ã‚“ã çŸ¥è­˜ã‚’çµ±åˆã—ã€ToDoãƒªã‚¹ãƒˆç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã‚’ä¾‹ã«å®Ÿç”¨çš„ãªã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æ§‹ç¯‰ã€è¨­è¨ˆã‹ã‚‰å®Ÿè£…ã¾ã§è¡Œã„ã¾ã™ã€‚"
tags:
  - json-rpc
  - perl
  - full-stack
  - best-practices
  - production-ready
draft: true
---

[@nqounet](https://x.com/nqounet)ã§ã™ã€‚

ã¤ã„ã«é€£è¼‰ã®æœ€çµ‚å›ã‚’è¿ãˆã¾ã—ãŸã€‚ã“ã‚Œã¾ã§ã®11å›ã«ã‚ãŸã£ã¦ã€JSON-RPC 2.0ã®åŸºç¤ã‹ã‚‰å¿œç”¨ã¾ã§ã€æ®µéšçš„ã«å­¦ã‚“ã§ãã¾ã—ãŸã€‚

ã“ã®æœ€çµ‚å›ã§ã¯ã€ã“ã‚Œã¾ã§ã«å­¦ã‚“ã ã™ã¹ã¦ã®çŸ¥è­˜ã‚’çµ±åˆã—ã¦ã€**å®Ÿç”¨çš„ãªToDoãƒªã‚¹ãƒˆç®¡ç†ã‚·ã‚¹ãƒ†ãƒ **ã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚è¦ä»¶å®šç¾©ã‹ã‚‰APIè¨­è¨ˆã€å®Ÿè£…ã€ãƒ†ã‚¹ãƒˆã€ãã—ã¦ãƒ‡ãƒ—ãƒ­ã‚¤æº–å‚™ã¾ã§ã€å®Ÿå‹™ã§å¿…è¦ã¨ãªã‚‹ã™ã¹ã¦ã®ã‚¹ãƒ†ãƒƒãƒ—ã‚’ä½“é¨“ã—ã¦ã„ãã¾ã—ã‚‡ã†ã€‚

ã“ã®è¨˜äº‹ã‚’é€šã˜ã¦ã€JSON-RPCã¨PerlãŒã„ã‹ã«å¼·åŠ›ãªçµ„ã¿åˆã‚ã›ã§ã‚ã‚‹ã‹ã€ãã—ã¦å®Ÿéš›ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³é–‹ç™ºã«ã©ã†æ´»ã‹ã›ã‚‹ã®ã‹ã‚’å®Ÿæ„Ÿã—ã¦ã„ãŸã ã‘ã‚‹ã¯ãšã§ã™ã€‚

## é€£è¼‰ã®æŒ¯ã‚Šè¿”ã‚Š

ã¾ãšã€ã“ã“ã¾ã§ã®æ—…ã‚’æŒ¯ã‚Šè¿”ã£ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

### ç¬¬1å›ã€œç¬¬3å›ï¼šåŸºç¤ç·¨

- **ç¬¬1å›ã€ŒJSON-RPC 2.0ã¸ã®æ‹›å¾…ã€**: ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®æ¦‚è¦ã¨RESTã¨ã®é•ã„
- **ç¬¬2å›ã€Œé–‹ç™ºç’°å¢ƒæ§‹ç¯‰ã¨Hello Worldã€**: æœ€å°é™ã®ã‚µãƒ¼ãƒãƒ¼ã¨ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
- **ç¬¬3å›ã€Œãƒ¡ã‚½ãƒƒãƒ‰ã®å®Ÿè£…ã€**: ä½ç½®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨åå‰ä»˜ããƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿

### ç¬¬4å›ã€œç¬¬6å›ï¼šæ©Ÿèƒ½ç·¨

- **ç¬¬4å›ã€Œé€šçŸ¥ã‚’ä½¿ã„ã“ãªã™ã€**: ä¸€æ–¹å‘é€šä¿¡ã®å®Ÿè£…
- **ç¬¬5å›ã€Œãƒãƒƒãƒå‡¦ç†å…¥é–€ã€**: è¤‡æ•°ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®ä¸€æ‹¬é€ä¿¡
- **ç¬¬6å›ã€Œãƒãƒƒãƒå‡¦ç†å¿œç”¨ã€**: ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³çš„ãªå‡¦ç†

### ç¬¬7å›ã€œç¬¬10å›ï¼šå®Ÿè·µç·¨

- **ç¬¬7å›ã€Œå®Ÿè·µçš„ãªã‚µãƒ¼ãƒãƒ¼è¨­è¨ˆã€**: ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åŒ–ã¨æ‹¡å¼µæ€§
- **ç¬¬8å›ã€Œèªè¨¼ã¨èªå¯ã€**: ã‚»ã‚­ãƒ¥ã‚¢ãªAPIå®Ÿè£…
- **ç¬¬9å›ã€ŒPSGIã§å‹•ã‹ã™ã€**: Webã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã¨ã®é€£æº
- **ç¬¬10å›ã€ŒJavaScriptã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã€**: ãƒ–ãƒ©ã‚¦ã‚¶ã‹ã‚‰ã®åˆ©ç”¨

### ç¬¬11å›ï¼šçµ±åˆã¨ãƒ†ã‚¹ãƒˆï¼ˆäºˆå®šï¼‰

- ãƒ†ã‚¹ãƒˆé§†å‹•é–‹ç™ºã¨ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã®å®Ÿè£…

ã“ã‚Œã‚‰ã™ã¹ã¦ã®çŸ¥è­˜ã‚’æ´»ã‹ã—ã¦ã€ä»Šå›ã¯å®Œå…¨ãªã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½œã‚Šä¸Šã’ã¾ã™ã€‚

## ToDoãƒªã‚¹ãƒˆç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã®è¦ä»¶å®šç¾©

å®Ÿç”¨çš„ãªã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½œã‚‹ã«ã¯ã€ã¾ãšè¦ä»¶ã‚’æ˜ç¢ºã«ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

### æ©Ÿèƒ½è¦ä»¶

#### åŸºæœ¬æ©Ÿèƒ½ï¼ˆCRUDæ“ä½œï¼‰

1. **ã‚¿ã‚¹ã‚¯ã®ä½œæˆï¼ˆCreateï¼‰**
   - ã‚¿ã‚¤ãƒˆãƒ«ã€èª¬æ˜ã€æœŸé™ã€å„ªå…ˆåº¦ã‚’è¨­å®š
   - ä½œæˆæ™‚ã«è‡ªå‹•çš„ã«IDã¨ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚’ä»˜ä¸

2. **ã‚¿ã‚¹ã‚¯ã®å–å¾—ï¼ˆReadï¼‰**
   - å˜ä¸€ã‚¿ã‚¹ã‚¯ã®å–å¾—
   - ã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆã®å–å¾—ï¼ˆãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã€ã‚½ãƒ¼ãƒˆã€ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³å¯¾å¿œï¼‰
   - æ¤œç´¢æ©Ÿèƒ½

3. **ã‚¿ã‚¹ã‚¯ã®æ›´æ–°ï¼ˆUpdateï¼‰**
   - éƒ¨åˆ†æ›´æ–°ã‚’ã‚µãƒãƒ¼ãƒˆ
   - å®Œäº†/æœªå®Œäº†ã®åˆ‡ã‚Šæ›¿ãˆ

4. **ã‚¿ã‚¹ã‚¯ã®å‰Šé™¤ï¼ˆDeleteï¼‰**
   - è«–ç†å‰Šé™¤ï¼ˆãƒ•ãƒ©ã‚°ã§ç®¡ç†ï¼‰
   - ç‰©ç†å‰Šé™¤ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰

#### é«˜åº¦ãªæ©Ÿèƒ½

5. **ãƒãƒƒãƒæ“ä½œ**
   - è¤‡æ•°ã‚¿ã‚¹ã‚¯ã®ä¸€æ‹¬æ›´æ–°
   - è¤‡æ•°ã‚¿ã‚¹ã‚¯ã®ä¸€æ‹¬å‰Šé™¤

6. **çµ±è¨ˆæƒ…å ±**
   - å®Œäº†ç‡ã®è¨ˆç®—
   - å„ªå…ˆåº¦åˆ¥ã®é›†è¨ˆ

### éæ©Ÿèƒ½è¦ä»¶

- **èªè¨¼**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ã”ã¨ã«ã‚¿ã‚¹ã‚¯ã‚’ç®¡ç†
- **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹**: 1000ä»¶ä»¥ä¸Šã®ã‚¿ã‚¹ã‚¯ã§ã‚‚å¿«é©ã«å‹•ä½œ
- **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£**: SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¯¾ç­–ã€XSSå¯¾ç­–
- **ä¿å®ˆæ€§**: ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åŒ–ã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã€ååˆ†ãªãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸

## APIè¨­è¨ˆ

è¦ä»¶ãŒæ±ºã¾ã£ãŸã‚‰ã€æ¬¡ã¯APIã‚’è¨­è¨ˆã—ã¾ã™ã€‚

### ãƒ¡ã‚½ãƒƒãƒ‰å‘½åè¦å‰‡

JSON-RPCã®ãƒ¡ã‚½ãƒƒãƒ‰åã¯ã€**ãƒªã‚½ãƒ¼ã‚¹.ã‚¢ã‚¯ã‚·ãƒ§ãƒ³**ã®å½¢å¼ã‚’æ¡ç”¨ã—ã¾ã™ï¼š

```
todo.create      - ã‚¿ã‚¹ã‚¯ä½œæˆ
todo.get         - å˜ä¸€ã‚¿ã‚¹ã‚¯å–å¾—
todo.list        - ã‚¿ã‚¹ã‚¯ä¸€è¦§å–å¾—
todo.update      - ã‚¿ã‚¹ã‚¯æ›´æ–°
todo.delete      - ã‚¿ã‚¹ã‚¯å‰Šé™¤
todo.batchUpdate - ä¸€æ‹¬æ›´æ–°
todo.search      - ã‚¿ã‚¹ã‚¯æ¤œç´¢
todo.stats       - çµ±è¨ˆæƒ…å ±å–å¾—
```

### APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆä¸€è¦§

| ãƒ¡ã‚½ãƒƒãƒ‰ | ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ | æˆ»ã‚Šå€¤ | èªè¨¼ |
|----------|-----------|--------|------|
| `user.login` | `{username, password}` | `{token, user}` | ä¸è¦ |
| `user.logout` | ãªã— | `{message}` | å¿…è¦ |
| `todo.create` | `{title, description?, due_date?, priority?}` | `{id, task}` | å¿…è¦ |
| `todo.get` | `{id}` | `{task}` | å¿…è¦ |
| `todo.list` | `{filter?, sort?, limit?, offset?}` | `{tasks, total}` | å¿…è¦ |
| `todo.update` | `{id, updates}` | `{task}` | å¿…è¦ |
| `todo.delete` | `{id, permanent?}` | `{message}` | å¿…è¦ |
| `todo.batchUpdate` | `{tasks: [{id, updates}]}` | `{updated}` | å¿…è¦ |
| `todo.search` | `{query}` | `{tasks, total}` | å¿…è¦ |
| `todo.stats` | ãªã— | `{total, completed, by_priority}` | å¿…è¦ |

## ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­è¨ˆ

SQLiteã‚’ä½¿ç”¨ã—ãŸã‚·ãƒ³ãƒ—ãƒ«ãªã‚¹ã‚­ãƒ¼ãƒã‚’è¨­è¨ˆã—ã¾ã™ã€‚

### schema.sql

```sql
-- ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ†ãƒ¼ãƒ–ãƒ«
CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    username TEXT UNIQUE NOT NULL,
    password_hash TEXT NOT NULL,
    email TEXT,
    created_at INTEGER NOT NULL,
    updated_at INTEGER NOT NULL
);

-- ã‚¿ã‚¹ã‚¯ãƒ†ãƒ¼ãƒ–ãƒ«
CREATE TABLE IF NOT EXISTS tasks (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER NOT NULL,
    title TEXT NOT NULL,
    description TEXT,
    priority TEXT DEFAULT 'medium' CHECK(priority IN ('low', 'medium', 'high')),
    status TEXT DEFAULT 'pending' CHECK(status IN ('pending', 'in_progress', 'completed')),
    due_date INTEGER,
    completed_at INTEGER,
    deleted INTEGER DEFAULT 0,
    created_at INTEGER NOT NULL,
    updated_at INTEGER NOT NULL,
    FOREIGN KEY (user_id) REFERENCES users(id)
);

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX IF NOT EXISTS idx_tasks_user_id ON tasks(user_id);
CREATE INDEX IF NOT EXISTS idx_tasks_status ON tasks(status);
CREATE INDEX IF NOT EXISTS idx_tasks_priority ON tasks(priority);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON tasks(due_date);
CREATE INDEX IF NOT EXISTS idx_tasks_deleted ON tasks(deleted);

-- åˆæœŸãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è¿½åŠ ï¼ˆãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰: demo123ï¼‰
INSERT OR IGNORE INTO users (username, password_hash, email, created_at, updated_at) 
VALUES (
    'demo',
    '7110eda4d09e062aa5e4a390b0a572ac0d2c0220',  -- SHA-1 hash of 'demo123'
    'demo@example.com',
    strftime('%s', 'now'),
    strftime('%s', 'now')
);
```

## ã‚µãƒ¼ãƒãƒ¼å®Ÿè£…

ãã‚Œã§ã¯ã€å®Œå…¨ãªã‚µãƒ¼ãƒãƒ¼ã‚’å®Ÿè£…ã—ã¦ã„ãã¾ã™ã€‚

### todo_server.pl

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use utf8;
use feature 'say';

use Plack::Builder;
use Plack::Request;
use JSON::RPC::Spec;
use DBI;
use Digest::SHA qw(sha1_hex sha256_hex);
use JSON;
use Time::Piece;

# ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶š
my $dbh = DBI->connect("dbi:SQLite:dbname=todo.db", "", "", {
    RaiseError => 1,
    AutoCommit => 1,
    sqlite_unicode => 1,
});

# ã‚¹ã‚­ãƒ¼ãƒåˆæœŸåŒ–
sub init_database {
    open my $fh, '<', 'schema.sql' or die $!;
    my $schema = do { local $/; <$fh> };
    close $fh;
    
    $dbh->do($_) for split /;/, $schema;
}

init_database();

# ãƒˆãƒ¼ã‚¯ãƒ³ã‚¹ãƒˆã‚¢ï¼ˆæœ¬ç•ªç’°å¢ƒã§ã¯Redisãªã©ã‚’ä½¿ç”¨ï¼‰
my %tokens;

# ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
sub generate_token {
    my ($user_id) = @_;
    my $token = sha256_hex($user_id . time() . rand());
    $tokens{$token} = {
        user_id => $user_id,
        created => time(),
    };
    return $token;
}

sub verify_token {
    my ($token) = @_;
    return unless $token;
    my $token_data = $tokens{$token};
    return unless $token_data;
    
    # ãƒˆãƒ¼ã‚¯ãƒ³ã®æœ‰åŠ¹æœŸé™ãƒã‚§ãƒƒã‚¯ï¼ˆ24æ™‚é–“ï¼‰
    return if time() - $token_data->{created} > 86400;
    
    return $token_data->{user_id};
}

sub current_timestamp {
    return time();
}

# JSON-RPC ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
my $rpc = JSON::RPC::Spec->new;

# =============================================================================
# ãƒ¦ãƒ¼ã‚¶ãƒ¼ç®¡ç†ãƒ¡ã‚½ãƒƒãƒ‰
# =============================================================================

$rpc->register(
    'user.login' => sub {
        my ($params) = @_;
        
        my $username = $params->{username} or die JSON::RPC::Spec::Error->new(
            code => -32602,
            message => "ãƒ¦ãƒ¼ã‚¶ãƒ¼åãŒå¿…è¦ã§ã™",
        );
        
        my $password = $params->{password} or die JSON::RPC::Spec::Error->new(
            code => -32602,
            message => "ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒå¿…è¦ã§ã™",
        );
        
        # ãƒ¦ãƒ¼ã‚¶ãƒ¼æ¤œè¨¼
        my $user = $dbh->selectrow_hashref(
            "SELECT * FROM users WHERE username = ?",
            undef,
            $username
        );
        
        unless ($user) {
            die JSON::RPC::Spec::Error->new(
                code => -32001,
                message => "èªè¨¼ã«å¤±æ•—ã—ã¾ã—ãŸ",
            );
        }
        
        # ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰æ¤œè¨¼
        my $password_hash = sha1_hex($password);
        unless ($password_hash eq $user->{password_hash}) {
            die JSON::RPC::Spec::Error->new(
                code => -32001,
                message => "èªè¨¼ã«å¤±æ•—ã—ã¾ã—ãŸ",
            );
        }
        
        # ãƒˆãƒ¼ã‚¯ãƒ³ç”Ÿæˆ
        my $token = generate_token($user->{id});
        
        return {
            token => $token,
            user => {
                id => $user->{id},
                username => $user->{username},
                email => $user->{email},
            },
        };
    }
);

$rpc->register(
    'user.logout' => sub {
        my ($params, $context) = @_;
        
        my $token = $context->{token};
        delete $tokens{$token} if $token;
        
        return {
            message => "ãƒ­ã‚°ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ",
        };
    }
);

# =============================================================================
# ToDoã‚¿ã‚¹ã‚¯ç®¡ç†ãƒ¡ã‚½ãƒƒãƒ‰
# =============================================================================

$rpc->register(
    'todo.create' => sub {
        my ($params, $context) = @_;
        
        my $user_id = $context->{user_id};
        my $title = $params->{title} or die JSON::RPC::Spec::Error->new(
            code => -32602,
            message => "ã‚¿ã‚¤ãƒˆãƒ«ãŒå¿…è¦ã§ã™",
        );
        
        my $description = $params->{description} || '';
        my $priority = $params->{priority} || 'medium';
        my $due_date = $params->{due_date};
        
        # å„ªå…ˆåº¦ã®æ¤œè¨¼
        unless ($priority =~ /^(low|medium|high)$/) {
            die JSON::RPC::Spec::Error->new(
                code => -32602,
                message => "å„ªå…ˆåº¦ã¯ low, medium, high ã®ã„ãšã‚Œã‹ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™",
            );
        }
        
        my $now = current_timestamp();
        
        $dbh->do(
            "INSERT INTO tasks (user_id, title, description, priority, due_date, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?)",
            undef,
            $user_id, $title, $description, $priority, $due_date, $now, $now
        );
        
        my $id = $dbh->last_insert_id(undef, undef, 'tasks', 'id');
        
        my $task = $dbh->selectrow_hashref(
            "SELECT * FROM tasks WHERE id = ?",
            undef,
            $id
        );
        
        return {
            id => $id,
            task => $task,
        };
    }
);

$rpc->register(
    'todo.get' => sub {
        my ($params, $context) = @_;
        
        my $user_id = $context->{user_id};
        my $id = $params->{id} or die JSON::RPC::Spec::Error->new(
            code => -32602,
            message => "ã‚¿ã‚¹ã‚¯IDãŒå¿…è¦ã§ã™",
        );
        
        my $task = $dbh->selectrow_hashref(
            "SELECT * FROM tasks WHERE id = ? AND user_id = ? AND deleted = 0",
            undef,
            $id, $user_id
        );
        
        unless ($task) {
            die JSON::RPC::Spec::Error->new(
                code => -32001,
                message => "ã‚¿ã‚¹ã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“",
            );
        }
        
        return {
            task => $task,
        };
    }
);

$rpc->register(
    'todo.list' => sub {
        my ($params, $context) = @_;
        
        my $user_id = $context->{user_id};
        my $filter = $params->{filter} || {};
        my $sort = $params->{sort} || 'created_at';
        my $order = $params->{order} || 'DESC';
        my $limit = $params->{limit} || 50;
        my $offset = $params->{offset} || 0;
        
        # WHEREå¥ã®æ§‹ç¯‰
        my @where = ("user_id = ?", "deleted = 0");
        my @bind = ($user_id);
        
        if ($filter->{status}) {
            push @where, "status = ?";
            push @bind, $filter->{status};
        }
        
        if ($filter->{priority}) {
            push @where, "priority = ?";
            push @bind, $filter->{priority};
        }
        
        my $where_clause = join(' AND ', @where);
        
        # ã‚½ãƒ¼ãƒˆã®æ¤œè¨¼
        unless ($sort =~ /^(created_at|updated_at|due_date|priority|status)$/) {
            $sort = 'created_at';
        }
        
        unless ($order =~ /^(ASC|DESC)$/i) {
            $order = 'DESC';
        }
        
        # ã‚¿ã‚¹ã‚¯å–å¾—
        my $tasks = $dbh->selectall_arrayref(
            "SELECT * FROM tasks WHERE $where_clause ORDER BY $sort $order LIMIT ? OFFSET ?",
            { Slice => {} },
            @bind, $limit, $offset
        );
        
        # ç·ä»¶æ•°å–å¾—
        my ($total) = $dbh->selectrow_array(
            "SELECT COUNT(*) FROM tasks WHERE $where_clause",
            undef,
            @bind
        );
        
        return {
            tasks => $tasks,
            total => $total,
            limit => $limit,
            offset => $offset,
        };
    }
);

$rpc->register(
    'todo.update' => sub {
        my ($params, $context) = @_;
        
        my $user_id = $context->{user_id};
        my $id = $params->{id} or die JSON::RPC::Spec::Error->new(
            code => -32602,
            message => "ã‚¿ã‚¹ã‚¯IDãŒå¿…è¦ã§ã™",
        );
        
        my $updates = $params->{updates} or die JSON::RPC::Spec::Error->new(
            code => -32602,
            message => "æ›´æ–°å†…å®¹ãŒå¿…è¦ã§ã™",
        );
        
        # ã‚¿ã‚¹ã‚¯ã®å­˜åœ¨ç¢ºèª
        my $task = $dbh->selectrow_hashref(
            "SELECT * FROM tasks WHERE id = ? AND user_id = ? AND deleted = 0",
            undef,
            $id, $user_id
        );
        
        unless ($task) {
            die JSON::RPC::Spec::Error->new(
                code => -32001,
                message => "ã‚¿ã‚¹ã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“",
            );
        }
        
        # æ›´æ–°å¯èƒ½ãªãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
        my %allowed_fields = (
            title => 1,
            description => 1,
            priority => 1,
            status => 1,
            due_date => 1,
        );
        
        my @set;
        my @bind;
        
        for my $field (keys %$updates) {
            if ($allowed_fields{$field}) {
                push @set, "$field = ?";
                push @bind, $updates->{$field};
            }
        }
        
        return { message => "æ›´æ–°ã™ã‚‹é …ç›®ãŒã‚ã‚Šã¾ã›ã‚“" } unless @set;
        
        # ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒå®Œäº†ã«å¤‰æ›´ã•ã‚ŒãŸå ´åˆ
        if ($updates->{status} && $updates->{status} eq 'completed' && $task->{status} ne 'completed') {
            push @set, "completed_at = ?";
            push @bind, current_timestamp();
        }
        
        push @set, "updated_at = ?";
        push @bind, current_timestamp();
        
        my $set_clause = join(', ', @set);
        
        $dbh->do(
            "UPDATE tasks SET $set_clause WHERE id = ?",
            undef,
            @bind, $id
        );
        
        # æ›´æ–°å¾Œã®ã‚¿ã‚¹ã‚¯ã‚’å–å¾—
        $task = $dbh->selectrow_hashref(
            "SELECT * FROM tasks WHERE id = ?",
            undef,
            $id
        );
        
        return {
            task => $task,
        };
    }
);

$rpc->register(
    'todo.delete' => sub {
        my ($params, $context) = @_;
        
        my $user_id = $context->{user_id};
        my $id = $params->{id} or die JSON::RPC::Spec::Error->new(
            code => -32602,
            message => "ã‚¿ã‚¹ã‚¯IDãŒå¿…è¦ã§ã™",
        );
        
        my $permanent = $params->{permanent} || 0;
        
        # ã‚¿ã‚¹ã‚¯ã®å­˜åœ¨ç¢ºèª
        my $task = $dbh->selectrow_hashref(
            "SELECT * FROM tasks WHERE id = ? AND user_id = ?",
            undef,
            $id, $user_id
        );
        
        unless ($task) {
            die JSON::RPC::Spec::Error->new(
                code => -32001,
                message => "ã‚¿ã‚¹ã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“",
            );
        }
        
        if ($permanent) {
            # ç‰©ç†å‰Šé™¤
            $dbh->do("DELETE FROM tasks WHERE id = ?", undef, $id);
            return { message => "ã‚¿ã‚¹ã‚¯ã‚’å®Œå…¨ã«å‰Šé™¤ã—ã¾ã—ãŸ" };
        } else {
            # è«–ç†å‰Šé™¤
            $dbh->do(
                "UPDATE tasks SET deleted = 1, updated_at = ? WHERE id = ?",
                undef,
                current_timestamp(), $id
            );
            return { message => "ã‚¿ã‚¹ã‚¯ã‚’å‰Šé™¤ã—ã¾ã—ãŸ" };
        }
    }
);

$rpc->register(
    'todo.batchUpdate' => sub {
        my ($params, $context) = @_;
        
        my $user_id = $context->{user_id};
        my $tasks = $params->{tasks} or die JSON::RPC::Spec::Error->new(
            code => -32602,
            message => "ã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆãŒå¿…è¦ã§ã™",
        );
        
        my @updated;
        
        $dbh->begin_work;
        
        eval {
            for my $task_update (@$tasks) {
                my $id = $task_update->{id};
                my $updates = $task_update->{updates};
                
                my @set;
                my @bind;
                
                my %allowed_fields = (
                    title => 1,
                    description => 1,
                    priority => 1,
                    status => 1,
                    due_date => 1,
                );
                
                for my $field (keys %$updates) {
                    if ($allowed_fields{$field}) {
                        push @set, "$field = ?";
                        push @bind, $updates->{$field};
                    }
                }
                
                next unless @set;
                
                push @set, "updated_at = ?";
                push @bind, current_timestamp();
                
                my $set_clause = join(', ', @set);
                
                $dbh->do(
                    "UPDATE tasks SET $set_clause WHERE id = ? AND user_id = ?",
                    undef,
                    @bind, $id, $user_id
                );
                
                push @updated, $id if $dbh->rows > 0;
            }
            
            $dbh->commit;
        };
        
        if ($@) {
            $dbh->rollback;
            die JSON::RPC::Spec::Error->new(
                code => -32603,
                message => "ãƒãƒƒãƒæ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ: $@",
            );
        }
        
        return {
            updated => \@updated,
            count => scalar(@updated),
        };
    }
);

$rpc->register(
    'todo.search' => sub {
        my ($params, $context) = @_;
        
        my $user_id = $context->{user_id};
        my $query = $params->{query} or die JSON::RPC::Spec::Error->new(
            code => -32602,
            message => "æ¤œç´¢ã‚¯ã‚¨ãƒªãŒå¿…è¦ã§ã™",
        );
        
        my $tasks = $dbh->selectall_arrayref(
            "SELECT * FROM tasks WHERE user_id = ? AND deleted = 0 AND (title LIKE ? OR description LIKE ?) ORDER BY created_at DESC",
            { Slice => {} },
            $user_id, "%$query%", "%$query%"
        );
        
        return {
            tasks => $tasks,
            total => scalar(@$tasks),
            query => $query,
        };
    }
);

$rpc->register(
    'todo.stats' => sub {
        my ($params, $context) = @_;
        
        my $user_id = $context->{user_id};
        
        my ($total) = $dbh->selectrow_array(
            "SELECT COUNT(*) FROM tasks WHERE user_id = ? AND deleted = 0",
            undef,
            $user_id
        );
        
        my ($completed) = $dbh->selectrow_array(
            "SELECT COUNT(*) FROM tasks WHERE user_id = ? AND deleted = 0 AND status = 'completed'",
            undef,
            $user_id
        );
        
        my $by_priority = $dbh->selectall_hashref(
            "SELECT priority, COUNT(*) as count FROM tasks WHERE user_id = ? AND deleted = 0 GROUP BY priority",
            'priority',
            undef,
            $user_id
        );
        
        my $by_status = $dbh->selectall_hashref(
            "SELECT status, COUNT(*) as count FROM tasks WHERE user_id = ? AND deleted = 0 GROUP BY status",
            'status',
            undef,
            $user_id
        );
        
        return {
            total => $total,
            completed => $completed,
            pending => $total - $completed,
            completion_rate => $total > 0 ? sprintf("%.1f", ($completed / $total) * 100) : 0,
            by_priority => $by_priority,
            by_status => $by_status,
        };
    }
);

# ä¿è­·ã•ã‚ŒãŸãƒ¡ã‚½ãƒƒãƒ‰ã®å®šç¾©
my %protected_methods = (
    'user.logout' => 1,
    'todo.create' => 1,
    'todo.get' => 1,
    'todo.list' => 1,
    'todo.update' => 1,
    'todo.delete' => 1,
    'todo.batchUpdate' => 1,
    'todo.search' => 1,
    'todo.stats' => 1,
);

# PSGIã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³
my $app = sub {
    my $env = shift;
    my $req = Plack::Request->new($env);
    
    # CORSå¯¾å¿œ
    if ($req->method eq 'OPTIONS') {
        return [
            200,
            [
                'Access-Control-Allow-Origin' => '*',
                'Access-Control-Allow-Methods' => 'POST, OPTIONS',
                'Access-Control-Allow-Headers' => 'Content-Type, Authorization',
            ],
            ['']
        ];
    }
    
    # Authorizationãƒ˜ãƒƒãƒ€ãƒ¼ã‹ã‚‰ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å–å¾—
    my $auth_header = $req->header('Authorization') || '';
    my $token;
    if ($auth_header =~ /^Bearer\s+(.+)$/) {
        $token = $1;
    }
    
    # ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒœãƒ‡ã‚£ã‚’å–å¾—
    my $body = $req->content;
    
    # JSON-RPCãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’ãƒ‘ãƒ¼ã‚¹
    my $request;
    eval {
        $request = decode_json($body);
    };
    if ($@) {
        my $error_response = {
            jsonrpc => "2.0",
            error => {
                code => -32700,
                message => "Parse error",
            },
            id => undef,
        };
        return [
            200,
            [
                'Content-Type' => 'application/json',
                'Access-Control-Allow-Origin' => '*',
            ],
            [encode_json($error_response)]
        ];
    }
    
    # ãƒ¡ã‚½ãƒƒãƒ‰åã‚’å–å¾—
    my $method = ref($request) eq 'ARRAY' 
        ? $request->[0]{method} 
        : $request->{method};
    
    # èªè¨¼ãƒã‚§ãƒƒã‚¯
    my $context = {};
    
    if ($protected_methods{$method}) {
        unless ($token) {
            my $error_response = {
                jsonrpc => "2.0",
                error => {
                    code => -32002,
                    message => "èªè¨¼ãŒå¿…è¦ã§ã™",
                },
                id => ref($request) eq 'ARRAY' ? $request->[0]{id} : $request->{id},
            };
            return [
                401,
                [
                    'Content-Type' => 'application/json',
                    'Access-Control-Allow-Origin' => '*',
                ],
                [encode_json($error_response)]
            ];
        }
        
        my $user_id = verify_token($token);
        unless ($user_id) {
            my $error_response = {
                jsonrpc => "2.0",
                error => {
                    code => -32003,
                    message => "ç„¡åŠ¹ãªãƒˆãƒ¼ã‚¯ãƒ³ã§ã™",
                },
                id => ref($request) eq 'ARRAY' ? $request->[0]{id} : $request->{id},
            };
            return [
                401,
                [
                    'Content-Type' => 'application/json',
                    'Access-Control-Allow-Origin' => '*',
                ],
                [encode_json($error_response)]
            ];
        }
        
        $context->{user_id} = $user_id;
        $context->{token} = $token;
    }
    
    # JSON-RPCãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å‡¦ç†
    my $response;
    if (ref($request) eq 'ARRAY') {
        # ãƒãƒƒãƒãƒªã‚¯ã‚¨ã‚¹ãƒˆ
        my @responses;
        for my $req (@$request) {
            my $res = eval {
                $rpc->call($req->{method}, $req->{params}, $context);
            };
            if ($@) {
                if (ref($@) eq 'JSON::RPC::Spec::Error') {
                    push @responses, {
                        jsonrpc => "2.0",
                        error => {
                            code => $@->code,
                            message => $@->message,
                        },
                        id => $req->{id},
                    };
                } else {
                    push @responses, {
                        jsonrpc => "2.0",
                        error => {
                            code => -32603,
                            message => "Internal error: $@",
                        },
                        id => $req->{id},
                    };
                }
            } else {
                push @responses, {
                    jsonrpc => "2.0",
                    result => $res,
                    id => $req->{id},
                };
            }
        }
        $response = \@responses;
    } else {
        # å˜ä¸€ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
        my $result = eval {
            $rpc->call($request->{method}, $request->{params}, $context);
        };
        if ($@) {
            if (ref($@) eq 'JSON::RPC::Spec::Error') {
                $response = {
                    jsonrpc => "2.0",
                    error => {
                        code => $@->code,
                        message => $@->message,
                    },
                    id => $request->{id},
                };
            } else {
                $response = {
                    jsonrpc => "2.0",
                    error => {
                        code => -32603,
                        message => "Internal error: $@",
                    },
                    id => $request->{id},
                };
            }
        } else {
            $response = {
                jsonrpc => "2.0",
                result => $result,
                id => $request->{id},
            };
        }
    }
    
    return [
        200,
        [
            'Content-Type' => 'application/json',
            'Access-Control-Allow-Origin' => '*',
        ],
        [encode_json($response)]
    ];
};

# Plack ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã®é©ç”¨
builder {
    enable 'AccessLog', format => 'combined';
    $app;
};
```

ã“ã®ã‚µãƒ¼ãƒãƒ¼ã¯ã™ã§ã«éå¸¸ã«é•·ã„ã®ã§ã€æ¬¡ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã§ç¶šãã‚’æ›¸ãã¾ã™ã€‚


## Webãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã®å®Ÿè£…

æ¬¡ã«ã€ã“ã®APIã‚’ä½¿ç”¨ã™ã‚‹Webãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã‚’ä½œæˆã—ã¾ã™ã€‚

### public/index.html

```html
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ToDo List Manager</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            color: white;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        .card {
            background: white;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .login-form, .task-form {
            display: grid;
            gap: 15px;
        }

        input, select, textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 16px;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
        }

        .task-list {
            display: grid;
            gap: 10px;
        }

        .task-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .task-item.completed {
            opacity: 0.6;
            border-left-color: #48bb78;
        }

        .task-item.high {
            border-left-color: #f56565;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .stat-box {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ“ ToDo List Manager</h1>

        <!-- ãƒ­ã‚°ã‚¤ãƒ³ç”»é¢ -->
        <div id="loginSection" class="card">
            <h2>ãƒ­ã‚°ã‚¤ãƒ³</h2>
            <div class="login-form">
                <input type="text" id="username" placeholder="ãƒ¦ãƒ¼ã‚¶ãƒ¼å" value="demo">
                <input type="password" id="password" placeholder="ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰" value="demo123">
                <button onclick="login()">ãƒ­ã‚°ã‚¤ãƒ³</button>
            </div>
        </div>

        <!-- ãƒ¡ã‚¤ãƒ³ç”»é¢ -->
        <div id="mainSection" class="hidden">
            <!-- çµ±è¨ˆæƒ…å ± -->
            <div class="card">
                <h2>çµ±è¨ˆæƒ…å ±</h2>
                <div id="stats" class="stats"></div>
            </div>

            <!-- ã‚¿ã‚¹ã‚¯ä½œæˆ -->
            <div class="card">
                <h2>æ–°ã—ã„ã‚¿ã‚¹ã‚¯</h2>
                <div class="task-form">
                    <input type="text" id="taskTitle" placeholder="ã‚¿ã‚¹ã‚¯ã®ã‚¿ã‚¤ãƒˆãƒ«">
                    <textarea id="taskDescription" placeholder="èª¬æ˜ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰" rows="3"></textarea>
                    <select id="taskPriority">
                        <option value="low">ä½å„ªå…ˆåº¦</option>
                        <option value="medium" selected>ä¸­å„ªå…ˆåº¦</option>
                        <option value="high">é«˜å„ªå…ˆåº¦</option>
                    </select>
                    <input type="date" id="taskDueDate">
                    <button onclick="createTask()">ã‚¿ã‚¹ã‚¯ã‚’è¿½åŠ </button>
                </div>
            </div>

            <!-- ã‚¿ã‚¹ã‚¯ä¸€è¦§ -->
            <div class="card">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2>ã‚¿ã‚¹ã‚¯ä¸€è¦§</h2>
                    <button onclick="logout()">ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ</button>
                </div>
                <div style="margin-bottom: 15px;">
                    <input type="text" id="searchQuery" placeholder="æ¤œç´¢..." style="display: inline-block; width: 300px; margin-right: 10px;">
                    <button onclick="searchTasks()">æ¤œç´¢</button>
                    <button onclick="loadTasks()">ã™ã¹ã¦è¡¨ç¤º</button>
                </div>
                <div id="taskList" class="task-list"></div>
            </div>
        </div>
    </div>

    <script>
        const API_URL = 'http://localhost:5000/';
        let authToken = null;

        class JsonRpcClient {
            constructor(url) {
                this.url = url;
                this.requestId = 1;
            }

            async call(method, params = null) {
                const request = {
                    jsonrpc: '2.0',
                    method: method,
                    params: params,
                    id: this.requestId++
                };

                const headers = {
                    'Content-Type': 'application/json',
                };

                if (authToken) {
                    headers['Authorization'] = `Bearer ${authToken}`;
                }

                const response = await fetch(this.url, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(request)
                });

                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error.message);
                }

                return data.result;
            }
        }

        const client = new JsonRpcClient(API_URL);

        async function login() {
            const username = document.getElementById('username').value;
            const password = document.getElementById('password').value;

            try {
                const result = await client.call('user.login', { username, password });
                authToken = result.token;
                
                document.getElementById('loginSection').classList.add('hidden');
                document.getElementById('mainSection').classList.remove('hidden');
                
                loadTasks();
                loadStats();
            } catch (error) {
                alert('ãƒ­ã‚°ã‚¤ãƒ³ã‚¨ãƒ©ãƒ¼: ' + error.message);
            }
        }

        async function logout() {
            try {
                await client.call('user.logout');
                authToken = null;
                
                document.getElementById('loginSection').classList.remove('hidden');
                document.getElementById('mainSection').classList.add('hidden');
            } catch (error) {
                alert('ãƒ­ã‚°ã‚¢ã‚¦ãƒˆã‚¨ãƒ©ãƒ¼: ' + error.message);
            }
        }

        async function createTask() {
            const title = document.getElementById('taskTitle').value;
            const description = document.getElementById('taskDescription').value;
            const priority = document.getElementById('taskPriority').value;
            const dueDate = document.getElementById('taskDueDate').value;

            if (!title) {
                alert('ã‚¿ã‚¹ã‚¯ã®ã‚¿ã‚¤ãƒˆãƒ«ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }

            try {
                const params = {
                    title: title,
                    priority: priority
                };

                if (description) params.description = description;
                if (dueDate) params.due_date = new Date(dueDate).getTime() / 1000;

                await client.call('todo.create', params);
                
                document.getElementById('taskTitle').value = '';
                document.getElementById('taskDescription').value = '';
                document.getElementById('taskPriority').value = 'medium';
                document.getElementById('taskDueDate').value = '';
                
                loadTasks();
                loadStats();
            } catch (error) {
                alert('ã‚¿ã‚¹ã‚¯ä½œæˆã‚¨ãƒ©ãƒ¼: ' + error.message);
            }
        }

        async function loadTasks() {
            try {
                const result = await client.call('todo.list', {
                    limit: 100,
                    offset: 0
                });
                
                displayTasks(result.tasks);
            } catch (error) {
                alert('ã‚¿ã‚¹ã‚¯èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: ' + error.message);
            }
        }

        async function searchTasks() {
            const query = document.getElementById('searchQuery').value;
            
            if (!query) {
                loadTasks();
                return;
            }

            try {
                const result = await client.call('todo.search', { query: query });
                displayTasks(result.tasks);
            } catch (error) {
                alert('æ¤œç´¢ã‚¨ãƒ©ãƒ¼: ' + error.message);
            }
        }

        function displayTasks(tasks) {
            const taskList = document.getElementById('taskList');
            
            if (tasks.length === 0) {
                taskList.innerHTML = '<p>ã‚¿ã‚¹ã‚¯ãŒã‚ã‚Šã¾ã›ã‚“</p>';
                return;
            }

            taskList.innerHTML = tasks.map(task => {
                const dueDate = task.due_date 
                    ? new Date(task.due_date * 1000).toLocaleDateString('ja-JP')
                    : 'æœŸé™ãªã—';
                
                const statusText = {
                    'pending': 'æœªç€æ‰‹',
                    'in_progress': 'é€²è¡Œä¸­',
                    'completed': 'å®Œäº†'
                }[task.status] || task.status;

                const priorityText = {
                    'low': 'ä½',
                    'medium': 'ä¸­',
                    'high': 'é«˜'
                }[task.priority] || task.priority;

                return `
                    <div class="task-item ${task.status} ${task.priority}">
                        <div style="display: flex; justify-content: space-between; align-items: start;">
                            <div style="flex: 1;">
                                <h3>${task.title}</h3>
                                ${task.description ? `<p>${task.description}</p>` : ''}
                                <div style="margin-top: 10px; font-size: 0.9em; color: #666;">
                                    å„ªå…ˆåº¦: ${priorityText} | ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: ${statusText} | æœŸé™: ${dueDate}
                                </div>
                            </div>
                            <div style="display: flex; gap: 10px;">
                                ${task.status !== 'completed' ? 
                                    `<button onclick="completeTask(${task.id})">å®Œäº†</button>` : ''}
                                <button onclick="deleteTask(${task.id})">å‰Šé™¤</button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        async function completeTask(id) {
            try {
                await client.call('todo.update', {
                    id: id,
                    updates: { status: 'completed' }
                });
                
                loadTasks();
                loadStats();
            } catch (error) {
                alert('ã‚¿ã‚¹ã‚¯æ›´æ–°ã‚¨ãƒ©ãƒ¼: ' + error.message);
            }
        }

        async function deleteTask(id) {
            if (!confirm('ã“ã®ã‚¿ã‚¹ã‚¯ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) {
                return;
            }

            try {
                await client.call('todo.delete', { id: id });
                loadTasks();
                loadStats();
            } catch (error) {
                alert('ã‚¿ã‚¹ã‚¯å‰Šé™¤ã‚¨ãƒ©ãƒ¼: ' + error.message);
            }
        }

        async function loadStats() {
            try {
                const stats = await client.call('todo.stats');
                
                const statsDiv = document.getElementById('stats');
                statsDiv.innerHTML = `
                    <div class="stat-box">
                        <div class="stat-value">${stats.total}</div>
                        <div>ç·ã‚¿ã‚¹ã‚¯æ•°</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value">${stats.completed}</div>
                        <div>å®Œäº†</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value">${stats.pending}</div>
                        <div>æœªå®Œäº†</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value">${stats.completion_rate}%</div>
                        <div>å®Œäº†ç‡</div>
                    </div>
                `;
            } catch (error) {
                console.error('çµ±è¨ˆæƒ…å ±èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
            }
        }
    </script>
</body>
</html>
```

## ãƒ†ã‚¹ãƒˆã‚³ãƒ¼ãƒ‰ã®å®Ÿè£…

å®Ÿç”¨çš„ãªã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«ã¯ã€ã—ã£ã‹ã‚Šã—ãŸãƒ†ã‚¹ãƒˆãŒæ¬ ã‹ã›ã¾ã›ã‚“ã€‚

### test/todo_api.t

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use Test::More;
use Test::Exception;
use Plack::Test;
use HTTP::Request::Common;
use JSON;
use DBI;

# ãƒ†ã‚¹ãƒˆç”¨DBã®ä½œæˆ
my $test_db = 'test_todo.db';
unlink $test_db if -e $test_db;

# ç’°å¢ƒå¤‰æ•°ã‚’è¨­å®šã—ã¦ãƒ†ã‚¹ãƒˆç”¨DBã‚’ä½¿ç”¨
$ENV{TODO_DB} = $test_db;

# ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ãƒ­ãƒ¼ãƒ‰
my $app = do 'todo_server.pl';

test_psgi $app, sub {
    my $cb = shift;
    my $token;

    # ãƒ­ã‚°ã‚¤ãƒ³ãƒ†ã‚¹ãƒˆ
    {
        my $req = POST '/',
            Content_Type => 'application/json',
            Content => encode_json({
                jsonrpc => '2.0',
                method => 'user.login',
                params => {
                    username => 'demo',
                    password => 'demo123',
                },
                id => 1,
            });

        my $res = $cb->($req);
        is $res->code, 200, 'ãƒ­ã‚°ã‚¤ãƒ³ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒæˆåŠŸ';

        my $data = decode_json($res->content);
        ok exists $data->{result}{token}, 'ãƒˆãƒ¼ã‚¯ãƒ³ãŒè¿”ã•ã‚Œã‚‹';
        $token = $data->{result}{token};
    }

    # ã‚¿ã‚¹ã‚¯ä½œæˆãƒ†ã‚¹ãƒˆ
    my $task_id;
    {
        my $req = POST '/',
            Content_Type => 'application/json',
            Authorization => "Bearer $token",
            Content => encode_json({
                jsonrpc => '2.0',
                method => 'todo.create',
                params => {
                    title => 'ãƒ†ã‚¹ãƒˆã‚¿ã‚¹ã‚¯',
                    description => 'ã“ã‚Œã¯ãƒ†ã‚¹ãƒˆã§ã™',
                    priority => 'high',
                },
                id => 2,
            });

        my $res = $cb->($req);
        is $res->code, 200, 'ã‚¿ã‚¹ã‚¯ä½œæˆãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒæˆåŠŸ';

        my $data = decode_json($res->content);
        ok exists $data->{result}{id}, 'ã‚¿ã‚¹ã‚¯IDãŒè¿”ã•ã‚Œã‚‹';
        $task_id = $data->{result}{id};
        is $data->{result}{task}{title}, 'ãƒ†ã‚¹ãƒˆã‚¿ã‚¹ã‚¯', 'ã‚¿ã‚¤ãƒˆãƒ«ãŒæ­£ã—ã„';
    }

    # ã‚¿ã‚¹ã‚¯å–å¾—ãƒ†ã‚¹ãƒˆ
    {
        my $req = POST '/',
            Content_Type => 'application/json',
            Authorization => "Bearer $token",
            Content => encode_json({
                jsonrpc => '2.0',
                method => 'todo.get',
                params => { id => $task_id },
                id => 3,
            });

        my $res = $cb->($req);
        is $res->code, 200, 'ã‚¿ã‚¹ã‚¯å–å¾—ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒæˆåŠŸ';

        my $data = decode_json($res->content);
        is $data->{result}{task}{id}, $task_id, 'ã‚¿ã‚¹ã‚¯IDãŒä¸€è‡´';
        is $data->{result}{task}{priority}, 'high', 'å„ªå…ˆåº¦ãŒæ­£ã—ã„';
    }

    # ã‚¿ã‚¹ã‚¯ä¸€è¦§å–å¾—ãƒ†ã‚¹ãƒˆ
    {
        my $req = POST '/',
            Content_Type => 'application/json',
            Authorization => "Bearer $token",
            Content => encode_json({
                jsonrpc => '2.0',
                method => 'todo.list',
                params => {},
                id => 4,
            });

        my $res = $cb->($req);
        is $res->code, 200, 'ã‚¿ã‚¹ã‚¯ä¸€è¦§å–å¾—ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒæˆåŠŸ';

        my $data = decode_json($res->content);
        ok ref $data->{result}{tasks} eq 'ARRAY', 'ã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆãŒé…åˆ—';
        ok $data->{result}{total} >= 1, 'ã‚¿ã‚¹ã‚¯ãŒå­˜åœ¨ã™ã‚‹';
    }

    # ã‚¿ã‚¹ã‚¯æ›´æ–°ãƒ†ã‚¹ãƒˆ
    {
        my $req = POST '/',
            Content_Type => 'application/json',
            Authorization => "Bearer $token",
            Content => encode_json({
                jsonrpc => '2.0',
                method => 'todo.update',
                params => {
                    id => $task_id,
                    updates => {
                        status => 'completed',
                        title => 'æ›´æ–°ã•ã‚ŒãŸã‚¿ã‚¹ã‚¯',
                    },
                },
                id => 5,
            });

        my $res = $cb->($req);
        is $res->code, 200, 'ã‚¿ã‚¹ã‚¯æ›´æ–°ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒæˆåŠŸ';

        my $data = decode_json($res->content);
        is $data->{result}{task}{status}, 'completed', 'ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒæ›´æ–°ã•ã‚ŒãŸ';
        is $data->{result}{task}{title}, 'æ›´æ–°ã•ã‚ŒãŸã‚¿ã‚¹ã‚¯', 'ã‚¿ã‚¤ãƒˆãƒ«ãŒæ›´æ–°ã•ã‚ŒãŸ';
    }

    # ãƒãƒƒãƒæ›´æ–°ãƒ†ã‚¹ãƒˆ
    {
        # è¿½åŠ ã®ã‚¿ã‚¹ã‚¯ã‚’ä½œæˆ
        my @task_ids = ($task_id);
        for my $i (1..2) {
            my $req = POST '/',
                Content_Type => 'application/json',
                Authorization => "Bearer $token",
                Content => encode_json({
                    jsonrpc => '2.0',
                    method => 'todo.create',
                    params => { title => "ãƒãƒƒãƒãƒ†ã‚¹ãƒˆ$i" },
                    id => 10 + $i,
                });
            
            my $res = $cb->($req);
            my $data = decode_json($res->content);
            push @task_ids, $data->{result}{id};
        }

        # ãƒãƒƒãƒæ›´æ–°å®Ÿè¡Œ
        my $req = POST '/',
            Content_Type => 'application/json',
            Authorization => "Bearer $token",
            Content => encode_json({
                jsonrpc => '2.0',
                method => 'todo.batchUpdate',
                params => {
                    tasks => [
                        map { { id => $_, updates => { priority => 'low' } } } @task_ids
                    ],
                },
                id => 6,
            });

        my $res = $cb->($req);
        is $res->code, 200, 'ãƒãƒƒãƒæ›´æ–°ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒæˆåŠŸ';

        my $data = decode_json($res->content);
        is $data->{result}{count}, scalar(@task_ids), 'å…¨ã‚¿ã‚¹ã‚¯ãŒæ›´æ–°ã•ã‚ŒãŸ';
    }

    # æ¤œç´¢ãƒ†ã‚¹ãƒˆ
    {
        my $req = POST '/',
            Content_Type => 'application/json',
            Authorization => "Bearer $token",
            Content => encode_json({
                jsonrpc => '2.0',
                method => 'todo.search',
                params => { query => 'ãƒ†ã‚¹ãƒˆ' },
                id => 7,
            });

        my $res = $cb->($req);
        is $res->code, 200, 'æ¤œç´¢ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒæˆåŠŸ';

        my $data = decode_json($res->content);
        ok $data->{result}{total} >= 1, 'æ¤œç´¢çµæœãŒè¿”ã•ã‚Œã‚‹';
    }

    # çµ±è¨ˆæƒ…å ±ãƒ†ã‚¹ãƒˆ
    {
        my $req = POST '/',
            Content_Type => 'application/json',
            Authorization => "Bearer $token",
            Content => encode_json({
                jsonrpc => '2.0',
                method => 'todo.stats',
                params => {},
                id => 8,
            });

        my $res = $cb->($req);
        is $res->code, 200, 'çµ±è¨ˆæƒ…å ±ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒæˆåŠŸ';

        my $data = decode_json($res->content);
        ok exists $data->{result}{total}, 'ç·æ•°ãŒå«ã¾ã‚Œã‚‹';
        ok exists $data->{result}{completion_rate}, 'å®Œäº†ç‡ãŒå«ã¾ã‚Œã‚‹';
    }

    # ã‚¿ã‚¹ã‚¯å‰Šé™¤ãƒ†ã‚¹ãƒˆ
    {
        my $req = POST '/',
            Content_Type => 'application/json',
            Authorization => "Bearer $token",
            Content => encode_json({
                jsonrpc => '2.0',
                method => 'todo.delete',
                params => { id => $task_id },
                id => 9,
            });

        my $res = $cb->($req);
        is $res->code, 200, 'ã‚¿ã‚¹ã‚¯å‰Šé™¤ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒæˆåŠŸ';
    }

    # èªè¨¼ãªã—ã§ã®ã‚¢ã‚¯ã‚»ã‚¹ãƒ†ã‚¹ãƒˆï¼ˆå¤±æ•—ã™ã‚‹ã¯ãšï¼‰
    {
        my $req = POST '/',
            Content_Type => 'application/json',
            Content => encode_json({
                jsonrpc => '2.0',
                method => 'todo.list',
                params => {},
                id => 10,
            });

        my $res = $cb->($req);
        is $res->code, 401, 'èªè¨¼ãªã—ã§ã¯ã‚¢ã‚¯ã‚»ã‚¹ã§ããªã„';
    }
};

# ãƒ†ã‚¹ãƒˆç”¨DBã‚’å‰Šé™¤
unlink $test_db if -e $test_db;

done_testing();
```

### ãƒ†ã‚¹ãƒˆã®å®Ÿè¡Œ

```bash
# å¿…è¦ãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
cpanm Test::More Test::Exception Plack::Test

# ãƒ†ã‚¹ãƒˆã®å®Ÿè¡Œ
prove -lv test/todo_api.t
```

## ãƒ‡ãƒ—ãƒ­ã‚¤æº–å‚™

æœ¬ç•ªç’°å¢ƒã¸ã®ãƒ‡ãƒ—ãƒ­ã‚¤ã«å¿…è¦ãªã‚¹ã‚¯ãƒªãƒ—ãƒˆã¨è¨­å®šã‚’ç”¨æ„ã—ã¾ã™ã€‚

### deploy/setup.sh

```bash
#!/bin/bash
# ToDoã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚¹ã‚¯ãƒªãƒ—ãƒˆ

set -e

echo "=== ToDoãƒªã‚¹ãƒˆç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ— ==="

# å¿…è¦ãªPerlãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
echo "Perlãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ä¸­..."
cpanm --installdeps .

# ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®åˆæœŸåŒ–
echo "ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®åˆæœŸåŒ–ä¸­..."
sqlite3 todo.db < schema.sql

# è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚³ãƒ”ãƒ¼
if [ ! -f config.pl ]; then
    echo "è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆä¸­..."
    cat > config.pl << 'CONFIG'
use strict;
use warnings;

our %CONFIG = (
    database => $ENV{TODO_DB} || 'todo.db',
    secret_key => $ENV{SECRET_KEY} || 'change_this_in_production',
    token_expiry => 86400,  # 24æ™‚é–“
    cors_origin => $ENV{CORS_ORIGIN} || '*',
);

1;
CONFIG
fi

echo "ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—å®Œäº†ï¼"
echo ""
echo "ã‚µãƒ¼ãƒãƒ¼ã‚’èµ·å‹•ã™ã‚‹ã«ã¯:"
echo "  plackup --port 5000 todo_server.pl"
echo ""
echo "Webãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã‚’èµ·å‹•ã™ã‚‹ã«ã¯:"
echo "  cd public && python3 -m http.server 3000"
```

### deploy/start_production.sh

```bash
#!/bin/bash
# æœ¬ç•ªç’°å¢ƒç”¨èµ·å‹•ã‚¹ã‚¯ãƒªãƒ—ãƒˆ

set -e

# ç’°å¢ƒå¤‰æ•°ã®è¨­å®š
export PLACK_ENV=production
export TODO_DB=todo.db
export SECRET_KEY=$(openssl rand -hex 32)

# Starmanã§èµ·å‹•ï¼ˆé«˜æ€§èƒ½ãªPSGIã‚µãƒ¼ãƒãƒ¼ï¼‰
starman \
    --workers 4 \
    --port 5000 \
    --pid /var/run/todo_server.pid \
    --daemonize \
    --error-log /var/log/todo_server.error.log \
    --access-log /var/log/todo_server.access.log \
    todo_server.pl

echo "ã‚µãƒ¼ãƒãƒ¼ã‚’èµ·å‹•ã—ã¾ã—ãŸ (PID: $(cat /var/run/todo_server.pid))"
```

### deploy/stop_production.sh

```bash
#!/bin/bash
# æœ¬ç•ªç’°å¢ƒç”¨åœæ­¢ã‚¹ã‚¯ãƒªãƒ—ãƒˆ

PID_FILE=/var/run/todo_server.pid

if [ -f $PID_FILE ]; then
    PID=$(cat $PID_FILE)
    kill $PID
    rm $PID_FILE
    echo "ã‚µãƒ¼ãƒãƒ¼ã‚’åœæ­¢ã—ã¾ã—ãŸ (PID: $PID)"
else
    echo "ã‚µãƒ¼ãƒãƒ¼ã¯å®Ÿè¡Œã•ã‚Œã¦ã„ã¾ã›ã‚“"
fi
```

### cpanfile (ä¾å­˜é–¢ä¿‚ã®å®šç¾©)

```perl
requires 'Plack', '1.0047';
requires 'JSON::RPC::Spec', '1.02';
requires 'DBI', '1.643';
requires 'DBD::SQLite', '1.70';
requires 'Digest::SHA', '6.02';
requires 'JSON', '4.10';
requires 'Plack::Middleware::CrossOrigin', '0.014';

on 'test' => sub {
    requires 'Test::More', '1.302';
    requires 'Test::Exception', '0.43';
    requires 'Plack::Test', '0';
    requires 'HTTP::Request::Common', '6.43';
};
```

## ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã¨ãƒ‘ã‚¿ãƒ¼ãƒ³

ã“ã®å®Ÿè£…ã§æ¡ç”¨ã—ãŸè¨­è¨ˆãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã‚’ã¾ã¨ã‚ã¾ã™ã€‚

### 1. APIè¨­è¨ˆã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

#### æ˜ç¢ºãªå‘½åè¦å‰‡

```
ãƒªã‚½ãƒ¼ã‚¹.ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å½¢å¼
- user.login, user.logout
- todo.create, todo.get, todo.list, todo.update, todo.delete
```

#### ä¸€è²«æ€§ã®ã‚ã‚‹ãƒ¬ã‚¹ãƒãƒ³ã‚¹å½¢å¼

```json
{
  "result": {
    "task": {...},
    "metadata": {...}
  }
}
```

### 2. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

- **ãƒˆãƒ¼ã‚¯ãƒ³ãƒ™ãƒ¼ã‚¹èªè¨¼**: ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¬ã‚¹ã§æ‹¡å¼µæ€§ã®é«˜ã„èªè¨¼
- **ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒãƒƒã‚·ãƒ¥åŒ–**: SHA-1ï¼ˆæœ¬ç•ªã§ã¯bcryptæ¨å¥¨ï¼‰
- **SQL ã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¯¾ç­–**: ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã®ä½¿ç”¨
- **CORSè¨­å®š**: é©åˆ‡ãªã‚ªãƒªã‚¸ãƒ³åˆ¶é™

### 3. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­è¨ˆã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

- **ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®æ´»ç”¨**: é »ç¹ã«æ¤œç´¢ã•ã‚Œã‚‹ã‚«ãƒ©ãƒ ã«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
- **è«–ç†å‰Šé™¤**: ãƒ‡ãƒ¼ã‚¿ã®å±¥æ­´ä¿æŒ
- **ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—**: ä½œæˆæ—¥æ™‚ã¨æ›´æ–°æ—¥æ™‚ã®è¨˜éŒ²
- **å¤–éƒ¨ã‚­ãƒ¼åˆ¶ç´„**: ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ã®ä¿è¨¼

### 4. ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

```perl
die JSON::RPC::Spec::Error->new(
    code => -32602,
    message => "ã‚ã‹ã‚Šã‚„ã™ã„ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸",
);
```

## é€£è¼‰å…¨ä½“ã®ã¾ã¨ã‚

12å›ã«ã‚ãŸã‚‹é€£è¼‰ã‚’é€šã˜ã¦ã€JSON-RPC 2.0ã¨Perlã‚’ä½¿ã£ãŸWebã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³é–‹ç™ºã®å…¨ä½“åƒã‚’å­¦ã³ã¾ã—ãŸã€‚

### å­¦ã‚“ã ä¸»è¦ãªãƒˆãƒ”ãƒƒã‚¯

1. **ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®åŸºç¤**
   - JSON-RPC 2.0ã®ä»•æ§˜
   - ãƒªã‚¯ã‚¨ã‚¹ãƒˆ/ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®æ§‹é€ 
   - ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

2. **å®Ÿè£…ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯**
   - ãƒ¡ã‚½ãƒƒãƒ‰ã®ç™»éŒ²ã¨å®Ÿè£…
   - ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®æ‰±ã„æ–¹
   - ãƒãƒƒãƒå‡¦ç†ã¨é€šçŸ¥

3. **å®Ÿè·µçš„ãªæ©Ÿèƒ½**
   - èªè¨¼ã¨èªå¯
   - ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹é€£æº
   - PSGI/Plackã¨ã®çµ±åˆ

4. **ãƒ•ãƒ«ã‚¹ã‚¿ãƒƒã‚¯é–‹ç™º**
   - ã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰å®Ÿè£…
   - ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰å®Ÿè£…
   - ãƒ†ã‚¹ãƒˆã¨ãƒ‡ãƒ—ãƒ­ã‚¤

### JSON-RPCã‚’é¸ã¶ã¹ãã‚±ãƒ¼ã‚¹

JSON-RPCãŒç‰¹ã«é©ã—ã¦ã„ã‚‹ã®ã¯ï¼š

- **æ˜ç¢ºãªã‚¢ã‚¯ã‚·ãƒ§ãƒ³æŒ‡å‘ã®API**: ãƒ¡ã‚½ãƒƒãƒ‰å‘¼ã³å‡ºã—ãŒè‡ªç„¶ã«ãƒãƒƒãƒ—ã•ã‚Œã‚‹
- **ãƒãƒƒãƒå‡¦ç†ãŒå¿…è¦**: è¤‡æ•°ã®æ“ä½œã‚’ä¸€åº¦ã«å®Ÿè¡Œã—ãŸã„
- **å³å¯†ãªå‹ä»˜ã‘ã¨ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³**: æ˜ç¤ºçš„ãªãƒ¡ã‚½ãƒƒãƒ‰ã‚·ã‚°ãƒãƒãƒ£
- **ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é€šä¿¡**: WebSocketã¨ã®çµ„ã¿åˆã‚ã›
- **å†…éƒ¨ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹**: ã‚µãƒ¼ãƒ“ã‚¹é–“é€šä¿¡

### Perlã§JSON-RPCã‚’å®Ÿè£…ã™ã‚‹ãƒ¡ãƒªãƒƒãƒˆ

- **æˆç†Ÿã—ãŸã‚¨ã‚³ã‚·ã‚¹ãƒ†ãƒ **: CPANã®è±Šå¯Œãªãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
- **é«˜ã„ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹**: åŠ¹ç‡çš„ãªãƒ†ã‚­ã‚¹ãƒˆå‡¦ç†
- **æŸ”è»Ÿæ€§**: å‹•çš„ãªè¨€èªç‰¹æ€§
- **å®‰å®šæ€§**: é•·å¹´ã®å®Ÿç¸¾

## ã•ã‚‰ã«å­¦ã¶ãŸã‚ã®ãƒªã‚½ãƒ¼ã‚¹

### å…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

- [JSON-RPC 2.0 Specification](https://www.jsonrpc.org/specification)
- [JSON::RPC::Spec - CPAN](https://metacpan.org/pod/JSON::RPC::Spec)
- [Plack Documentation](https://plackperl.org/)

### ãŠã™ã™ã‚ã®æ›¸ç±

- ã€ŒWebã‚’æ”¯ãˆã‚‹æŠ€è¡“ã€- HTTPã€URIã€HTMLã‚’å­¦ã¶
- ã€Œåˆã‚ã¦ã®Perlã€- Perlè¨€èªã®åŸºç¤
- ã€Œãƒã‚¤ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ–ãƒ©ã‚¦ã‚¶ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚­ãƒ³ã‚°ã€- ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æœ€é©åŒ–

### ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£

- [Perl Mongers](https://www.pm.org/) - Perlã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£
- [CPAN](https://metacpan.org/) - Perlãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒªãƒã‚¸ãƒˆãƒª
- [Stack Overflow](https://stackoverflow.com/questions/tagged/json-rpc) - Q&Aãƒ•ã‚©ãƒ¼ãƒ©ãƒ 

### æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—

ã“ã®é€£è¼‰ã§å­¦ã‚“ã çŸ¥è­˜ã‚’ãƒ™ãƒ¼ã‚¹ã«ã€æ¬¡ã®ã‚ˆã†ãªç™ºå±•çš„ãªãƒˆãƒ”ãƒƒã‚¯ã«æŒ‘æˆ¦ã§ãã¾ã™ï¼š

1. **ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é€šä¿¡**
   - WebSocketã‚’ä½¿ã£ãŸJSON-RPC
   - Server-Sent Events (SSE) ã¨ã®çµ±åˆ

2. **ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£**
   - ã‚µãƒ¼ãƒ“ã‚¹é–“é€šä¿¡ã§ã®JSON-RPCæ´»ç”¨
   - ã‚µãƒ¼ãƒ“ã‚¹ãƒ‡ã‚£ã‚¹ã‚«ãƒãƒªãƒ¼ã¨ã®çµ±åˆ

3. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–**
   - æ¥ç¶šãƒ—ãƒ¼ãƒªãƒ³ã‚°
   - ã‚­ãƒ£ãƒƒã‚·ãƒ³ã‚°æˆ¦ç•¥
   - éåŒæœŸå‡¦ç†

4. **é«˜åº¦ãªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£**
   - OAuth 2.0çµ±åˆ
   - JWT (JSON Web Tokens)
   - ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã¨DDoSå¯¾ç­–

## ãŠã‚ã‚Šã«

12å›ã«ã‚ãŸã‚‹é€£è¼‰ã€ã“ã“ã¾ã§èª­ã‚“ã§ã„ãŸã ãã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã—ãŸã€‚

JSON-RPC 2.0ã¯ã€ã‚·ãƒ³ãƒ—ãƒ«ã§ã‚ã‚ŠãªãŒã‚‰å¼·åŠ›ãªãƒ—ãƒ­ãƒˆã‚³ãƒ«ã§ã™ã€‚RESTful APIã¨æ¯”è¼ƒã—ã¦éå°è©•ä¾¡ã•ã‚ŒãŒã¡ã§ã™ãŒã€é©åˆ‡ãªãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ã§ã¯éå¸¸ã«åŠ¹æœçš„ãªé¸æŠè‚¢ã¨ãªã‚Šã¾ã™ã€‚

Perlã¨ã®çµ„ã¿åˆã‚ã›ã¯ã€ç‰¹ã«ãƒ¬ã‚¬ã‚·ãƒ¼ã‚·ã‚¹ãƒ†ãƒ ã®çµ±åˆã‚„ã€ãƒ†ã‚­ã‚¹ãƒˆå‡¦ç†ãŒä¸­å¿ƒã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§çœŸä¾¡ã‚’ç™ºæ®ã—ã¾ã™ã€‚JSON::RPC::Specãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®æ´—ç·´ã•ã‚ŒãŸAPIã¨ã€Plackã®æŸ”è»ŸãªãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢ã‚·ã‚¹ãƒ†ãƒ ã«ã‚ˆã‚Šã€æœ¬ç•ªç’°å¢ƒã§ä½¿ãˆã‚‹å …ç‰¢ãªã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æ§‹ç¯‰ã§ãã¾ã™ã€‚

ã“ã®é€£è¼‰ã§ä½œæˆã—ãŸToDoãƒªã‚¹ãƒˆç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã¯ã€å®Ÿç”¨çš„ãªã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®å‡ºç™ºç‚¹ã§ã™ã€‚ã“ã“ã‹ã‚‰æ©Ÿèƒ½ã‚’è¿½åŠ ã—ãŸã‚Šã€ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã‚’æ”¹å–„ã—ãŸã‚Šã—ã¦ã€ã‚ãªãŸç‹¬è‡ªã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«ç™ºå±•ã•ã›ã¦ãã ã•ã„ã€‚

JSON-RPCã¨Perlã®å¯èƒ½æ€§ã¯ã€ã“ã®é€£è¼‰ã§ç´¹ä»‹ã—ãŸã‚‚ã®ã ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã‚ãªãŸè‡ªèº«ã®æ‰‹ã§ã€ã•ã‚‰ã«ç´ æ™´ã‚‰ã—ã„ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½œã‚Šä¸Šã’ã¦ãã ã•ã„ã€‚

ãã‚Œã§ã¯ã€Happy Coding!

[@nqounet](https://x.com/nqounet)ã§ã—ãŸã€‚
