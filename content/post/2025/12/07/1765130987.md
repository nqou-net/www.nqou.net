---
title: "メソッドの実装 - 引数と戻り値を理解する"
description: "位置パラメータと名前付きパラメータの両方を受け取れるメソッドを実装し、JSON-RPC 2.0の柔軟なパラメータ渡しを体験します。"
tags:
  - json-rpc
  - perl
  - parameters
  - methods
  - api-design
draft: true
---

[@nqounet](https://x.com/nqounet)です。

前回の記事では、引数を受け取らない最もシンプルな`hello`メソッドを実装しました。しかし実用的なアプリケーションでは、パラメータを受け取り、それに基づいて処理を行う必要があります。

JSON-RPC 2.0の大きな特徴の一つは、パラメータの渡し方に柔軟性があることです。位置パラメータ（配列形式）と名前付きパラメータ（オブジェクト形式）の両方をサポートしており、実装者は用途に応じて選択できます。

今回は、計算機能を持つメソッドを実装しながら、この柔軟なパラメータ渡しの仕組みを深く理解していきましょう。

## JSON-RPC 2.0のパラメータ仕様

まず、JSON-RPC 2.0の仕様におけるパラメータの定義を確認しましょう。

仕様書によれば、`params`フィールドは以下の3つの形式を取ることができます：

1. **配列（位置パラメータ）**
2. **オブジェクト（名前付きパラメータ）**
3. **省略（パラメータなし）**

### 位置パラメータ（配列形式）

配列形式では、パラメータは順序によって意味が決まります：

```json
{
  "jsonrpc": "2.0",
  "method": "subtract",
  "params": [42, 23],
  "id": 1
}
```

この場合、最初の要素が第1引数、次の要素が第2引数として扱われます。プログラミング言語の関数呼び出しに似た、直感的な方法です。

### 名前付きパラメータ（オブジェクト形式）

オブジェクト形式では、パラメータは名前で識別されます：

```json
{
  "jsonrpc": "2.0",
  "method": "subtract",
  "params": {"minuend": 42, "subtrahend": 23},
  "id": 1
}
```

順序に依存しないため、パラメータの意味が明確になり、オプションパラメータの扱いも容易になります。

## 位置パラメータを受け取るメソッドの実装

まずは位置パラメータで計算を行うメソッドを実装してみましょう。新しく`calc_server.pl`を作成します：

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use JSON::RPC::Spec;

my $rpc = JSON::RPC::Spec->new;

# 加算メソッド（位置パラメータ版）
$rpc->register(
    add => sub {
        my ($params) = @_;
        
        # 配列として受け取る
        unless (ref $params eq 'ARRAY') {
            die "Parameters must be an array";
        }
        
        # 2つの引数が必要
        unless (@$params == 2) {
            die "add requires exactly 2 parameters";
        }
        
        my ($a, $b) = @$params;
        return $a + $b;
    }
);

# 減算メソッド（位置パラメータ版）
$rpc->register(
    subtract => sub {
        my ($params) = @_;
        
        unless (ref $params eq 'ARRAY') {
            die "Parameters must be an array";
        }
        
        unless (@$params == 2) {
            die "subtract requires exactly 2 parameters";
        }
        
        my ($minuend, $subtrahend) = @$params;
        return $minuend - $subtrahend;
    }
);

my $app = sub {
    my ($env) = @_;
    return $rpc->handle($env);
};
```

### コードの解説

1. **パラメータの型チェック**
   - `ref $params eq 'ARRAY'`で配列であることを確認しています
   - 配列でない場合は例外を投げます

2. **引数の数のチェック**
   - `@$params == 2`で要素数が2であることを確認しています
   - 必須パラメータの検証は重要です

3. **配列からの値の取り出し**
   - `my ($a, $b) = @$params`で配列の要素を変数に代入します
   - Perlのリスト代入の機能を活用しています

### クライアントで呼び出してみる

`calc_client_positional.pl`を作成して動作確認しましょう：

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use JSON::RPC::Spec::Client;

my $client = JSON::RPC::Spec::Client->new(
    url => 'http://localhost:5000/'
);

# 位置パラメータで加算を呼び出す
my $result1 = $client->call('add', [10, 5]);

if ($result1->is_success) {
    print "10 + 5 = ", $result1->result, "\n";
} else {
    print "Error: ", $result1->error->{message}, "\n";
}

# 位置パラメータで減算を呼び出す
my $result2 = $client->call('subtract', [42, 23]);

if ($result2->is_success) {
    print "42 - 23 = ", $result2->result, "\n";
} else {
    print "Error: ", $result2->error->{message}, "\n";
}
```

サーバーを起動してクライアントを実行すると：

```bash
# ターミナル1
plackup calc_server.pl

# ターミナル2
perl calc_client_positional.pl
```

以下のような出力が得られます：

```
10 + 5 = 15
42 - 23 = 19
```

## 名前付きパラメータを受け取るメソッドの実装

次は、名前付きパラメータに対応したバージョンを作成します。`calc_server_named.pl`を作成しましょう：

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use JSON::RPC::Spec;

my $rpc = JSON::RPC::Spec->new;

# 加算メソッド（名前付きパラメータ版）
$rpc->register(
    add => sub {
        my ($params) = @_;
        
        # オブジェクト（ハッシュリファレンス）として受け取る
        unless (ref $params eq 'HASH') {
            die "Parameters must be an object";
        }
        
        # 必須パラメータの存在確認
        unless (exists $params->{a} && exists $params->{b}) {
            die "add requires 'a' and 'b' parameters";
        }
        
        return $params->{a} + $params->{b};
    }
);

# 減算メソッド（名前付きパラメータ版）
$rpc->register(
    subtract => sub {
        my ($params) = @_;
        
        unless (ref $params eq 'HASH') {
            die "Parameters must be an object";
        }
        
        unless (exists $params->{minuend} && exists $params->{subtrahend}) {
            die "subtract requires 'minuend' and 'subtrahend' parameters";
        }
        
        return $params->{minuend} - $params->{subtrahend};
    }
);

my $app = sub {
    my ($env) = @_;
    return $rpc->handle($env);
};
```

### 名前付きパラメータの利点

1. **パラメータの意味が明確**
   - `{minuend: 42, subtrahend: 23}`は何を引いているのか一目瞭然
   - `[42, 23]`よりも可読性が高い

2. **順序に依存しない**
   - `{b: 5, a: 10}`と`{a: 10, b: 5}`は同じ結果になる
   - パラメータの追加や変更に強い

3. **オプションパラメータの扱いが容易**
   - デフォルト値の設定が簡単
   - 一部のパラメータを省略可能にできる

### クライアントで呼び出してみる

`calc_client_named.pl`を作成します：

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use JSON::RPC::Spec::Client;

my $client = JSON::RPC::Spec::Client->new(
    url => 'http://localhost:5000/'
);

# 名前付きパラメータで加算を呼び出す
my $result1 = $client->call('add', {a => 10, b => 5});

if ($result1->is_success) {
    print "10 + 5 = ", $result1->result, "\n";
} else {
    print "Error: ", $result1->error->{message}, "\n";
}

# 名前付きパラメータで減算を呼び出す（順序を変えても同じ結果）
my $result2 = $client->call('subtract', {
    subtrahend => 23,
    minuend => 42
});

if ($result2->is_success) {
    print "42 - 23 = ", $result2->result, "\n";
} else {
    print "Error: ", $result2->error->{message}, "\n";
}
```

## 両方のパラメータ形式に対応する

より柔軟な実装として、両方のパラメータ形式に対応したメソッドを作成してみましょう。`calc_server_flexible.pl`を作成します：

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use JSON::RPC::Spec;

my $rpc = JSON::RPC::Spec->new;

# 両形式に対応した加算メソッド
$rpc->register(
    add => sub {
        my ($params) = @_;
        
        my ($a, $b);
        
        if (ref $params eq 'ARRAY') {
            # 位置パラメータの場合
            unless (@$params == 2) {
                die "add requires exactly 2 parameters";
            }
            ($a, $b) = @$params;
            
        } elsif (ref $params eq 'HASH') {
            # 名前付きパラメータの場合
            unless (exists $params->{a} && exists $params->{b}) {
                die "add requires 'a' and 'b' parameters";
            }
            $a = $params->{a};
            $b = $params->{b};
            
        } else {
            die "Invalid parameter type";
        }
        
        return $a + $b;
    }
);

# 両形式に対応した減算メソッド
$rpc->register(
    subtract => sub {
        my ($params) = @_;
        
        my ($minuend, $subtrahend);
        
        if (ref $params eq 'ARRAY') {
            unless (@$params == 2) {
                die "subtract requires exactly 2 parameters";
            }
            ($minuend, $subtrahend) = @$params;
            
        } elsif (ref $params eq 'HASH') {
            unless (exists $params->{minuend} && exists $params->{subtrahend}) {
                die "subtract requires 'minuend' and 'subtrahend' parameters";
            }
            $minuend = $params->{minuend};
            $subtrahend = $params->{subtrahend};
            
        } else {
            die "Invalid parameter type";
        }
        
        return $minuend - $subtrahend;
    }
);

my $app = sub {
    my ($env) = @_;
    return $rpc->handle($env);
};
```

この実装により、クライアントは好きな形式でパラメータを渡せるようになります。

## 構造化された戻り値の実装

これまでは単純な数値を返していましたが、より実用的な情報を返すために、オブジェクトや配列を返すメソッドを実装してみましょう。

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use JSON::RPC::Spec;

my $rpc = JSON::RPC::Spec->new;

# 計算結果を詳細情報とともに返すメソッド
$rpc->register(
    calculate => sub {
        my ($params) = @_;
        
        my ($a, $b, $operation);
        
        if (ref $params eq 'ARRAY') {
            unless (@$params == 3) {
                die "calculate requires 3 parameters: a, b, operation";
            }
            ($a, $b, $operation) = @$params;
            
        } elsif (ref $params eq 'HASH') {
            unless (exists $params->{a} && exists $params->{b} && exists $params->{operation}) {
                die "calculate requires 'a', 'b', and 'operation' parameters";
            }
            $a = $params->{a};
            $b = $params->{b};
            $operation = $params->{operation};
            
        } else {
            die "Invalid parameter type";
        }
        
        my $result;
        
        if ($operation eq 'add') {
            $result = $a + $b;
        } elsif ($operation eq 'subtract') {
            $result = $a - $b;
        } elsif ($operation eq 'multiply') {
            $result = $a * $b;
        } elsif ($operation eq 'divide') {
            if ($b == 0) {
                die "Division by zero";
            }
            $result = $a / $b;
        } else {
            die "Unknown operation: $operation";
        }
        
        # 構造化された結果を返す
        return {
            operand1 => $a,
            operand2 => $b,
            operation => $operation,
            result => $result,
            expression => "$a $operation $b = $result"
        };
    }
);

# 複数の計算を一度に実行するメソッド
$rpc->register(
    batch_calculate => sub {
        my ($params) = @_;
        
        unless (ref $params eq 'ARRAY') {
            die "batch_calculate requires an array of calculations";
        }
        
        my @results;
        
        for my $calc (@$params) {
            unless (ref $calc eq 'HASH') {
                die "Each calculation must be an object";
            }
            
            my $a = $calc->{a};
            my $b = $calc->{b};
            my $op = $calc->{operation};
            
            my $result;
            
            if ($op eq 'add') {
                $result = $a + $b;
            } elsif ($op eq 'subtract') {
                $result = $a - $b;
            } elsif ($op eq 'multiply') {
                $result = $a * $b;
            } elsif ($op eq 'divide') {
                $result = $b != 0 ? $a / $b : undef;
            }
            
            push @results, {
                input => $calc,
                result => $result
            };
        }
        
        # 配列を返す
        return \@results;
    }
);

my $app = sub {
    my ($env) = @_;
    return $rpc->handle($env);
};
```

### 構造化された戻り値を受け取るクライアント

`calc_client_structured.pl`を作成します：

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use JSON::RPC::Spec::Client;
use Data::Dumper;

my $client = JSON::RPC::Spec::Client->new(
    url => 'http://localhost:5000/'
);

# オブジェクトを返すメソッドの呼び出し
my $result1 = $client->call('calculate', {
    a => 15,
    b => 3,
    operation => 'multiply'
});

if ($result1->is_success) {
    my $data = $result1->result;
    print "Result: ", $data->{result}, "\n";
    print "Expression: ", $data->{expression}, "\n";
    print "\nFull response:\n";
    print Dumper($data);
} else {
    print "Error: ", $result1->error->{message}, "\n";
}

print "\n", "=" x 50, "\n\n";

# 配列を返すメソッドの呼び出し
my $result2 = $client->call('batch_calculate', [
    {a => 10, b => 5, operation => 'add'},
    {a => 20, b => 4, operation => 'divide'},
    {a => 7, b => 3, operation => 'subtract'}
]);

if ($result2->is_success) {
    my $results = $result2->result;
    
    for my $item (@$results) {
        my $input = $item->{input};
        my $result = $item->{result};
        
        printf "%d %s %d = %s\n",
            $input->{a},
            $input->{operation},
            $input->{b},
            defined $result ? $result : 'ERROR';
    }
} else {
    print "Error: ", $result2->error->{message}, "\n";
}
```

実行すると、以下のような出力が得られます：

```
Result: 45
Expression: 15 multiply 3 = 45

Full response:
$VAR1 = {
          'operand1' => 15,
          'operand2' => 3,
          'operation' => 'multiply',
          'result' => 45,
          'expression' => '15 multiply 3 = 45'
        };

==================================================

10 add 5 = 15
20 divide 4 = 5
7 subtract 3 = 4
```

## 実装のベストプラクティス

実際にメソッドを実装する際のベストプラクティスをまとめます。

### 1. パラメータの検証は徹底する

```perl
# 良い例：明確なエラーメッセージ
unless (exists $params->{required_field}) {
    die "Missing required parameter: required_field";
}

# 悪い例：エラーメッセージが不明確
die "Invalid parameters" if !$params->{required_field};
```

### 2. 両形式に対応する場合は一貫性を保つ

```perl
# 位置パラメータ: [value1, value2, value3]
# 名前付きパラメータ: {field1: value1, field2: value2, field3: value3}
# 順序と名前を対応させる
```

### 3. 戻り値の構造を文書化する

```perl
# 戻り値:
# {
#   result: 数値,
#   metadata: {
#     calculation_time: ミリ秒,
#     version: 文字列
#   }
# }
```

### 4. エラーは適切に投げる

```perl
# die で投げられた例外は JSON::RPC::Spec が適切にエラーレスポンスに変換します
die "Division by zero" if $divisor == 0;
```

## まとめ

この記事では、JSON-RPC 2.0におけるパラメータと戻り値の扱い方を詳しく学びました：

- 位置パラメータ（配列形式）でのメソッド実装
- 名前付きパラメータ（オブジェクト形式）でのメソッド実装
- 両方の形式に対応する柔軟な実装
- 構造化された戻り値（オブジェクトや配列）の実装
- 実用的な計算機メソッド群の実装

JSON-RPC 2.0の柔軟性により、APIの使いやすさと実装の簡潔さを両立できることが理解できたと思います。

次回は、エラーハンドリングとバリデーションについて深掘りします。適切なエラー処理は、堅牢なAPIを構築する上で欠かせない要素です。

実際のコードを動かしながら、パラメータの渡し方による違いや、構造化された戻り値の扱いを体感してみてください。

## 参考リンク

- {{< linkcard "https://www.jsonrpc.org/specification" >}}
- {{< linkcard "https://metacpan.org/pod/JSON::RPC::Spec" >}}
