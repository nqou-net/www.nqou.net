---
title: "JSON-RPC 2.0への招待 - なぜ今、JSON-RPCなのか"
description: "REST APIとの違いを明確にしながら、JSON-RPC 2.0の基本概念とメリット、プロトコルの美しさと実用性を解説します。"
tags:
  - json-rpc
  - perl
  - api
  - rpc
  - web-api
draft: true
---

[@nqounet](https://x.com/nqounet)です。

外部サービスのAPIと通信するとき、curlコマンドで動作確認をした後、実際のプログラムに組み込む作業をしたことがある方は多いのではないでしょうか。

REST APIが主流の現在、エンドポイントごとにHTTPメソッドやパラメータの渡し方が異なり、それぞれに対応したコードを書く必要があります。「もっとシンプルに、統一的に扱えたらいいのに」と感じたことはありませんか？

そんな課題を解決する選択肢の一つが、JSON-RPC 2.0です。

この連載では、JSON-RPC 2.0の仕様を読み解きながら、Perlを使った実装を通じて、プロトコルの美しさと実用性を体験していきます。

## JSON-RPC 2.0とは何か

JSON-RPC 2.0は、JSONをデータフォーマットとして使用する、軽量なリモートプロシージャコール（RPC）プロトコルです。2010年に仕様が策定され、シンプルながら実用的な設計で、現在も多くのシステムで採用されています。

公式仕様書はこちらです：

{{< linkcard "https://www.jsonrpc.org/specification" >}}

RPCとは「Remote Procedure Call」の略で、ネットワーク越しに別のプログラムの関数（プロシージャ）を呼び出す仕組みです。つまり、JSON-RPC 2.0を使えば、遠隔地にあるサーバーの機能を、まるで自分のプログラムの関数を呼ぶかのように扱えます。

## REST APIとの違い

REST APIとJSON-RPC 2.0は、どちらもHTTPを利用したクライアント・サーバー間の通信方法ですが、設計思想が大きく異なります。

### REST APIの特徴

REST APIは、リソース（データ）を中心に設計されます：

- エンドポイントがリソースを表現する（例：`/users/123`、`/products`）
- HTTPメソッド（GET、POST、PUT、DELETE）で操作を表現する
- ステートレスな通信を重視する

例えば、ユーザー情報を取得する場合：

```bash
curl -X GET https://api.example.com/users/123
```

ユーザーを作成する場合：

```bash
curl -X POST https://api.example.com/users \
  -H "Content-Type: application/json" \
  -d '{"name":"Taro Yamada","email":"taro@example.com"}'
```

このように、リソースの種類や操作によってエンドポイントやHTTPメソッドが変わります。

### JSON-RPC 2.0の特徴

一方、JSON-RPC 2.0は、関数呼び出しを中心に設計されます：

- エンドポイントは通常1つ（すべてのリクエストが同じURL）
- HTTPメソッドは基本的にPOSTのみ
- 呼び出したいメソッド名をJSONで指定する

同じ操作をJSON-RPCで表現すると：

```bash
# ユーザー情報を取得
curl -X POST https://api.example.com/rpc \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "method": "getUser",
    "params": {"id": 123},
    "id": 1
  }'

# ユーザーを作成
curl -X POST https://api.example.com/rpc \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "method": "createUser",
    "params": {"name": "Taro Yamada", "email": "taro@example.com"},
    "id": 2
  }'
```

エンドポイントもHTTPメソッドも同じで、`method`フィールドで実行する処理を指定します。この統一性が、JSON-RPCの大きな特徴です。

## リクエストとレスポンスの基本構造

JSON-RPC 2.0のリクエストとレスポンスは、シンプルで明確な構造を持っています。

### リクエストの構造

リクエストは、以下のフィールドを含むJSONオブジェクトです：

```json
{
  "jsonrpc": "2.0",
  "method": "subtract",
  "params": {"minuend": 42, "subtrahend": 23},
  "id": 1
}
```

各フィールドの意味：

- `jsonrpc`: プロトコルバージョン。常に`"2.0"`を指定します
- `method`: 呼び出すメソッド名を文字列で指定します
- `params`: メソッドに渡すパラメータ。配列またはオブジェクトで指定できます（省略可）
- `id`: リクエストを識別する値。文字列、数値、またはnullを指定します

`params`は配列でも指定できます：

```json
{
  "jsonrpc": "2.0",
  "method": "subtract",
  "params": [42, 23],
  "id": 1
}
```

配列を使う場合は位置パラメータ、オブジェクトを使う場合は名前付きパラメータとして扱われます。

### レスポンスの構造

成功時のレスポンス：

```json
{
  "jsonrpc": "2.0",
  "result": 19,
  "id": 1
}
```

エラー時のレスポンス：

```json
{
  "jsonrpc": "2.0",
  "error": {
    "code": -32600,
    "message": "Invalid Request"
  },
  "id": null
}
```

レスポンスの特徴：

- 必ず`"jsonrpc": "2.0"`を含む
- 成功時は`result`フィールド、エラー時は`error`フィールドを持つ（両方を同時に持つことはない）
- `id`はリクエストと同じ値を返す（リクエストとレスポンスを対応付けるため）

## JSON-RPC 2.0仕様の重要ポイント

仕様書を読んでいくと、いくつかの重要なポイントが見えてきます。

### バッチリクエスト

複数のリクエストを配列にまとめて、一度に送信できます：

```json
[
  {"jsonrpc": "2.0", "method": "sum", "params": [1, 2, 4], "id": "1"},
  {"jsonrpc": "2.0", "method": "notify_hello", "params": [7]},
  {"jsonrpc": "2.0", "method": "subtract", "params": [42, 23], "id": "2"}
]
```

これにより、ネットワークのオーバーヘッドを削減し、効率的な通信が可能になります。

### 通知（Notification）

`id`フィールドを省略すると、レスポンスを返さない「通知」として扱われます：

```json
{
  "jsonrpc": "2.0",
  "method": "update",
  "params": {"status": "processing"}
}
```

通知は、結果を待つ必要がない処理（ログ送信、イベント通知など）に適しています。レスポンスが返らないため、通信量を削減できます。

### エラーコードの標準化

エラーには標準的なコードが定義されています：

| コード | メッセージ | 意味 |
|--------|-----------|------|
| -32700 | Parse error | JSONのパースに失敗 |
| -32600 | Invalid Request | リクエストが仕様に準拠していない |
| -32601 | Method not found | メソッドが見つからない |
| -32602 | Invalid params | パラメータが不正 |
| -32603 | Internal error | サーバー内部エラー |

-32000から-32099は、実装固有のエラーコードとして予約されています。

## なぜPerlで実装するのか

「なぜ今、Perlなのか」と思われるかもしれません。実は、Perlには以下のような利点があります：

### テキスト処理の強さ

JSONは結局のところテキストデータです。Perlの強力なテキスト処理能力は、JSONの扱いにも活かせます。

### CPANの豊富なモジュール

CPAN（Comprehensive Perl Archive Network）には、40年近い歴史の中で蓄積された膨大なモジュールがあります。JSON-RPC関連のモジュールも充実しています。

### シンプルなスクリプト実行

コンパイル不要で、すぐに実行できます。プロトタイピングや小規模なツール作成に最適です。

### 実績のある安定性

多くの企業システムで長年運用されており、信頼性が証明されています。

## JSON::RPC::Specの紹介

この連載では、`JSON::RPC::Spec`というCPANモジュールを使用します。

{{< linkcard "https://metacpan.org/pod/JSON::RPC::Spec" >}}

このモジュールは、JSON-RPC 2.0の仕様に忠実な実装を提供しており、以下の特徴があります：

- リクエスト/レスポンスの構築と検証
- バッチリクエストのサポート
- エラーハンドリングの標準化
- 軽量で依存関係が少ない

インストールは簡単です：

```bash
cpanm JSON::RPC::Spec
```

次回以降の記事で、このモジュールを使った具体的な実装例を紹介していきます。

## まとめ

この記事では、JSON-RPC 2.0の基本を学びました：

- JSON-RPC 2.0は、JSONを使った軽量なRPCプロトコル
- REST APIとは異なり、関数呼び出しを中心とした設計
- リクエスト/レスポンスの構造はシンプルで統一的
- バッチリクエストや通知など、実用的な機能を備えている
- Perlの`JSON::RPC::Spec`モジュールで簡単に実装できる

次回は、実際にJSON-RPC 2.0のクライアントを実装し、具体的なリクエストの送信方法を学びます。

プロトコルのシンプルさと美しさを、実装を通じて体感していきましょう。

## 参考リンク

- {{< linkcard "https://www.jsonrpc.org/specification" >}}
- {{< linkcard "https://metacpan.org/pod/JSON::RPC::Spec" >}}
