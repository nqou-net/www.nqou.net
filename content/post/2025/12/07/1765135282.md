---
title: "Webアプリケーションとの連携 - PSGIで動かす"
description: "JSON::RPC::SpecをPSGI環境で動作させ、実際のWebアプリケーションとして公開、Plackの基本も学びます。"
tags:
  - json-rpc
  - perl
  - psgi
  - plack
  - web-application
draft: true
---

[@nqounet](https://x.com/nqounet)です。

前回の記事では、JSON-RPCサーバーに認証・認可機能を追加し、トークンベースの認証とメソッドレベルでのアクセス制御を実装しました。

これまでの連載で、JSON-RPC 2.0の基本機能から高度なセキュリティまで学んできましたが、サンプルコードの多くは「どのように動かすか」という部分を簡略化していました。実際のプロダクション環境では、標準的なWebアプリケーションとして動作させる必要があります。

今回は、**PSGI（Perl Web Server Gateway Interface）**を使って、JSON-RPCサーバーを本格的なWebアプリケーションとして公開する方法を学びます。PSGIは、PerlにおけるWebアプリケーションの標準インターフェースで、PlackというツールキットとともにPerlのWeb開発の基盤となっています。

## PSGIとは？

PSGIは、Pythonの**WSGI**やRubyの**Rack**に相当する、Perlのためのインターフェース仕様です。

### PSGIの3つの利点

1. **サーバー非依存**
   - Apache、nginx、Starletなど、様々なWebサーバーで動作
   - 開発時と本番環境で同じコードが使える

2. **ミドルウェア機構**
   - CORS、アクセスログ、認証などを簡単に追加
   - 機能を疎結合に保てる

3. **標準化と互換性**
   - PSGI準拠のアプリケーションは、Plackの豊富なツールを活用できる
   - フレームワークに依存しない

### Plackとの関係

- **PSGI**: インターフェース仕様（約束事）
- **Plack**: PSGI実装のツールキット（実際のツール群）

例えるなら、PSGIが「電源プラグの規格」で、Plackが「実際のプラグやアダプタのセット」です。

## 最小限のPSGIアプリケーション

まず、PSGIの基本を理解するため、最小限のアプリケーションを見てみましょう。

### hello.psgi

```perl
#!/usr/bin/env perl
use strict;
use warnings;

# PSGIアプリケーションは、環境変数を受け取り、レスポンスを返すサブルーチン
my $app = sub {
    my $env = shift;  # リクエストの情報が入ったハッシュリファレンス
    
    # レスポンスは [status, headers, body] の配列リファレンス
    return [
        200,                                      # HTTPステータスコード
        ['Content-Type' => 'text/plain'],        # ヘッダー（配列リファレンス）
        ["Hello, PSGI World!\n"],                # ボディ（配列リファレンス）
    ];
};
```

### 実行方法

```bash
plackup hello.psgi
```

これだけで、`http://localhost:5000/`にアクセスすると「Hello, PSGI World!」が表示されます。

### PSGIレスポンスの構造

PSGIアプリケーションが返すレスポンスは、必ず以下の形式です：

```perl
[
    $status,      # HTTPステータスコード（数値）
    $headers,     # ヘッダー（配列リファレンス）
    $body,        # ボディ（配列リファレンス、またはファイルハンドル風のオブジェクト）
]
```

## JSON-RPC サーバーのPSGI化

それでは、前回作成した認証機能付きJSON-RPCサーバーをPSGI対応にしましょう。

### app.psgi

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use utf8;
use JSON::RPC::Spec;
use Plack::Request;
use Digest::SHA qw(sha256_hex);
use JSON;

# トークンストア（本番環境ではRedisやDBを使用）
my %tokens;

# ユーザーデータベース
my %users = (
    'alice' => {
        password => sha256_hex('alice123'),
        role     => 'admin',
        email    => 'alice@example.com',
        name     => 'Alice Admin',
    },
    'bob' => {
        password => sha256_hex('bob123'),
        role     => 'user',
        email    => 'bob@example.com',
        name     => 'Bob User',
    },
);

# トークン生成
sub generate_token {
    my ($username) = @_;
    my $token = sha256_hex($username . time() . rand());
    return $token;
}

# トークン検証
sub verify_token {
    my ($token) = @_;
    return unless $token;
    return $tokens{$token};
}

# 保護されたメソッドの定義
my %protected_methods = (
    getUserInfo   => 'user',
    updateProfile => 'user',
    adminOnly     => 'admin',
    logout        => 'user',
);

# JSON-RPCハンドラー
my $rpc = JSON::RPC::Spec->new;

# ログインメソッド
$rpc->register(
    login => sub {
        my ($params) = @_;
        
        my $username = $params->{username};
        my $password = $params->{password};
        
        unless ($username && $password) {
            die JSON::RPC::Spec::Error->new(
                code    => -32602,
                message => "ユーザー名とパスワードが必要です",
            );
        }
        
        my $user = $users{$username};
        unless ($user) {
            die JSON::RPC::Spec::Error->new(
                code    => -32001,
                message => "認証に失敗しました",
            );
        }
        
        my $password_hash = sha256_hex($password);
        unless ($password_hash eq $user->{password}) {
            die JSON::RPC::Spec::Error->new(
                code    => -32001,
                message => "認証に失敗しました",
            );
        }
        
        my $token = generate_token($username);
        $tokens{$token} = {
            username => $username,
            role     => $user->{role},
            created  => time(),
        };
        
        return {
            token    => $token,
            username => $username,
            role     => $user->{role},
        };
    }
);

# ユーザー情報取得
$rpc->register(
    getUserInfo => sub {
        my ($params, $context) = @_;
        
        my $user_info = $context->{user};
        my $username = $user_info->{username};
        my $user = $users{$username};
        
        return {
            username => $username,
            email    => $user->{email},
            name     => $user->{name},
            role     => $user->{role},
        };
    }
);

# プロフィール更新
$rpc->register(
    updateProfile => sub {
        my ($params, $context) = @_;
        
        my $user_info = $context->{user};
        my $username = $user_info->{username};
        
        my $name = $params->{name};
        my $email = $params->{email};
        
        $users{$username}{name} = $name if $name;
        $users{$username}{email} = $email if $email;
        
        return {
            message  => "プロフィールを更新しました",
            username => $username,
            name     => $users{$username}{name},
            email    => $users{$username}{email},
        };
    }
);

# 管理者専用メソッド
$rpc->register(
    adminOnly => sub {
        my ($params, $context) = @_;
        
        my $user_info = $context->{user};
        
        return {
            message => "管理者専用の機能にアクセスしました",
            user    => $user_info->{username},
            role    => $user_info->{role},
        };
    }
);

# ログアウト
$rpc->register(
    logout => sub {
        my ($params, $context) = @_;
        
        my $token = $context->{token};
        delete $tokens{$token};
        
        return {
            message => "ログアウトしました",
        };
    }
);

# PSGIアプリケーション本体
my $app = sub {
    my $env = shift;
    my $req = Plack::Request->new($env);
    
    # POSTメソッドのみ許可
    unless ($req->method eq 'POST') {
        return [
            405,
            ['Content-Type' => 'application/json'],
            [encode_json({
                jsonrpc => "2.0",
                error   => {
                    code    => -32600,
                    message => "Method not allowed",
                },
                id => undef,
            })],
        ];
    }
    
    # Authorizationヘッダーからトークンを取得
    my $auth_header = $req->header('Authorization') || '';
    my $token;
    if ($auth_header =~ /^Bearer\s+(.+)$/) {
        $token = $1;
    }
    
    # リクエストボディを取得
    my $body = $req->content;
    
    # JSON-RPCリクエストをパース
    my $request;
    eval {
        $request = decode_json($body);
    };
    if ($@) {
        my $error_response = {
            jsonrpc => "2.0",
            error   => {
                code    => -32700,
                message => "Parse error",
            },
            id => undef,
        };
        return [
            200,
            ['Content-Type' => 'application/json'],
            [encode_json($error_response)],
        ];
    }
    
    # メソッド名を取得
    my $method = ref($request) eq 'ARRAY'
        ? $request->[0]{method}
        : $request->{method};
    
    # 認証チェック
    my $context = {};
    
    if ($protected_methods{$method}) {
        unless ($token) {
            my $error_response = {
                jsonrpc => "2.0",
                error   => {
                    code    => -32002,
                    message => "認証が必要です",
                },
                id => ref($request) eq 'ARRAY'
                    ? $request->[0]{id}
                    : $request->{id},
            };
            return [
                401,
                ['Content-Type' => 'application/json'],
                [encode_json($error_response)],
            ];
        }
        
        my $user_info = verify_token($token);
        unless ($user_info) {
            my $error_response = {
                jsonrpc => "2.0",
                error   => {
                    code    => -32003,
                    message => "無効なトークンです",
                },
                id => ref($request) eq 'ARRAY'
                    ? $request->[0]{id}
                    : $request->{id},
            };
            return [
                401,
                ['Content-Type' => 'application/json'],
                [encode_json($error_response)],
            ];
        }
        
        # 認可チェック
        my $required_role = $protected_methods{$method};
        if ($required_role eq 'admin' && $user_info->{role} ne 'admin') {
            my $error_response = {
                jsonrpc => "2.0",
                error   => {
                    code    => -32004,
                    message => "このメソッドを実行する権限がありません",
                },
                id => ref($request) eq 'ARRAY'
                    ? $request->[0]{id}
                    : $request->{id},
            };
            return [
                403,
                ['Content-Type' => 'application/json'],
                [encode_json($error_response)],
            ];
        }
        
        $context->{user} = $user_info;
        $context->{token} = $token;
    }
    
    # JSON-RPCリクエストを処理
    my $response;
    if (ref($request) eq 'ARRAY') {
        # バッチリクエスト
        my @responses;
        for my $req (@$request) {
            my $res = eval {
                $rpc->call($req->{method}, $req->{params}, $context);
            };
            if ($@) {
                if (ref($@) eq 'JSON::RPC::Spec::Error') {
                    push @responses, {
                        jsonrpc => "2.0",
                        error   => {
                            code    => $@->code,
                            message => $@->message,
                            (defined $@->data ? (data => $@->data) : ()),
                        },
                        id => $req->{id},
                    };
                } else {
                    push @responses, {
                        jsonrpc => "2.0",
                        error   => {
                            code    => -32603,
                            message => "Internal error: $@",
                        },
                        id => $req->{id},
                    };
                }
            } else {
                push @responses, {
                    jsonrpc => "2.0",
                    result  => $res,
                    id      => $req->{id},
                };
            }
        }
        $response = \@responses;
    } else {
        # 単一リクエスト
        my $result = eval {
            $rpc->call($request->{method}, $request->{params}, $context);
        };
        if ($@) {
            if (ref($@) eq 'JSON::RPC::Spec::Error') {
                $response = {
                    jsonrpc => "2.0",
                    error   => {
                        code    => $@->code,
                        message => $@->message,
                        (defined $@->data ? (data => $@->data) : ()),
                    },
                    id => $request->{id},
                };
            } else {
                $response = {
                    jsonrpc => "2.0",
                    error   => {
                        code    => -32603,
                        message => "Internal error: $@",
                    },
                    id => $request->{id},
                };
            }
        } else {
            $response = {
                jsonrpc => "2.0",
                result  => $result,
                id      => $request->{id},
            };
        }
    }
    
    return [
        200,
        ['Content-Type' => 'application/json'],
        [encode_json($response)],
    ];
};
```

### コードの解説

このPSGIアプリケーションの構造：

1. **PSGIの標準形式**
   - `sub { my $env = shift; ... return [$status, $headers, $body]; }`
   - 環境変数を受け取り、レスポンス配列を返す

2. **Plack::Requestの活用**
   - `Plack::Request->new($env)`でリクエストオブジェクトを生成
   - メソッド、ヘッダー、ボディに簡単にアクセス

3. **適切なHTTPステータスコード**
   - 405: Method Not Allowed（POSTのみ許可）
   - 401: Unauthorized（認証エラー）
   - 403: Forbidden（認可エラー）
   - 200: 成功（JSON-RPCエラーもHTTPは200で返す）

## ミドルウェアの活用

Plackの強力な機能の一つが、**ミドルウェア**です。アプリケーションをラップして機能を追加できます。

### ミドルウェアを使ったapp.psgi

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use utf8;
use Plack::Builder;

# 前述のJSON-RPCアプリケーション（$app）を含む
# ... （上記のコードをここに配置）...

# ミドルウェアを使って機能を追加
builder {
    # CORSヘッダーを追加（ブラウザからのアクセスを許可）
    enable 'CrossOrigin',
        origins => '*',
        methods => ['POST'],
        headers => ['Content-Type', 'Authorization'];
    
    # アクセスログを記録
    enable 'AccessLog',
        format => '%h %l %u %t "%r" %>s %b "%{Referer}i" "%{User-agent}i"';
    
    # リクエスト処理時間を測定
    enable 'Runtime';
    
    # 静的ファイルの配信（/static以下）
    enable 'Static',
        path => qr{^/static/},
        root => './public';
    
    # エラー時にスタックトレースを表示（開発時のみ）
    enable_if { $ENV{PLACK_ENV} eq 'development' } 'StackTrace';
    
    # 実際のJSON-RPCアプリケーション
    $app;
};
```

### 主要なミドルウェアの紹介

#### 1. Plack::Middleware::CrossOrigin

CORS（Cross-Origin Resource Sharing）ヘッダーを追加します。

```perl
enable 'CrossOrigin',
    origins => ['https://example.com', 'https://app.example.com'],
    methods => ['GET', 'POST', 'OPTIONS'],
    headers => ['Content-Type', 'Authorization', 'X-Custom-Header'],
    credentials => 1;  # Cookieを許可
```

#### 2. Plack::Middleware::AccessLog

Apache形式のアクセスログを出力します。

```perl
enable 'AccessLog',
    format => 'combined',  # Apache combined形式
    logger => sub {
        my $message = shift;
        # カスタムログ処理
        open my $fh, '>>', '/var/log/myapp/access.log';
        print $fh $message;
        close $fh;
    };
```

#### 3. Plack::Middleware::Auth::Basic

Basic認証を追加します。

```perl
enable 'Auth::Basic',
    authenticator => sub {
        my ($username, $password) = @_;
        return $username eq 'admin' && $password eq 'secret';
    },
    realm => 'Restricted Area';
```

#### 4. Plack::Middleware::ReverseProxy

リバースプロキシ背後での動作をサポートします。

```perl
enable 'ReverseProxy';
```

#### 5. Plack::Middleware::Deflater

レスポンスをgzip圧縮します。

```perl
enable 'Deflater',
    content_type => ['text/html', 'application/json'],
    vary_user_agent => 1;
```

## 環境別の設定

開発環境と本番環境で異なる設定を使い分けましょう。

### 環境変数による切り替え

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use Plack::Builder;

my $env_mode = $ENV{PLACK_ENV} || 'development';

# 環境別の設定
my $config = {
    development => {
        cors_origins => '*',
        enable_stacktrace => 1,
        log_level => 'debug',
    },
    production => {
        cors_origins => ['https://example.com'],
        enable_stacktrace => 0,
        log_level => 'info',
    },
}->{$env_mode};

# アプリケーション本体
my $app = sub {
    my $env = shift;
    # ... JSON-RPC処理 ...
};

# ミドルウェアを環境に応じて適用
builder {
    enable 'CrossOrigin',
        origins => $config->{cors_origins};
    
    enable 'AccessLog';
    
    enable_if { $config->{enable_stacktrace} } 'StackTrace';
    
    $app;
};
```

## plackupコマンドの使い方

### 基本的な起動

```bash
# デフォルト（ポート5000、開発モード）
plackup app.psgi

# ポート指定
plackup --port 8080 app.psgi

# ホスト指定
plackup --host 0.0.0.0 --port 8080 app.psgi

# 環境指定
PLACK_ENV=production plackup app.psgi
```

### サーバーの選択

```bash
# Starlet（高速、本番推奨）
plackup --server Starlet --port 8080 app.psgi

# Starman（プリフォーク、安定性重視）
plackup --server Starman --workers 5 --port 8080 app.psgi

# Twiggy（非同期IO）
plackup --server Twiggy --port 8080 app.psgi

# デフォルトのHTTP::Server::PSGI（開発用）
plackup app.psgi
```

### リロード機能

開発時にファイル変更を自動検知してリロード：

```bash
plackup --reload app.psgi
```

### ワーカー数の指定

```bash
# 5個のワーカープロセスで起動
plackup --server Starman --workers 5 app.psgi
```

## ブラウザからのアクセステスト

ミドルウェアを組み込んだサーバーを起動して、ブラウザからテストしてみましょう。

### HTMLクライアントの作成

`public/index.html`を作成：

```html
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JSON-RPC Test Client</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
        }
        .section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
        }
        pre {
            background: #f4f4f4;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }
        input {
            padding: 5px;
            margin: 5px 0;
            width: 200px;
        }
    </style>
</head>
<body>
    <h1>JSON-RPC 2.0 Test Client</h1>
    
    <div class="section">
        <h2>1. ログイン</h2>
        <input type="text" id="username" placeholder="Username" value="alice">
        <input type="password" id="password" placeholder="Password" value="alice123">
        <button onclick="login()">ログイン</button>
        <pre id="login-result"></pre>
    </div>
    
    <div class="section">
        <h2>2. ユーザー情報取得</h2>
        <button onclick="getUserInfo()">ユーザー情報取得</button>
        <pre id="userinfo-result"></pre>
    </div>
    
    <div class="section">
        <h2>3. 管理者専用機能</h2>
        <button onclick="adminOnly()">管理者機能を呼び出す</button>
        <pre id="admin-result"></pre>
    </div>
    
    <div class="section">
        <h2>4. ログアウト</h2>
        <button onclick="logout()">ログアウト</button>
        <pre id="logout-result"></pre>
    </div>

    <script>
        let authToken = null;

        async function callRPC(method, params) {
            const request = {
                jsonrpc: "2.0",
                method: method,
                params: params,
                id: Date.now()
            };

            const headers = {
                'Content-Type': 'application/json'
            };

            if (authToken) {
                headers['Authorization'] = `Bearer ${authToken}`;
            }

            const response = await fetch('/', {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(request)
            });

            return await response.json();
        }

        async function login() {
            const username = document.getElementById('username').value;
            const password = document.getElementById('password').value;

            const result = await callRPC('login', {
                username: username,
                password: password
            });

            if (result.result) {
                authToken = result.result.token;
                document.getElementById('login-result').textContent =
                    'ログイン成功！\n' + JSON.stringify(result.result, null, 2);
            } else {
                document.getElementById('login-result').textContent =
                    'エラー: ' + JSON.stringify(result.error, null, 2);
            }
        }

        async function getUserInfo() {
            const result = await callRPC('getUserInfo', {});
            document.getElementById('userinfo-result').textContent =
                JSON.stringify(result, null, 2);
        }

        async function adminOnly() {
            const result = await callRPC('adminOnly', {});
            document.getElementById('admin-result').textContent =
                JSON.stringify(result, null, 2);
        }

        async function logout() {
            const result = await callRPC('logout', {});
            document.getElementById('logout-result').textContent =
                JSON.stringify(result, null, 2);
            authToken = null;
        }
    </script>
</body>
</html>
```

### ミドルウェアを含むapp.psgiの完全版

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use utf8;
use JSON::RPC::Spec;
use Plack::Request;
use Plack::Builder;
use Digest::SHA qw(sha256_hex);
use JSON;

# ... （前述のJSON-RPCサーバー実装をここに配置）...

# ミドルウェアを組み込んで起動
builder {
    enable 'CrossOrigin',
        origins => '*',
        methods => ['POST', 'OPTIONS'],
        headers => ['Content-Type', 'Authorization'];
    
    enable 'AccessLog',
        format => '%h %l %u %t "%r" %>s %b';
    
    enable 'Static',
        path => qr{^/},
        root => './public';
    
    enable_if { $ENV{PLACK_ENV} eq 'development' } 'StackTrace';
    
    $app;
};
```

### 起動と確認

```bash
# サーバー起動
plackup --port 5000 app.psgi

# ブラウザで以下にアクセス
# http://localhost:5000/
```

ブラウザでHTMLクライアントが表示され、ボタンをクリックするだけでJSON-RPCサーバーとのやり取りを試せます。

## 本番環境への対応

### systemdでの起動設定

本番環境では、systemdで管理することが一般的です。

`/etc/systemd/system/jsonrpc-server.service`：

```ini
[Unit]
Description=JSON-RPC Server
After=network.target

[Service]
Type=simple
User=www-data
WorkingDirectory=/var/www/jsonrpc
Environment="PLACK_ENV=production"
ExecStart=/usr/local/bin/plackup --server Starlet --port 8080 --workers 4 app.psgi
Restart=always

[Install]
WantedBy=multi-user.target
```

起動方法：

```bash
sudo systemctl daemon-reload
sudo systemctl enable jsonrpc-server
sudo systemctl start jsonrpc-server
sudo systemctl status jsonrpc-server
```

### nginxでのリバースプロキシ

nginx設定例（`/etc/nginx/sites-available/jsonrpc`）：

```nginx
upstream jsonrpc_backend {
    server 127.0.0.1:8080;
}

server {
    listen 80;
    server_name api.example.com;

    location / {
        proxy_pass http://jsonrpc_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # 静的ファイル
    location /static {
        alias /var/www/jsonrpc/public;
        expires 1d;
    }
}
```

### HTTPS対応

Let's Encryptを使った証明書取得：

```bash
sudo apt install certbot python3-certbot-nginx
sudo certbot --nginx -d api.example.com
```

nginxの設定が自動的に更新され、HTTPSが有効になります。

## パフォーマンスチューニング

### Starletサーバーの最適化

```bash
plackup --server Starlet \
    --port 8080 \
    --workers 10 \
    --max-reqs-per-child 1000 \
    --max-keepalive-reqs 100 \
    app.psgi
```

オプションの意味：

- `--workers`: ワーカープロセス数（CPUコア数の2倍程度）
- `--max-reqs-per-child`: プロセスが処理するリクエスト数の上限（メモリリーク対策）
- `--max-keepalive-reqs`: Keep-Alive接続で処理するリクエスト数

### キャッシュの活用

Plack::Middleware::Cacheを使った例：

```perl
builder {
    enable 'Cache',
        cache_class => 'CHI',
        chi => {
            driver => 'Redis',
            server => '127.0.0.1:6379',
            namespace => 'jsonrpc',
        };
    
    $app;
};
```

## まとめ

今回は、JSON-RPCサーバーをPSGI環境で動作させる方法を学びました。

### 学んだこと

1. **PSGIの基本**
   - PSGIアプリケーションの構造
   - レスポンスの形式
   - Plack::Requestの活用

2. **ミドルウェアの活用**
   - CORS対応
   - アクセスログ
   - エラーハンドリング
   - 静的ファイル配信

3. **環境別の設定**
   - 開発環境と本番環境の分離
   - 環境変数の活用

4. **本番環境への対応**
   - systemdによるプロセス管理
   - nginxでのリバースプロキシ
   - HTTPS対応

5. **実践的な使い方**
   - plackupコマンド
   - サーバーの選択
   - ブラウザからのテスト

### 次回予告

次回は、JSON-RPCサーバーのテストについて学びます。

- 単体テストの書き方
- Test::Moreを使った実践的なテスト
- モックを使った認証のテスト
- 統合テストの実装

実運用に耐えるサーバーを作るには、包括的なテストが不可欠です。次回もお楽しみに！

## 参考リンク

- {{< linkcard "https://plackperl.org/" >}}
- {{< linkcard "https://metacpan.org/pod/PSGI" >}}
- {{< linkcard "https://metacpan.org/pod/Plack" >}}
- {{< linkcard "https://metacpan.org/pod/Plack::Builder" >}}
