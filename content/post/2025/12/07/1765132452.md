---
title: "実践的なサーバー設計 - メソッドの整理と拡張性"
description: "実務で使えるサーバー構造を設計し、メソッドのモジュール化、共通処理の実装、設定管理など保守性の高い実装を学びます。"
tags:
  - json-rpc
  - perl
  - architecture
  - scalability
  - best-practices
draft: true
---

[@nqounet](https://x.com/nqounet)です。

前回の記事では、バッチ処理を使った疑似トランザクション処理を実装し、複数の関連する操作を一括で扱う方法を学びました。

ここまでの連載で、JSON-RPC 2.0の基本的な機能は一通り学んできました。しかし、実務でサーバーを運用していくには、「動く」だけでは不十分です。保守性、拡張性、デバッグのしやすさなど、長期的な視点での設計が重要になります。

今回は、これまで学んできた知識を総動員して、実務で使える「実践的なサーバー設計」を構築します。メソッドのモジュール化、共通処理の実装、設定管理、ロギングなど、プロダクション環境で求められる要素を一つずつ実装していきましょう。

## 実践的なサーバーに必要な要素

実務で運用するJSON-RPCサーバーには、以下のような要素が求められます：

### コードの整理と拡張性
- **メソッドのモジュール分割**: 機能ごとにファイルを分け、管理しやすくする
- **共通処理の抽出**: 認証、バリデーション、ロギングなどの横断的な処理を一元化
- **プラグイン機構**: 新しいメソッドを簡単に追加できる仕組み

### 設定管理
- **設定ファイルの外部化**: データベース接続情報、APIキーなどを環境変数や設定ファイルで管理
- **環境別の設定**: 開発、ステージング、本番環境で異なる設定を適用

### ロギングとデバッグ
- **構造化ログ**: リクエストID、ユーザー情報、実行時間などを記録
- **デバッグモード**: 開発時に詳細なログを出力
- **エラートラッキング**: 例外やエラーを適切に記録

### セキュリティと信頼性
- **入力バリデーション**: すべての入力を検証
- **エラーハンドリング**: 予期しないエラーでも安全に処理
- **レート制限**: 過度なリクエストから保護

今回は、これらの要素のうち、特に重要な「モジュール分割」「設定管理」「ロギング」に焦点を当てて実装していきます。

## プロジェクト構造の設計

まず、プロジェクトのディレクトリ構造を整理しましょう。以下のような構造を採用します：

```
my-jsonrpc-server/
├── lib/
│   ├── MyApp/
│   │   ├── Config.pm        # 設定管理
│   │   ├── Logger.pm        # ロギング
│   │   ├── Server.pm        # サーバー本体
│   │   └── Methods/         # メソッド群
│   │       ├── User.pm      # ユーザー関連メソッド
│   │       ├── Item.pm      # アイテム関連メソッド
│   │       └── System.pm    # システム関連メソッド
├── config/
│   ├── development.json     # 開発環境設定
│   └── production.json      # 本番環境設定
├── logs/                    # ログファイル
├── server.pl               # サーバー起動スクリプト
└── client.pl              # テスト用クライアント
```

この構造により、機能ごとにファイルが分割され、それぞれのメソッドが独立して管理できるようになります。

## 設定管理モジュールの実装

まず、設定ファイルを読み込むモジュールを作成します：

```perl
# lib/MyApp/Config.pm
package MyApp::Config;
use strict;
use warnings;
use JSON;
use Path::Tiny;

my $config_cache;

sub load {
    my ($class, $env) = @_;
    $env ||= $ENV{MYAPP_ENV} || 'development';
    
    return $config_cache if $config_cache;
    
    my $config_file = path("config/$env.json");
    
    unless ($config_file->exists) {
        die "Config file not found: $config_file\n";
    }
    
    my $json_text = $config_file->slurp_utf8;
    $config_cache = decode_json($json_text);
    
    # 環境変数での上書きをサポート
    if (my $db_host = $ENV{DB_HOST}) {
        $config_cache->{database}{host} = $db_host;
    }
    if (my $db_pass = $ENV{DB_PASSWORD}) {
        $config_cache->{database}{password} = $db_pass;
    }
    
    return $config_cache;
}

sub get {
    my ($class, $key) = @_;
    $config_cache ||= $class->load();
    
    my @keys = split /\./, $key;
    my $value = $config_cache;
    
    for my $k (@keys) {
        return unless ref $value eq 'HASH';
        $value = $value->{$k};
    }
    
    return $value;
}

sub reload {
    my $class = shift;
    $config_cache = undef;
    return $class->load();
}

1;
```

次に、設定ファイルを作成します：

```json
{
  "server": {
    "host": "localhost",
    "port": 8080,
    "timeout": 30
  },
  "database": {
    "host": "localhost",
    "port": 5432,
    "name": "myapp_dev",
    "user": "developer",
    "password": "dev_password"
  },
  "log": {
    "level": "debug",
    "file": "logs/development.log",
    "max_size": "10MB"
  },
  "features": {
    "enable_debug": true,
    "rate_limit": 100
  }
}
```

## ロギングモジュールの実装

次に、構造化ログを出力するロギングモジュールを作成します：

```perl
# lib/MyApp/Logger.pm
package MyApp::Logger;
use strict;
use warnings;
use JSON;
use Time::HiRes qw(time);
use Path::Tiny;

my $log_file;
my $log_level;
my %LEVELS = (
    debug => 0,
    info  => 1,
    warn  => 2,
    error => 3,
);

sub new {
    my ($class, %args) = @_;
    
    $log_file = $args{file} || 'logs/app.log';
    $log_level = $args{level} || 'info';
    
    # ログディレクトリの作成
    path($log_file)->parent->mkpath;
    
    return bless {}, $class;
}

sub _log {
    my ($self, $level, $message, $context) = @_;
    
    return if $LEVELS{$level} < $LEVELS{$log_level};
    
    my $log_entry = {
        timestamp => _timestamp(),
        level     => uc($level),
        message   => $message,
        %{$context || {}},
    };
    
    my $json = encode_json($log_entry);
    
    # ファイルに書き込み
    path($log_file)->append_utf8($json . "\n");
    
    # 開発環境では標準出力にも
    if ($ENV{MYAPP_ENV} && $ENV{MYAPP_ENV} eq 'development') {
        print STDERR "[" . uc($level) . "] $message\n";
    }
}

sub debug {
    my ($self, $message, $context) = @_;
    $self->_log('debug', $message, $context);
}

sub info {
    my ($self, $message, $context) = @_;
    $self->_log('info', $message, $context);
}

sub warn {
    my ($self, $message, $context) = @_;
    $self->_log('warn', $message, $context);
}

sub error {
    my ($self, $message, $context) = @_;
    $self->_log('error', $message, $context);
}

sub _timestamp {
    my ($sec, $min, $hour, $mday, $mon, $year) = localtime(time);
    return sprintf(
        "%04d-%02d-%02d %02d:%02d:%02d",
        $year + 1900, $mon + 1, $mday, $hour, $min, $sec
    );
}

1;
```

## メソッドモジュールの実装

次に、機能ごとにメソッドを分割します。まず、ユーザー関連のメソッドを実装します：

```perl
# lib/MyApp/Methods/User.pm
package MyApp::Methods::User;
use strict;
use warnings;

my %users = (
    1 => { id => 1, name => 'Alice', email => 'alice@example.com' },
    2 => { id => 2, name => 'Bob', email => 'bob@example.com' },
);
my $next_id = 3;

sub register_methods {
    my ($class, $server) = @_;
    
    $server->register('user.list', \&list);
    $server->register('user.get', \&get);
    $server->register('user.create', \&create);
    $server->register('user.update', \&update);
    $server->register('user.delete', \&delete_user);
}

sub list {
    my ($params) = @_;
    
    my $limit = $params->{limit} || 10;
    my $offset = $params->{offset} || 0;
    
    my @all_users = values %users;
    my @result = splice(@all_users, $offset, $limit);
    
    return {
        users => \@result,
        total => scalar(keys %users),
        limit => $limit,
        offset => $offset,
    };
}

sub get {
    my ($params) = @_;
    
    my $user_id = $params->{id};
    
    unless (defined $user_id) {
        die {
            code => -32602,
            message => 'Invalid params',
            data => 'user id is required'
        };
    }
    
    my $user = $users{$user_id};
    
    unless ($user) {
        die {
            code => -32001,
            message => 'User not found',
            data => "User ID: $user_id"
        };
    }
    
    return $user;
}

sub create {
    my ($params) = @_;
    
    unless ($params->{name} && $params->{email}) {
        die {
            code => -32602,
            message => 'Invalid params',
            data => 'name and email are required'
        };
    }
    
    my $user = {
        id => $next_id++,
        name => $params->{name},
        email => $params->{email},
    };
    
    $users{$user->{id}} = $user;
    
    return $user;
}

sub update {
    my ($params) = @_;
    
    my $user_id = $params->{id};
    
    unless (defined $user_id) {
        die {
            code => -32602,
            message => 'Invalid params',
            data => 'user id is required'
        };
    }
    
    my $user = $users{$user_id};
    
    unless ($user) {
        die {
            code => -32001,
            message => 'User not found',
            data => "User ID: $user_id"
        };
    }
    
    $user->{name} = $params->{name} if $params->{name};
    $user->{email} = $params->{email} if $params->{email};
    
    return $user;
}

sub delete_user {
    my ($params) = @_;
    
    my $user_id = $params->{id};
    
    unless (defined $user_id) {
        die {
            code => -32602,
            message => 'Invalid params',
            data => 'user id is required'
        };
    }
    
    my $user = delete $users{$user_id};
    
    unless ($user) {
        die {
            code => -32001,
            message => 'User not found',
            data => "User ID: $user_id"
        };
    }
    
    return { success => 1, deleted_user => $user };
}

1;
```

アイテム管理のメソッドも実装します：

```perl
# lib/MyApp/Methods/Item.pm
package MyApp::Methods::Item;
use strict;
use warnings;

my %items = (
    1 => { id => 1, name => 'Item A', price => 1000, stock => 10 },
    2 => { id => 2, name => 'Item B', price => 2000, stock => 5 },
);
my $next_id = 3;

sub register_methods {
    my ($class, $server) = @_;
    
    $server->register('item.list', \&list);
    $server->register('item.get', \&get);
    $server->register('item.create', \&create);
    $server->register('item.update_stock', \&update_stock);
}

sub list {
    my ($params) = @_;
    
    my @all_items = values %items;
    
    # 在庫フィルタリング
    if (defined $params->{in_stock_only} && $params->{in_stock_only}) {
        @all_items = grep { $_->{stock} > 0 } @all_items;
    }
    
    return {
        items => \@all_items,
        total => scalar(@all_items),
    };
}

sub get {
    my ($params) = @_;
    
    my $item_id = $params->{id};
    
    unless (defined $item_id) {
        die {
            code => -32602,
            message => 'Invalid params',
            data => 'item id is required'
        };
    }
    
    my $item = $items{$item_id};
    
    unless ($item) {
        die {
            code => -32002,
            message => 'Item not found',
            data => "Item ID: $item_id"
        };
    }
    
    return $item;
}

sub create {
    my ($params) = @_;
    
    unless ($params->{name} && defined $params->{price}) {
        die {
            code => -32602,
            message => 'Invalid params',
            data => 'name and price are required'
        };
    }
    
    my $item = {
        id => $next_id++,
        name => $params->{name},
        price => $params->{price},
        stock => $params->{stock} || 0,
    };
    
    $items{$item->{id}} = $item;
    
    return $item;
}

sub update_stock {
    my ($params) = @_;
    
    my $item_id = $params->{id};
    my $quantity = $params->{quantity};
    
    unless (defined $item_id && defined $quantity) {
        die {
            code => -32602,
            message => 'Invalid params',
            data => 'item id and quantity are required'
        };
    }
    
    my $item = $items{$item_id};
    
    unless ($item) {
        die {
            code => -32002,
            message => 'Item not found',
            data => "Item ID: $item_id"
        };
    }
    
    $item->{stock} += $quantity;
    
    if ($item->{stock} < 0) {
        die {
            code => -32003,
            message => 'Insufficient stock',
            data => "Current stock: " . ($item->{stock} - $quantity)
        };
    }
    
    return $item;
}

1;
```

システム関連のメソッドも追加します：

```perl
# lib/MyApp/Methods/System.pm
package MyApp::Methods::System;
use strict;
use warnings;
use MyApp::Config;

sub register_methods {
    my ($class, $server) = @_;
    
    $server->register('system.ping', \&ping);
    $server->register('system.status', \&status);
    $server->register('system.version', \&version);
}

sub ping {
    my ($params) = @_;
    return { pong => time() };
}

sub status {
    my ($params) = @_;
    
    return {
        status => 'ok',
        uptime => time() - $^T,
        version => version()->{version},
        environment => $ENV{MYAPP_ENV} || 'development',
    };
}

sub version {
    my ($params) = @_;
    return {
        version => '1.0.0',
        api_version => '2.0',
    };
}

1;
```

## サーバー本体の実装

次に、これらのモジュールを統合するサーバー本体を実装します：

```perl
# lib/MyApp/Server.pm
package MyApp::Server;
use strict;
use warnings;
use JSON::RPC::Spec;
use MyApp::Config;
use MyApp::Logger;
use MyApp::Methods::User;
use MyApp::Methods::Item;
use MyApp::Methods::System;
use Time::HiRes qw(time);

sub new {
    my ($class, %args) = @_;
    
    my $config = MyApp::Config->load($args{env});
    my $logger = MyApp::Logger->new(
        file  => $config->{log}{file},
        level => $config->{log}{level},
    );
    
    my $rpc = JSON::RPC::Spec->new;
    
    my $self = bless {
        rpc    => $rpc,
        config => $config,
        logger => $logger,
        stats  => {
            requests => 0,
            errors   => 0,
        },
    }, $class;
    
    # メソッドの登録
    $self->_register_methods();
    
    return $self;
}

sub _register_methods {
    my $self = shift;
    
    # 各モジュールのメソッドを登録
    MyApp::Methods::User->register_methods($self);
    MyApp::Methods::Item->register_methods($self);
    MyApp::Methods::System->register_methods($self);
}

sub register {
    my ($self, $method_name, $code_ref) = @_;
    
    # メソッドをラップして共通処理を追加
    my $wrapped = sub {
        my ($params) = @_;
        
        my $start_time = time();
        
        $self->{logger}->debug("Method called: $method_name", {
            method => $method_name,
            params => $params,
        });
        
        my $result;
        eval {
            $result = $code_ref->($params);
        };
        
        my $elapsed = time() - $start_time;
        
        if ($@) {
            $self->{stats}{errors}++;
            
            my $error = ref($@) eq 'HASH' ? $@ : {
                code => -32603,
                message => 'Internal error',
                data => "$@",
            };
            
            $self->{logger}->error("Method error: $method_name", {
                method  => $method_name,
                error   => $error,
                elapsed => $elapsed,
            });
            
            die $error;
        }
        
        $self->{logger}->info("Method completed: $method_name", {
            method  => $method_name,
            elapsed => $elapsed,
        });
        
        return $result;
    };
    
    $self->{rpc}->register($method_name, $wrapped);
}

sub handle_request {
    my ($self, $json_request) = @_;
    
    $self->{stats}{requests}++;
    
    my $start_time = time();
    
    $self->{logger}->debug("Request received", {
        request => $json_request,
    });
    
    my $response = $self->{rpc}->parse($json_request);
    
    my $elapsed = time() - $start_time;
    
    $self->{logger}->info("Request processed", {
        elapsed => $elapsed,
        stats   => $self->{stats},
    });
    
    return $response;
}

sub get_stats {
    my $self = shift;
    return $self->{stats};
}

1;
```

## サーバー起動スクリプト

サーバーを起動するスクリプトを作成します：

```perl
#!/usr/bin/env perl
# server.pl
use strict;
use warnings;
use FindBin;
use lib "$FindBin::Bin/lib";
use MyApp::Server;
use HTTP::Server::Simple::CGI;

{
    package MyApp::HTTPServer;
    use base qw(HTTP::Server::Simple::CGI);
    
    my $server;
    
    sub setup {
        my $class = shift;
        $server = MyApp::Server->new();
    }
    
    sub handle_request {
        my ($self, $cgi) = @_;
        
        my $path = $cgi->path_info();
        
        if ($path ne '/rpc') {
            print "HTTP/1.0 404 Not Found\r\n";
            print "Content-Type: text/plain\r\n\r\n";
            print "Not Found\n";
            return;
        }
        
        if ($cgi->request_method() ne 'POST') {
            print "HTTP/1.0 405 Method Not Allowed\r\n";
            print "Content-Type: text/plain\r\n\r\n";
            print "Method Not Allowed\n";
            return;
        }
        
        my $request = $cgi->param('POSTDATA');
        my $response = $server->handle_request($request);
        
        print "HTTP/1.0 200 OK\r\n";
        print "Content-Type: application/json\r\n";
        print "Content-Length: " . length($response) . "\r\n\r\n";
        print $response;
    }
}

MyApp::HTTPServer->setup();

my $port = $ENV{PORT} || 8080;
my $httpd = MyApp::HTTPServer->new($port);

print "Starting JSON-RPC server on port $port...\n";
print "Access: http://localhost:$port/rpc\n";

$httpd->run();
```

## クライアントのテスト

最後に、動作確認用のクライアントを作成します：

```perl
#!/usr/bin/env perl
# client.pl
use strict;
use warnings;
use FindBin;
use lib "$FindBin::Bin/lib";
use JSON::RPC::Spec::Client;
use Data::Dumper;

my $client = JSON::RPC::Spec::Client->new(
    url => 'http://localhost:8080/rpc',
);

print "=== システム情報 ===\n";
my $version = $client->call('system.version');
print Dumper($version);

print "\n=== ユーザー一覧 ===\n";
my $users = $client->call('user.list', { limit => 5 });
print Dumper($users);

print "\n=== 新規ユーザー作成 ===\n";
my $new_user = $client->call('user.create', {
    name => 'Charlie',
    email => 'charlie@example.com',
});
print Dumper($new_user);

print "\n=== ユーザー詳細取得 ===\n";
my $user = $client->call('user.get', { id => $new_user->{id} });
print Dumper($user);

print "\n=== アイテム一覧（在庫あり） ===\n";
my $items = $client->call('item.list', { in_stock_only => 1 });
print Dumper($items);

print "\n=== 新規アイテム作成 ===\n";
my $new_item = $client->call('item.create', {
    name => 'Item C',
    price => 3000,
    stock => 15,
});
print Dumper($new_item);

print "\n=== 在庫更新 ===\n";
my $updated_item = $client->call('item.update_stock', {
    id => $new_item->{id},
    quantity => -5,
});
print Dumper($updated_item);

print "\n=== バッチリクエスト ===\n";
my @batch_results = $client->batch(sub {
    $client->call('system.status');
    $client->call('user.list', { limit => 2 });
    $client->call('item.list', { in_stock_only => 1 });
});
print Dumper(\@batch_results);

print "\n=== エラーハンドリングのテスト ===\n";
eval {
    $client->call('user.get', { id => 99999 });
};
if ($@) {
    print "Expected error caught:\n";
    print Dumper($@);
}

print "\n=== サーバーステータス ===\n";
my $status = $client->call('system.status');
print Dumper($status);
```

## 動作確認

依存モジュールをインストールします：

```bash
cpanm JSON::RPC::Spec JSON::RPC::Spec::Client HTTP::Server::Simple Path::Tiny
```

設定ファイルを配置します：

```bash
mkdir -p config logs
cat > config/development.json << 'EOF'
{
  "server": {
    "host": "localhost",
    "port": 8080,
    "timeout": 30
  },
  "database": {
    "host": "localhost",
    "port": 5432,
    "name": "myapp_dev",
    "user": "developer",
    "password": "dev_password"
  },
  "log": {
    "level": "debug",
    "file": "logs/development.log",
    "max_size": "10MB"
  },
  "features": {
    "enable_debug": true,
    "rate_limit": 100
  }
}
EOF
```

サーバーを起動します：

```bash
perl server.pl
```

別のターミナルでクライアントを実行します：

```bash
perl client.pl
```

## ログの確認

実行後、ログファイルを確認すると、構造化されたJSONログが記録されています：

```bash
cat logs/development.log
```

出力例：
```json
{"timestamp":"2025-12-07 18:30:01","level":"DEBUG","message":"Request received","request":"{\"jsonrpc\":\"2.0\",\"method\":\"system.version\",\"id\":1}"}
{"timestamp":"2025-12-07 18:30:01","level":"DEBUG","message":"Method called: system.version","method":"system.version","params":{}}
{"timestamp":"2025-12-07 18:30:01","level":"INFO","message":"Method completed: system.version","method":"system.version","elapsed":0.000123}
{"timestamp":"2025-12-07 18:30:01","level":"INFO","message":"Request processed","elapsed":0.001234,"stats":{"requests":1,"errors":0}}
```

## 拡張のポイント

この設計により、以下のような拡張が容易になります：

### 新しいメソッドの追加

新しい機能を追加するには、`lib/MyApp/Methods/` に新しいモジュールを作成するだけです：

```perl
# lib/MyApp/Methods/Order.pm
package MyApp::Methods::Order;
use strict;
use warnings;

sub register_methods {
    my ($class, $server) = @_;
    
    $server->register('order.create', \&create);
    $server->register('order.list', \&list);
}

sub create {
    my ($params) = @_;
    # 注文作成ロジック
}

sub list {
    my ($params) = @_;
    # 注文一覧取得ロジック
}

1;
```

そして、`lib/MyApp/Server.pm` の `_register_methods` メソッドに追加：

```perl
sub _register_methods {
    my $self = shift;
    
    MyApp::Methods::User->register_methods($self);
    MyApp::Methods::Item->register_methods($self);
    MyApp::Methods::System->register_methods($self);
    MyApp::Methods::Order->register_methods($self);  # 追加
}
```

### 認証の追加

共通処理として認証を追加することもできます：

```perl
sub register {
    my ($self, $method_name, $code_ref) = @_;
    
    my $wrapped = sub {
        my ($params) = @_;
        
        # 認証が必要なメソッドの場合
        if ($method_name !~ /^system\./) {
            unless ($params->{auth_token}) {
                die {
                    code => -32004,
                    message => 'Authentication required',
                };
            }
            
            # トークン検証ロジック
            # ...
        }
        
        # 元の処理
        return $code_ref->($params);
    };
    
    $self->{rpc}->register($method_name, $wrapped);
}
```

### データベース接続の追加

設定からデータベースに接続するモジュールを追加できます：

```perl
# lib/MyApp/Database.pm
package MyApp::Database;
use strict;
use warnings;
use DBI;
use MyApp::Config;

sub connect {
    my $class = shift;
    
    my $db_config = MyApp::Config->get('database');
    
    my $dsn = sprintf(
        "dbi:Pg:dbname=%s;host=%s;port=%s",
        $db_config->{name},
        $db_config->{host},
        $db_config->{port},
    );
    
    return DBI->connect(
        $dsn,
        $db_config->{user},
        $db_config->{password},
        { RaiseError => 1, AutoCommit => 1 },
    );
}

1;
```

## まとめ

今回は、実務で使える実践的なJSON-RPCサーバーの設計を学びました。

### 学んだこと

1. **モジュール分割**: 機能ごとにファイルを分け、保守性を向上
2. **設定管理**: 環境別の設定を外部ファイルで管理
3. **ロギング**: 構造化ログで詳細な情報を記録
4. **共通処理**: メソッドをラップして横断的な処理を一元化
5. **拡張性**: 新しい機能を簡単に追加できる設計

### 実装したもの

- 設定管理モジュール（`MyApp::Config`）
- ロギングモジュール（`MyApp::Logger`）
- ユーザー管理メソッド（`MyApp::Methods::User`）
- アイテム管理メソッド（`MyApp::Methods::Item`）
- システムメソッド（`MyApp::Methods::System`）
- サーバー本体（`MyApp::Server`）

この設計は、小規模なプロジェクトから始めて、必要に応じて段階的に拡張していくことができます。認証、データベース接続、キャッシング、レート制限など、必要な機能を徐々に追加していけば、プロダクション環境で使えるサーバーに成長させることができます。

次回は、この設計をベースに、より高度なトピックとして「セキュリティ対策」や「パフォーマンスチューニング」について学んでいきます。

それでは、また次回の記事でお会いしましょう！
