---
title: "通知（Notification）を使いこなす"
description: "レスポンスを期待しない通知リクエストの実装方法を学び、ログ送信など一方向通信が適切なケースを理解します。"
tags:
  - json-rpc
  - perl
  - notification
  - one-way-communication
  - logging
draft: true
---

[@nqounet](https://x.com/nqounet)です。

前回の記事では、エラーハンドリングの基礎について学びました。適切なエラーコードとメッセージを返すことで、クライアントが問題を正確に把握できるようになりました。

今回は、JSON-RPC 2.0の特徴的な機能の一つである「通知（Notification）」について深く掘り下げます。通知は、レスポンスを期待しない一方向のリクエストで、ログ送信やイベント通知など、結果を待つ必要がない処理に適しています。

通知を使いこなすことで、通信量を削減し、パフォーマンスを向上させることができます。

## 通知（Notification）とは

JSON-RPC 2.0の仕様では、`id`フィールドを持たないリクエストは「通知」として扱われます。通知は、サーバーからレスポンスが返されないことが保証されています。

### 通常のリクエスト（レスポンスあり）

```json
{
  "jsonrpc": "2.0",
  "method": "subtract",
  "params": [42, 23],
  "id": 1
}
```

このリクエストには`id`フィールドがあるため、サーバーは必ず対応するレスポンスを返します：

```json
{
  "jsonrpc": "2.0",
  "result": 19,
  "id": 1
}
```

### 通知リクエスト（レスポンスなし）

```json
{
  "jsonrpc": "2.0",
  "method": "logMessage",
  "params": {"level": "info", "message": "User logged in"}
}
```

`id`フィールドが存在しないため、サーバーはこのリクエストを処理しますが、レスポンスを返しません。クライアントは応答を待つ必要がありません。

## 通知の仕様上の特徴

仕様書から重要なポイントを確認しましょう：

1. **`id`フィールドを含まない**
   - `id`フィールドが存在しない、または`null`でないリクエストが通知として扱われます
   - 仕様では`id`を含めないことが推奨されています

2. **サーバーはレスポンスを返してはいけない**
   - 通知に対して、成功時もエラー時もレスポンスを返しません
   - クライアントは結果を知ることができません

3. **エラーも返されない**
   - メソッドが存在しない場合でも、エラーレスポンスは返されません
   - サーバー側でエラーログは記録できますが、クライアントには通知されません

4. **実行順序の保証はない**
   - サーバーは通知を非同期に処理できます
   - ただし、実装によって同期的に処理することも可能です

## 通知の適切な使用場面

通知は、以下のような場面で特に有効です：

### 1. ログ送信

アプリケーションのログをサーバーに送信する際、各ログメッセージの送信結果を待つ必要はありません：

```json
{
  "jsonrpc": "2.0",
  "method": "log.write",
  "params": {
    "timestamp": "2025-12-07T18:00:00Z",
    "level": "error",
    "message": "Database connection failed",
    "context": {"retry_count": 3}
  }
}
```

### 2. メトリクス収集

パフォーマンスメトリクスや統計情報を定期的に送信する場合：

```json
{
  "jsonrpc": "2.0",
  "method": "metrics.record",
  "params": {
    "metric": "api.response_time",
    "value": 0.125,
    "tags": {"endpoint": "/users", "method": "GET"}
  }
}
```

### 3. イベント通知

ユーザーの行動や状態変化を記録する場合：

```json
{
  "jsonrpc": "2.0",
  "method": "event.track",
  "params": {
    "event": "page_view",
    "user_id": "12345",
    "properties": {"page": "/dashboard", "referrer": "/login"}
  }
}
```

### 4. キャッシュの無効化

他のサーバーに対してキャッシュを削除するよう通知する場合：

```json
{
  "jsonrpc": "2.0",
  "method": "cache.invalidate",
  "params": {"key": "user:12345"}
}
```

## サーバー側での通知の実装

通知を受け取るサーバーを実装してみましょう。`log_server.pl`を作成します：

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use JSON::RPC::Spec;
use Path::Tiny;
use Time::Piece;

my $rpc = JSON::RPC::Spec->new;

# ログファイルのパス
my $log_file = path('application.log');

# ログを記録するメソッド（通知として受け取る）
$rpc->register(
    'log.write' => sub {
        my ($params) = @_;
        
        # パラメータの検証
        unless (ref $params eq 'HASH') {
            warn "log.write: params must be a hash\n";
            return;
        }
        
        unless (exists $params->{level} && exists $params->{message}) {
            warn "log.write: missing required fields (level, message)\n";
            return;
        }
        
        # ログレベルの検証
        my $level = uc($params->{level});
        unless ($level =~ /^(DEBUG|INFO|WARN|ERROR|FATAL)$/) {
            warn "log.write: invalid log level: $level\n";
            return;
        }
        
        # タイムスタンプの取得（パラメータになければ現在時刻）
        my $timestamp = $params->{timestamp} // localtime->datetime;
        
        # ログメッセージの構築
        my $message = $params->{message};
        
        # コンテキスト情報があれば追加
        my $context_str = '';
        if (exists $params->{context} && ref $params->{context} eq 'HASH') {
            my @context_parts;
            for my $key (sort keys %{$params->{context}}) {
                push @context_parts, "$key=$params->{context}{$key}";
            }
            $context_str = ' [' . join(', ', @context_parts) . ']' if @context_parts;
        }
        
        # ログエントリの作成
        my $log_entry = sprintf(
            "[%s] %s: %s%s\n",
            $timestamp,
            $level,
            $message,
            $context_str
        );
        
        # ファイルに追記
        $log_file->append($log_entry);
        
        # 標準出力にも表示（デバッグ用）
        print $log_entry;
        
        # 通知なので戻り値は不要だが、内部処理のために返す
        return 1;
    }
);

# イベントトラッキングメソッド（通知として受け取る）
$rpc->register(
    'event.track' => sub {
        my ($params) = @_;
        
        unless (ref $params eq 'HASH' && exists $params->{event}) {
            warn "event.track: missing event name\n";
            return;
        }
        
        my $event_file = path('events.log');
        
        # イベントログの作成
        my $timestamp = localtime->datetime;
        my $event_name = $params->{event};
        my $user_id = $params->{user_id} // 'anonymous';
        
        my $event_entry = sprintf(
            "[%s] EVENT: %s (user: %s)\n",
            $timestamp,
            $event_name,
            $user_id
        );
        
        # プロパティがあれば追加
        if (exists $params->{properties} && ref $params->{properties} eq 'HASH') {
            for my $key (sort keys %{$params->{properties}}) {
                $event_entry .= sprintf(
                    "  %s: %s\n",
                    $key,
                    $params->{properties}{$key}
                );
            }
        }
        
        $event_file->append($event_entry . "\n");
        print $event_entry;
        
        return 1;
    }
);

# メトリクス記録メソッド（通知として受け取る）
$rpc->register(
    'metrics.record' => sub {
        my ($params) = @_;
        
        unless (ref $params eq 'HASH' && exists $params->{metric} && exists $params->{value}) {
            warn "metrics.record: missing required fields\n";
            return;
        }
        
        my $metrics_file = path('metrics.log');
        
        my $timestamp = localtime->epoch;
        my $metric_name = $params->{metric};
        my $value = $params->{value};
        
        # タグがあれば含める
        my $tags_str = '';
        if (exists $params->{tags} && ref $params->{tags} eq 'HASH') {
            my @tag_parts;
            for my $key (sort keys %{$params->{tags}}) {
                push @tag_parts, "$key=$params->{tags}{$key}";
            }
            $tags_str = ' {' . join(', ', @tag_parts) . '}' if @tag_parts;
        }
        
        my $metric_entry = sprintf(
            "%d %s %s%s\n",
            $timestamp,
            $metric_name,
            $value,
            $tags_str
        );
        
        $metrics_file->append($metric_entry);
        print "METRIC: $metric_entry";
        
        return 1;
    }
);

my $app = sub {
    my ($env) = @_;
    return $rpc->handle($env);
};
```

### コードの解説

1. **ログファイルの管理**
   - `Path::Tiny`モジュールを使ってファイル操作を簡潔に記述しています
   - `append`メソッドで既存のログに追記します

2. **パラメータの検証**
   - 通知でもパラメータの検証は重要です
   - エラーがあっても、クライアントにはレスポンスを返しません
   - 代わりに`warn`でサーバー側のログに記録します

3. **タイムスタンプの扱い**
   - クライアントから`timestamp`が提供されればそれを使用
   - なければサーバー側の現在時刻を使用します

4. **戻り値について**
   - 仕様上、通知にはレスポンスを返しませんが、内部処理のために値を返すことは可能です
   - JSON::RPC::Specは、`id`がないリクエストに対して自動的にレスポンスを抑制します

## クライアント側からの通知送信

通知を送信するクライアントを実装します。`log_client.pl`を作成しましょう：

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use JSON::RPC::Spec::Client;
use Time::Piece;

my $client = JSON::RPC::Spec::Client->new(
    url => 'http://localhost:5000/'
);

# 通知を送信する関数
sub send_notification {
    my ($method, $params) = @_;
    
    # idフィールドを指定せずに呼び出すと通知になる
    $client->notify($method, $params);
    
    # 通知は即座に戻る（レスポンスを待たない）
    print "Notification sent: $method\n";
}

# ログ送信の例
print "=== Sending log notifications ===\n";

send_notification('log.write', {
    level => 'info',
    message => 'Application started',
    context => {
        version => '1.0.0',
        environment => 'production'
    }
});

send_notification('log.write', {
    level => 'debug',
    message => 'Database connection established',
    context => {
        host => 'db.example.com',
        database => 'myapp'
    }
});

send_notification('log.write', {
    level => 'error',
    message => 'Failed to send email',
    context => {
        recipient => 'user@example.com',
        error_code => 'SMTP_TIMEOUT'
    }
});

# イベントトラッキングの例
print "\n=== Sending event notifications ===\n";

send_notification('event.track', {
    event => 'user_login',
    user_id => '12345',
    properties => {
        ip_address => '192.168.1.100',
        user_agent => 'Mozilla/5.0',
        login_method => 'password'
    }
});

send_notification('event.track', {
    event => 'page_view',
    user_id => '12345',
    properties => {
        page => '/dashboard',
        referrer => '/login',
        session_id => 'abc123'
    }
});

# メトリクス記録の例
print "\n=== Sending metrics notifications ===\n";

send_notification('metrics.record', {
    metric => 'api.response_time',
    value => 0.125,
    tags => {
        endpoint => '/users',
        method => 'GET',
        status => '200'
    }
});

send_notification('metrics.record', {
    metric => 'database.query_time',
    value => 0.032,
    tags => {
        query => 'SELECT',
        table => 'users'
    }
});

send_notification('metrics.record', {
    metric => 'cache.hit_rate',
    value => 0.87,
    tags => {
        cache_type => 'redis'
    }
});

print "\nAll notifications sent. Check server logs.\n";
```

### 低レベルAPIを使った通知送信

`JSON::RPC::Spec::Client`の`notify`メソッドが使えない場合、HTTP::Tinyなどを使って直接送信することもできます：

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use HTTP::Tiny;
use JSON::MaybeXS;

my $http = HTTP::Tiny->new;
my $url = 'http://localhost:5000/';

sub send_notification {
    my ($method, $params) = @_;
    
    # 通知リクエストの作成（idフィールドを含めない）
    my $request = {
        jsonrpc => '2.0',
        method  => $method,
        params  => $params,
        # id を含めないことで通知となる
    };
    
    my $json_request = encode_json($request);
    
    # HTTPリクエストを送信
    my $response = $http->post(
        $url,
        {
            content => $json_request,
            headers => { 'Content-Type' => 'application/json' },
        }
    );
    
    # 通知の場合、レスポンスの内容は重要ではない
    # HTTPステータスが成功であれば送信完了
    if ($response->{success}) {
        print "Notification sent: $method\n";
    } else {
        warn "Failed to send notification: $response->{status} $response->{reason}\n";
    }
}

# 使用例
send_notification('log.write', {
    level => 'info',
    message => 'Test log message'
});
```

## 実践例：ログ収集システムの実装

通知の実用的な例として、完全なログ収集システムを実装してみましょう。

### サーバー側（完全版）

`log_collector.pl`を作成します：

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use JSON::RPC::Spec;
use Path::Tiny;
use Time::Piece;
use Fcntl qw(:flock);

my $rpc = JSON::RPC::Spec->new;

# ログディレクトリの設定
my $log_dir = path('logs');
$log_dir->mkpath unless $log_dir->exists;

# ログレベルごとのファイル
my %log_files = (
    DEBUG => $log_dir->child('debug.log'),
    INFO  => $log_dir->child('info.log'),
    WARN  => $log_dir->child('warn.log'),
    ERROR => $log_dir->child('error.log'),
    FATAL => $log_dir->child('fatal.log'),
);

# すべてのログを記録する統合ファイル
my $all_logs = $log_dir->child('all.log');

# ログを安全に書き込む関数
sub write_log_safely {
    my ($file, $content) = @_;
    
    # ファイルロックを使用して同時書き込みを防ぐ
    open my $fh, '>>', $file or do {
        warn "Cannot open log file $file: $!\n";
        return;
    };
    
    flock($fh, LOCK_EX) or do {
        warn "Cannot lock log file $file: $!\n";
        close $fh;
        return;
    };
    
    print $fh $content;
    
    flock($fh, LOCK_UN);
    close $fh;
}

# ログ書き込みメソッド
$rpc->register(
    'log.write' => sub {
        my ($params) = @_;
        
        # パラメータの検証
        unless (ref $params eq 'HASH') {
            warn "log.write: params must be a hash\n";
            return;
        }
        
        my $level = uc($params->{level} // 'INFO');
        my $message = $params->{message} // '';
        my $timestamp = $params->{timestamp} // localtime->datetime;
        
        # ログレベルの検証
        unless ($level =~ /^(DEBUG|INFO|WARN|ERROR|FATAL)$/) {
            warn "log.write: invalid log level: $level\n";
            return;
        }
        
        # アプリケーション情報
        my $app_name = $params->{app} // 'unknown';
        
        # コンテキスト情報の整形
        my $context_str = '';
        if (exists $params->{context} && ref $params->{context} eq 'HASH') {
            my @parts;
            for my $key (sort keys %{$params->{context}}) {
                push @parts, "$key=$params->{context}{$key}";
            }
            $context_str = ' [' . join(', ', @parts) . ']' if @parts;
        }
        
        # ログエントリの作成
        my $log_entry = sprintf(
            "[%s] %s <%s>: %s%s\n",
            $timestamp,
            $level,
            $app_name,
            $message,
            $context_str
        );
        
        # レベル別ファイルに書き込み
        if (exists $log_files{$level}) {
            write_log_safely($log_files{$level}, $log_entry);
        }
        
        # 統合ログにも書き込み
        write_log_safely($all_logs, $log_entry);
        
        # コンソールにも出力
        print $log_entry;
        
        return 1;
    }
);

# ログファイルの取得メソッド（通常のリクエスト）
$rpc->register(
    'log.get' => sub {
        my ($params) = @_;
        
        my $level = uc($params->{level} // 'ALL');
        my $lines = $params->{lines} // 100;
        
        my $file;
        if ($level eq 'ALL') {
            $file = $all_logs;
        } elsif (exists $log_files{$level}) {
            $file = $log_files{$level};
        } else {
            die "Invalid log level: $level";
        }
        
        unless ($file->exists) {
            return {
                level => $level,
                entries => [],
                count => 0
            };
        }
        
        # ファイルの最後のN行を読み込む
        my @all_lines = $file->lines;
        my @last_lines = @all_lines > $lines
            ? @all_lines[-$lines..-1]
            : @all_lines;
        
        return {
            level => $level,
            entries => \@last_lines,
            count => scalar(@last_lines),
            total => scalar(@all_lines)
        };
    }
);

# ログファイルのクリアメソッド（通知）
$rpc->register(
    'log.clear' => sub {
        my ($params) = @_;
        
        my $level = uc($params->{level} // 'ALL');
        
        if ($level eq 'ALL') {
            # すべてのログファイルをクリア
            for my $file (values %log_files, $all_logs) {
                $file->remove if $file->exists;
            }
            print "All log files cleared\n";
        } elsif (exists $log_files{$level}) {
            # 特定レベルのログをクリア
            $log_files{$level}->remove if $log_files{$level}->exists;
            print "Log file cleared: $level\n";
        } else {
            warn "Invalid log level: $level\n";
        }
        
        return 1;
    }
);

my $app = sub {
    my ($env) = @_;
    return $rpc->handle($env);
};
```

### クライアント側（アプリケーション統合例）

実際のアプリケーションに統合する例を示します：

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use JSON::RPC::Spec::Client;
use Time::Piece;

# ログクライアントクラス
package LogClient {
    use Time::Piece;
    
    sub new {
        my ($class, %args) = @_;
        
        my $self = {
            client => JSON::RPC::Spec::Client->new(
                url => $args{url} // 'http://localhost:5000/'
            ),
            app_name => $args{app_name} // 'myapp',
        };
        
        bless $self, $class;
    }
    
    sub _send_log {
        my ($self, $level, $message, $context) = @_;
        
        # 通知として送信（レスポンスを待たない）
        $self->{client}->notify('log.write', {
            level => $level,
            message => $message,
            app => $self->{app_name},
            timestamp => localtime->datetime,
            context => $context // {},
        });
    }
    
    sub debug {
        my ($self, $message, $context) = @_;
        $self->_send_log('debug', $message, $context);
    }
    
    sub info {
        my ($self, $message, $context) = @_;
        $self->_send_log('info', $message, $context);
    }
    
    sub warn {
        my ($self, $message, $context) = @_;
        $self->_send_log('warn', $message, $context);
    }
    
    sub error {
        my ($self, $message, $context) = @_;
        $self->_send_log('error', $message, $context);
    }
    
    sub fatal {
        my ($self, $message, $context) = @_;
        $self->_send_log('fatal', $message, $context);
    }
    
    # ログの取得（通常のリクエスト）
    sub get_logs {
        my ($self, $level, $lines) = @_;
        
        # こちらはレスポンスを待つ
        my $result = $self->{client}->call('log.get', {
            level => $level // 'ALL',
            lines => $lines // 100,
        });
        
        return $result->is_success ? $result->result : undef;
    }
}

package main;

# アプリケーションでの使用例
my $logger = LogClient->new(
    url => 'http://localhost:5000/',
    app_name => 'user_service',
);

# 様々なレベルのログを送信
$logger->info('Application started');

$logger->debug('Loading configuration', {
    config_file => '/etc/myapp/config.yml',
    environment => 'production',
});

$logger->info('Database connection established', {
    host => 'db.example.com',
    database => 'users',
});

# エラーシミュレーション
eval {
    # 何か危険な処理
    die "Something went wrong!";
};
if ($@) {
    $logger->error('Operation failed', {
        error => $@,
        operation => 'dangerous_task',
    });
}

$logger->warn('High memory usage detected', {
    usage_mb => 1024,
    threshold_mb => 800,
});

# 通知は即座に戻るため、ここまで瞬時に実行される
print "All logs sent (notifications are fire-and-forget)\n";

# ログを取得する場合は通常のリクエスト
print "\n=== Retrieving recent logs ===\n";
my $logs = $logger->get_logs('ERROR', 10);

if ($logs) {
    print "Found $logs->{count} error logs:\n";
    for my $entry (@{$logs->{entries}}) {
        print $entry;
    }
}
```

## 通知使用時の注意点

通知を使用する際は、以下の点に注意が必要です：

### 1. 結果の確認ができない

通知はレスポンスが返らないため、以下のことが確認できません：

- メソッドが実際に実行されたか
- パラメータが正しかったか
- サーバー側でエラーが発生したか

**対策**：重要な処理には通知を使わず、通常のリクエストを使用する

### 2. 信頼性の問題

ネットワークエラーやサーバーエラーが発生しても、クライアントは気付けません：

**対策**：
- クリティカルではない処理にのみ使用する
- 必要に応じてローカルにもログを保存する
- 定期的に通常のリクエストで状態を確認する

### 3. デバッグの難しさ

通知が正しく届いているかの確認が難しくなります：

**対策**：
- サーバー側で詳細なログを記録する
- 開発環境では通常のリクエストも併用する
- モニタリングツールを導入する

### 4. 順序の保証

仕様上、通知の処理順序は保証されません：

**対策**：
- タイムスタンプを含める
- 順序が重要な場合は通常のリクエストを使用する
- または、シーケンス番号を付与する

## まとめ

この記事では、JSON-RPC 2.0の通知機能について学びました：

- **通知の定義**：`id`フィールドを持たないリクエストで、レスポンスが返らない
- **適切な使用場面**：ログ送信、メトリクス収集、イベント通知など
- **サーバー実装**：通知を受け取り、ファイルに記録する処理
- **クライアント実装**：`notify`メソッドを使った通知の送信
- **実践例**：ログ収集システムの完全な実装
- **注意点**：結果確認ができない、信頼性、デバッグの難しさ

通知を適切に使用することで、不要な通信を削減し、アプリケーションのパフォーマンスを向上させることができます。ただし、重要な処理や結果の確認が必要な場合は、通常のリクエストを使用することが重要です。

次回は、複数のリクエストをまとめて送信する「バッチリクエスト」について解説します。通知とバッチリクエストを組み合わせることで、さらに効率的な通信が可能になります。

## 参考リンク

- {{< linkcard "https://www.jsonrpc.org/specification" >}}
- {{< linkcard "https://metacpan.org/pod/JSON::RPC::Spec" >}}
- {{< linkcard "https://metacpan.org/pod/JSON::RPC::Spec::Client" >}}
