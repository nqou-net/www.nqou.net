---
title: "認証と認可 - セキュアなAPIの実装"
description: "JSON-RPCサーバーに認証機能を追加し、トークンベースの認証を実装、メソッドごとのアクセス制御を行います。"
tags:
  - json-rpc
  - perl
  - authentication
  - authorization
  - security
draft: true
---

[@nqounet](https://x.com/nqounet)です。

前回の記事では、実践的なサーバー設計について学び、メソッドのモジュール化や共通処理の実装、設定管理など、保守性の高い実装を構築しました。

しかし、実務でAPIを公開する際には、「誰がアクセスしているのか」「そのユーザーは何を実行できるのか」を制御する必要があります。これが認証（Authentication）と認可（Authorization）です。

今回は、JSON-RPCサーバーにトークンベースの認証機能を追加し、メソッドごとにアクセス制御を行う実装を構築していきます。セキュアなAPIの基礎を、実際に動くコードとともに学んでいきましょう。

## 認証と認可の違い

まず、混同しやすい2つの概念を明確にしておきましょう。

### 認証（Authentication）

「あなたは誰ですか？」という問いに答えるプロセスです。

- ユーザー名とパスワードでログイン
- トークンやAPIキーの検証
- セッションの確認

### 認可（Authorization）

「あなたは何ができますか？」という問いに答えるプロセスです。

- ユーザーの役割（ロール）に基づくアクセス制御
- リソースごとの権限チェック
- 操作の許可/拒否の判断

今回の実装では、**トークンベースの認証**と**メソッドレベルでの認可**を組み合わせます。

## JSON-RPCでの認証情報の送信

JSON-RPC 2.0の仕様自体には認証の仕組みは定義されていません。しかし、HTTPトランスポートを使う場合、HTTPヘッダーを利用して認証情報を送ることができます。

### HTTPヘッダーを使った認証

最も一般的な方法は、`Authorization`ヘッダーを使うことです：

```
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

この形式は、OAuth 2.0やJWTなど、多くの認証システムで採用されている標準的な方法です。

## 実装の全体像

今回実装するシステムの構成：

1. **認証サーバー部分**
   - `login`メソッド：ユーザー名とパスワードでトークンを発行
   - トークン検証機能：リクエストごとにトークンをチェック

2. **保護されたメソッド群**
   - `getUserInfo`：ログインユーザーの情報を取得
   - `updateProfile`：プロフィールを更新
   - `adminOnly`：管理者専用メソッド

3. **アクセス制御機構**
   - メソッドごとに必要な権限を定義
   - トークンから権限を取得し、実行可否を判定

## セキュアなJSON-RPCサーバーの実装

それでは、認証機能を持つJSON-RPCサーバーを実装していきましょう。

### サーバー本体（auth_server.pl）

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use utf8;
use JSON::RPC::Spec;
use Plack::Request;
use Digest::SHA qw(sha256_hex);
use JSON;

# トークンストア（本番環境ではRedisやDBを使用）
my %tokens;

# ユーザーデータベース（本番環境ではDBを使用）
my %users = (
    'alice' => {
        password => sha256_hex('alice123'),  # ハッシュ化されたパスワード
        role     => 'admin',
        email    => 'alice@example.com',
        name     => 'Alice Admin',
    },
    'bob' => {
        password => sha256_hex('bob123'),
        role     => 'user',
        email    => 'bob@example.com',
        name     => 'Bob User',
    },
);

# トークン生成関数
sub generate_token {
    my ($username) = @_;
    my $token = sha256_hex($username . time() . rand());
    return $token;
}

# トークン検証関数
sub verify_token {
    my ($token) = @_;
    return unless $token;
    return $tokens{$token};
}

# 認証が必要なメソッドの定義
my %protected_methods = (
    getUserInfo   => 'user',   # 一般ユーザー権限が必要
    updateProfile => 'user',   # 一般ユーザー権限が必要
    adminOnly     => 'admin',  # 管理者権限が必要
);

# JSON-RPC ハンドラー
my $rpc = JSON::RPC::Spec->new;

# ログインメソッド（認証不要）
$rpc->register(
    login => sub {
        my ($params) = @_;
        
        # パラメータチェック
        my $username = $params->{username};
        my $password = $params->{password};
        
        unless ($username && $password) {
            die JSON::RPC::Spec::Error->new(
                code    => -32602,
                message => "ユーザー名とパスワードが必要です",
            );
        }
        
        # ユーザー存在チェック
        my $user = $users{$username};
        unless ($user) {
            die JSON::RPC::Spec::Error->new(
                code    => -32001,
                message => "認証に失敗しました",
            );
        }
        
        # パスワード検証
        my $password_hash = sha256_hex($password);
        unless ($password_hash eq $user->{password}) {
            die JSON::RPC::Spec::Error->new(
                code    => -32001,
                message => "認証に失敗しました",
            );
        }
        
        # トークン生成
        my $token = generate_token($username);
        $tokens{$token} = {
            username => $username,
            role     => $user->{role},
            created  => time(),
        };
        
        return {
            token    => $token,
            username => $username,
            role     => $user->{role},
        };
    }
);

# ユーザー情報取得メソッド（認証必要）
$rpc->register(
    getUserInfo => sub {
        my ($params, $context) = @_;
        
        my $user_info = $context->{user};
        my $username = $user_info->{username};
        
        my $user = $users{$username};
        
        return {
            username => $username,
            email    => $user->{email},
            name     => $user->{name},
            role     => $user->{role},
        };
    }
);

# プロフィール更新メソッド（認証必要）
$rpc->register(
    updateProfile => sub {
        my ($params, $context) = @_;
        
        my $user_info = $context->{user};
        my $username = $user_info->{username};
        
        # 更新可能なフィールド
        my $name = $params->{name};
        my $email = $params->{email};
        
        if ($name) {
            $users{$username}{name} = $name;
        }
        
        if ($email) {
            $users{$username}{email} = $email;
        }
        
        return {
            message  => "プロフィールを更新しました",
            username => $username,
            name     => $users{$username}{name},
            email    => $users{$username}{email},
        };
    }
);

# 管理者専用メソッド（管理者権限必要）
$rpc->register(
    adminOnly => sub {
        my ($params, $context) = @_;
        
        my $user_info = $context->{user};
        
        return {
            message => "管理者専用の機能にアクセスしました",
            user    => $user_info->{username},
            role    => $user_info->{role},
        };
    }
);

# ログアウトメソッド（認証必要）
$rpc->register(
    logout => sub {
        my ($params, $context) = @_;
        
        my $token = $context->{token};
        delete $tokens{$token};
        
        return {
            message => "ログアウトしました",
        };
    }
);

# PSGIアプリケーション
my $app = sub {
    my $env = shift;
    my $req = Plack::Request->new($env);
    
    # Authorizationヘッダーからトークンを取得
    my $auth_header = $req->header('Authorization') || '';
    my $token;
    if ($auth_header =~ /^Bearer\s+(.+)$/) {
        $token = $1;
    }
    
    # リクエストボディを取得
    my $body = $req->content;
    
    # JSON-RPCリクエストをパース
    my $request;
    eval {
        $request = decode_json($body);
    };
    if ($@) {
        my $error_response = $rpc->error_response(
            undef,
            -32700,
            "Parse error"
        );
        return [
            200,
            ['Content-Type' => 'application/json'],
            [encode_json($error_response)]
        ];
    }
    
    # メソッド名を取得
    my $method = ref($request) eq 'ARRAY' 
        ? $request->[0]{method} 
        : $request->{method};
    
    # 認証チェック
    my $context = {};
    
    if ($protected_methods{$method}) {
        # 保護されたメソッドの場合、トークン検証
        unless ($token) {
            my $error_response = {
                jsonrpc => "2.0",
                error   => {
                    code    => -32002,
                    message => "認証が必要です",
                },
                id => ref($request) eq 'ARRAY' 
                    ? $request->[0]{id} 
                    : $request->{id},
            };
            return [
                401,
                ['Content-Type' => 'application/json'],
                [encode_json($error_response)]
            ];
        }
        
        my $user_info = verify_token($token);
        unless ($user_info) {
            my $error_response = {
                jsonrpc => "2.0",
                error   => {
                    code    => -32003,
                    message => "無効なトークンです",
                },
                id => ref($request) eq 'ARRAY' 
                    ? $request->[0]{id} 
                    : $request->{id},
            };
            return [
                401,
                ['Content-Type' => 'application/json'],
                [encode_json($error_response)]
            ];
        }
        
        # 認可チェック
        my $required_role = $protected_methods{$method};
        if ($required_role eq 'admin' && $user_info->{role} ne 'admin') {
            my $error_response = {
                jsonrpc => "2.0",
                error   => {
                    code    => -32004,
                    message => "このメソッドを実行する権限がありません",
                },
                id => ref($request) eq 'ARRAY' 
                    ? $request->[0]{id} 
                    : $request->{id},
            };
            return [
                403,
                ['Content-Type' => 'application/json'],
                [encode_json($error_response)]
            ];
        }
        
        # コンテキストにユーザー情報を設定
        $context->{user} = $user_info;
        $context->{token} = $token;
    }
    
    # JSON-RPCリクエストを処理
    my $response;
    if (ref($request) eq 'ARRAY') {
        # バッチリクエスト
        my @responses;
        for my $req (@$request) {
            my $res = eval {
                $rpc->call($req->{method}, $req->{params}, $context);
            };
            if ($@) {
                push @responses, $rpc->error_response(
                    $req->{id},
                    -32603,
                    "Internal error: $@"
                );
            } else {
                push @responses, {
                    jsonrpc => "2.0",
                    result  => $res,
                    id      => $req->{id},
                };
            }
        }
        $response = \@responses;
    } else {
        # 単一リクエスト
        my $result = eval {
            $rpc->call($request->{method}, $request->{params}, $context);
        };
        if ($@) {
            if (ref($@) eq 'JSON::RPC::Spec::Error') {
                $response = {
                    jsonrpc => "2.0",
                    error   => {
                        code    => $@->code,
                        message => $@->message,
                        (defined $@->data ? (data => $@->data) : ()),
                    },
                    id => $request->{id},
                };
            } else {
                $response = $rpc->error_response(
                    $request->{id},
                    -32603,
                    "Internal error: $@"
                );
            }
        } else {
            $response = {
                jsonrpc => "2.0",
                result  => $result,
                id      => $request->{id},
            };
        }
    }
    
    return [
        200,
        ['Content-Type' => 'application/json'],
        [encode_json($response)]
    ];
};

return $app;
```

### クライアント実装（auth_client.pl）

認証機能を使うクライアントも実装しましょう。

```perl
#!/usr/bin/env perl
use strict;
use warnings;
use utf8;
use LWP::UserAgent;
use JSON;

my $ua = LWP::UserAgent->new;
my $url = 'http://localhost:5000/';

# トークンを保持する変数
my $auth_token;

# JSON-RPCリクエストを送信する関数
sub call_rpc {
    my ($method, $params, $id) = @_;
    $id //= 1;
    
    my $request = {
        jsonrpc => "2.0",
        method  => $method,
        params  => $params,
        id      => $id,
    };
    
    my %headers = ('Content-Type' => 'application/json');
    
    # トークンがあればAuthorizationヘッダーに設定
    if ($auth_token) {
        $headers{Authorization} = "Bearer $auth_token";
    }
    
    my $res = $ua->post(
        $url,
        %headers,
        Content => encode_json($request),
    );
    
    unless ($res->is_success) {
        die "HTTP Error: " . $res->status_line;
    }
    
    return decode_json($res->content);
}

print "=== JSON-RPC 認証デモ ===\n\n";

# 1. 認証なしで保護されたメソッドを呼ぼうとする（失敗するはず）
print "1. 認証なしでgetUserInfoを呼び出し:\n";
my $result = call_rpc('getUserInfo', {}, 1);
if ($result->{error}) {
    print "   エラー: $result->{error}{message}\n";
    print "   コード: $result->{error}{code}\n\n";
}

# 2. ログイン（トークン取得）
print "2. aliceでログイン:\n";
$result = call_rpc('login', {
    username => 'alice',
    password => 'alice123',
}, 2);

if ($result->{result}) {
    $auth_token = $result->{result}{token};
    print "   ログイン成功！\n";
    print "   トークン: " . substr($auth_token, 0, 20) . "...\n";
    print "   ユーザー: $result->{result}{username}\n";
    print "   役割: $result->{result}{role}\n\n";
} else {
    print "   エラー: $result->{error}{message}\n\n";
    exit 1;
}

# 3. ユーザー情報取得（認証済み）
print "3. getUserInfoを呼び出し（認証済み）:\n";
$result = call_rpc('getUserInfo', {}, 3);
if ($result->{result}) {
    print "   ユーザー名: $result->{result}{username}\n";
    print "   名前: $result->{result}{name}\n";
    print "   Email: $result->{result}{email}\n";
    print "   役割: $result->{result}{role}\n\n";
}

# 4. プロフィール更新
print "4. プロフィールを更新:\n";
$result = call_rpc('updateProfile', {
    name  => 'Alice Administrator',
    email => 'alice.admin@example.com',
}, 4);
if ($result->{result}) {
    print "   $result->{result}{message}\n";
    print "   新しい名前: $result->{result}{name}\n";
    print "   新しいEmail: $result->{result}{email}\n\n";
}

# 5. 管理者専用メソッド（aliceは管理者なので成功）
print "5. 管理者専用メソッドを呼び出し:\n";
$result = call_rpc('adminOnly', {}, 5);
if ($result->{result}) {
    print "   $result->{result}{message}\n";
    print "   ユーザー: $result->{result}{user}\n";
    print "   役割: $result->{result}{role}\n\n";
}

# 6. ログアウト
print "6. ログアウト:\n";
$result = call_rpc('logout', {}, 6);
if ($result->{result}) {
    print "   $result->{result}{message}\n\n";
    $auth_token = undef;
}

# 7. ログアウト後に保護されたメソッドを呼ぶ（失敗するはず）
print "7. ログアウト後にgetUserInfoを呼び出し:\n";
$result = call_rpc('getUserInfo', {}, 7);
if ($result->{error}) {
    print "   エラー: $result->{error}{message}\n";
    print "   コード: $result->{error}{code}\n\n";
}

# 8. bobでログイン（一般ユーザー）
print "8. bobでログイン:\n";
$result = call_rpc('login', {
    username => 'bob',
    password => 'bob123',
}, 8);

if ($result->{result}) {
    $auth_token = $result->{result}{token};
    print "   ログイン成功！\n";
    print "   ユーザー: $result->{result}{username}\n";
    print "   役割: $result->{result}{role}\n\n";
}

# 9. bobで管理者専用メソッドを呼ぶ（失敗するはず）
print "9. 一般ユーザーで管理者専用メソッドを呼び出し:\n";
$result = call_rpc('adminOnly', {}, 9);
if ($result->{error}) {
    print "   エラー: $result->{error}{message}\n";
    print "   コード: $result->{error}{code}\n\n";
}

print "=== デモ終了 ===\n";
```

## 実行してみよう

### サーバーの起動

```bash
plackup auth_server.pl
```

### クライアントの実行

別のターミナルで：

```bash
chmod +x auth_client.pl
./auth_client.pl
```

### 実行結果

```
=== JSON-RPC 認証デモ ===

1. 認証なしでgetUserInfoを呼び出し:
   エラー: 認証が必要です
   コード: -32002

2. aliceでログイン:
   ログイン成功！
   トークン: 1a2b3c4d5e6f7g8h9i0j...
   ユーザー: alice
   役割: admin

3. getUserInfoを呼び出し（認証済み）:
   ユーザー名: alice
   名前: Alice Admin
   Email: alice@example.com
   役割: admin

4. プロフィールを更新:
   プロフィールを更新しました
   新しい名前: Alice Administrator
   新しいEmail: alice.admin@example.com

5. 管理者専用メソッドを呼び出し:
   管理者専用の機能にアクセスしました
   ユーザー: alice
   役割: admin

6. ログアウト:
   ログアウトしました

7. ログアウト後にgetUserInfoを呼び出し:
   エラー: 認証が必要です
   コード: -32002

8. bobでログイン:
   ログイン成功！
   ユーザー: bob
   役割: user

9. 一般ユーザーで管理者専用メソッドを呼び出し:
   エラー: このメソッドを実行する権限がありません
   コード: -32004

=== デモ終了 ===
```

## カスタムエラーコードの定義

今回の実装では、以下のカスタムエラーコードを定義しました：

| コード | 意味 | 説明 |
|--------|------|------|
| -32001 | 認証失敗 | ユーザー名またはパスワードが間違っている |
| -32002 | 認証が必要 | 保護されたメソッドにアクセスするにはログインが必要 |
| -32003 | 無効なトークン | トークンが期限切れまたは不正 |
| -32004 | 権限不足 | メソッドを実行する権限がない |

これらは、JSON-RPC 2.0の仕様で定義されている範囲外（-32000から-32099がサーバーエラー用に予約）のコードです。

## セキュリティ上の考慮事項

今回の実装はデモ用のため、実運用では以下の点を改善する必要があります：

### 本番環境への移行時の改善点

1. **パスワードのハッシュ化強化**
   - SHA-256ではなく、bcryptやArgon2などの強固なハッシュ関数を使用
   - ソルトの追加
   - ストレッチング（反復処理）

2. **トークンの有効期限**
   - トークンに有効期限を設定
   - リフレッシュトークンの実装

3. **セッションストアの外部化**
   - RedisやMemcachedなどのインメモリDBを使用
   - データベースへの永続化

4. **HTTPS必須**
   - トークンは平文で送信されるため、必ずHTTPSを使用
   - HTTP Strict Transport Security (HSTS)の設定

5. **レート制限**
   - ログイン試行の制限
   - APIコールの頻度制限

6. **監査ログ**
   - 認証の成功/失敗を記録
   - 不審なアクティビティの検知

### JWT（JSON Web Token）の利用

より本格的な実装では、JWTの使用を検討しましょう：

```perl
use Crypt::JWT qw(encode_jwt decode_jwt);

# トークン生成
my $token = encode_jwt(
    payload => {
        username => $username,
        role     => $user->{role},
        exp      => time() + 3600,  # 1時間後に期限切れ
    },
    key => $secret_key,
    alg => 'HS256',
);

# トークン検証
my $payload = decode_jwt(
    token => $token,
    key   => $secret_key,
);
```

## まとめ

今回は、JSON-RPCサーバーに認証と認可の機能を追加しました。

### 学んだこと

1. **HTTPヘッダーを使った認証**
   - `Authorization: Bearer`形式でトークンを送信
   - 標準的な方法で多くのツールと互換性がある

2. **トークンベースの認証**
   - ログイン時にトークンを発行
   - 以降のリクエストでトークンを使って認証

3. **メソッドレベルでの認可**
   - メソッドごとに必要な権限を定義
   - ロールベースでアクセス制御

4. **コンテキストを使った情報共有**
   - 認証情報をメソッドに渡す仕組み
   - メソッド内でユーザー情報を利用可能に

### 次回予告

次回は、JSON-RPCサーバーのテストについて学びます。

- 単体テストの書き方
- モックを使った認証のテスト
- 統合テストの実装
- テストカバレッジの測定

実運用に耐えるサーバーを作るには、テストが不可欠です。次回もお楽しみに！
