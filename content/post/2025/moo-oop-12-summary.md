---
title: "第12回-Mooで覚えるオブジェクト指向プログラミング"
draft: true
tags:
  - perl
  - moo
  - object-oriented
description: "連載の総復習として完成版BBSを確認し、次のステップへの道筋を示します"
---

[@nqounet](https://twitter.com/nqounet)です。

「Mooで覚えるオブジェクト指向プログラミング」も、ついに最終回を迎えました。第1回でMooを使った最初の一歩を踏み出してから、ここまで一緒に歩んできてくださり、ありがとうございます。

今回は、全12回の連載を振り返りながら、完成した掲示板システムの全体像を確認し、次のステップへの道筋をお伝えします。

## 連載で学んだこと

まずは、この連載で何を学んできたのかを振り返ってみましょう。

### 第1回〜第2回：Mooとの出会い

最初に、Mooを使った簡単なプログラムを動かし、`package`、`has`、`sub`といった基本的な構文を学びました。そして第2回では、オブジェクト指向の核となる`$self`の役割を理解しました。

- `package`でクラス（設計図）を定義する
- `has`でプロパティ（属性）を定義する
- `sub`でメソッド（機能）を定義する
- `$self`は「メソッドを呼び出したオブジェクト自身」を指す

### 第3回〜第4回：スパゲティコードからの脱却

配列だけで作った素朴なチャットが、なぜ「スパゲティコード」と呼ばれる状態になるのかを体験しました。そして、Messageクラスを作ることで、データを1つのオブジェクトにまとめる利点を学びました。

- データが散らばっていると管理が大変になる
- 関連するデータをオブジェクトにまとめることでコードがスッキリする
- クラスは「設計図」、オブジェクトは「設計図から作った実体」である

### 第5回〜第6回：データを守る

カプセル化の概念を学び、`is => 'ro'`と`is => 'rw'`の使い分けを理解しました。また、`required`や`default`、`builder`を使って、オブジェクト作成時の初期化を制御する方法も習得しました。

- `is => 'ro'`で読み取り専用、`is => 'rw'`で読み書き可能
- カプセル化とは、データを外から守り、必要な機能だけを公開する考え方である
- `required`で必須項目、`default`や`builder`でデフォルト値を設定できる

### 第7回：メソッドで機能を追加

Boardクラスを作成し、投稿の追加・一覧表示・投稿数の取得といった機能をメソッドとして実装しました。クラスを組み合わせて使うことで、責任を分離できることを学びました。

- メソッドは`sub メソッド名 { ... }`で定義する
- プロパティが「オブジェクトが持つデータ」なら、メソッドは「オブジェクトが持つ機能」である

### 第8回：継承でコードを再利用

`extends`を使った継承を学び、MessageクラスからThreadクラスを作成しました。親クラスの機能を引き継ぎつつ、新しい機能を追加できることを体験しました。

- 継承は親クラスの機能を子クラスに引き継ぐ仕組みである
- 子クラスで同じ名前のメソッドを定義するとオーバーライドできる

### 第9回：委譲で柔軟に

Userクラスを作成し、`handles`（委譲）でメソッドを転送する方法を学びました。継承が「is-a関係」なら、委譲は「has-a関係」であることを理解しました。

- 委譲はあるオブジェクトへのメソッド呼び出しを別のオブジェクトに転送する仕組みである
- 継承は「AはBの一種」、委譲は「AはBを持つ」で使い分ける

### 第10回：Roleで横断的な機能を共有

Moo::Roleを使って共通機能を定義し、`with`で複数のクラスに適用する方法を学びました。継承関係にないクラス同士でも機能を共有できることを知りました。

- Roleは複数のクラスに共通する機能をまとめたものである
- `with 'Role名'`でRoleをクラスに適用する
- `requires`でRoleが期待するメソッドを強制できる

### 第11回：多態性で拡張性を高める

管理者と一般ユーザーを例に、多態性（ポリモーフィズム）とダックタイピングの概念を学びました。型を気にせずメソッドを呼び出せることで、コードの保守性と拡張性が高まることを理解しました。

- 多態性とは「同じメソッド名で、オブジェクトの種類によって異なる動作をする」という性質である
- ダックタイピングは「型」ではなく「何ができるか」で判断する考え方である

## 完成した掲示板の全体像

さて、ここまで学んできた概念をすべて活用して、掲示板システムは完成しました。ここで、各クラスの関係を整理してみましょう。

### クラスの関係図

この掲示板システムは、以下のクラスとRoleで構成されています。

- **Timestampable（Role）**：タイムスタンプ機能を提供。`created_at`プロパティと`formatted_time`メソッドを持つ
- **User**：一般ユーザーを表す。`id`、`name`を持ち、`can_delete`メソッドは0を返す
- **AdminUser**：管理者を表す。Userを継承し、`can_delete`メソッドは1を返す
- **Message**：1つの投稿を表す。Timestampableを適用し、Userへの委譲で投稿者名を取得できる
- **Board**：掲示板全体を表す。複数のMessageを管理し、追加・一覧表示・カウント機能を持つ

### 完成版コード

それでは、完成した掲示板システムのコードを見てみましょう。

```perl
# 完成版 簡易掲示板システム

# タイムスタンプ機能（Role）
package Timestampable {
    use Moo::Role;
    has created_at => (is => 'ro', builder => sub { time() });
    sub formatted_time {
        my $self = shift;
        return scalar localtime($self->created_at);
    }
};

# ユーザー
package User {
    use Moo;
    has id   => (is => 'ro', required => 1);
    has name => (is => 'rw', required => 1);
    sub can_delete { return 0; }
};

# 管理者
package AdminUser {
    use Moo;
    extends 'User';
    sub can_delete { return 1; }
};

# メッセージ
package Message {
    use Moo;
    with 'Timestampable';
    has author => (is => 'ro', required => 1, handles => [qw(name)]);
    has body   => (is => 'rw', required => 1);
    sub show {
        my $self = shift;
        print '[' . $self->formatted_time . '] ';
        print $self->name . ': ' . $self->body . "\n";
    }
};

# 掲示板
package Board {
    use Moo;
    has messages => (is => 'rw', default => sub { [] });
    sub add { push @{shift->messages}, shift; }
    sub show_all { $_->show for @{shift->messages}; }
    sub count { return scalar @{shift->messages}; }
};

# 使用例
my $admin = AdminUser->new(id => 1, name => '管理人');
my $user  = User->new(id => 2, name => '太郎');

my $board = Board->new;
$board->add(Message->new(author => $admin, body => '掲示板へようこそ！'));
$board->add(Message->new(author => $user, body => 'こんにちは！'));

print "=== 投稿一覧（" . $board->count . "件）===\n";
$board->show_all;
```

このコードには、連載で学んだすべての概念が詰まっています。

- **Moo::Role**でTimestampableを定義し、Messageに適用している
- **継承**でAdminUserがUserを拡張している
- **委譲**でMessageがauthorのnameメソッドを転送している
- **カプセル化**で適切に`ro`/`rw`を使い分けている
- **多態性**でUserとAdminUserが同じインターフェースで扱える

## オブジェクト指向の良さを実感する

### スパゲティコードとの比較

第3回で作った「配列だけのチャット」を思い出してください。投稿者とメッセージが別々の配列に散らばっていて、機能を追加するたびに複数の場所を修正しなければなりませんでした。

オブジェクト指向で書き直した今のコードは、どうでしょうか。

- 投稿者の情報はUserクラスに集約されている
- メッセージの情報はMessageクラスに集約されている
- 掲示板の管理はBoardクラスが担当している

それぞれのクラスが明確な責任を持ち、変更の影響範囲が限定されています。

### 機能追加が簡単になった

例えば「投稿にいいねボタンをつけたい」となったら、どうすればいいでしょうか。

オブジェクト指向なら、Messageクラスに`likes`プロパティと`add_like`メソッドを追加するだけです。BoardクラスやUserクラスを変更する必要はありません。

「モデレーター」という新しいユーザー種別が必要になったら？Userを継承したModeratorクラスを作り、`can_delete`メソッドをオーバーライドするだけです。既存のコードを変更せずに、新しい機能を追加できます。

これがオブジェクト指向の強みです。コードが整理されているから、変更が楽になる。変更が楽だから、機能追加を恐れずに済む。そして、より良いソフトウェアを作り続けることができるのです。

## 次のステップ

Mooでオブジェクト指向の基礎を学んだあなたには、さらに広い世界が待っています。ここでは、次のステップとしておすすめの道筋を紹介します。

### Mooseへのステップアップ

MooはMooseの軽量版として設計されています。Mooで学んだ概念は、ほぼそのままMooseでも使えます。

Mooseでは、より高度な型制約、遅延評価、メタプログラミングなどの機能が利用できます。大規模なアプリケーションを開発する際には、Mooseの機能が役立つでしょう。

{{< linkcard "https://metacpan.org/pod/Moose" >}}

### テスト（Test::More, Test2）

プロダクションコードを書くなら、テストは欠かせません。Perlには優れたテストフレームワークがあります。

Test::Moreは長年Perlのテストの標準として使われてきました。最近ではTest2という新しいフレームワークも人気です。作成したクラスが正しく動作することを確認するために、ぜひテストを書く習慣を身につけてください。

{{< linkcard "https://metacpan.org/pod/Test::More" >}}

### Webフレームワーク（Mojolicious, Dancer2）

今回作った掲示板をWebアプリケーションにしたいなら、Webフレームワークを学びましょう。

Mojoliciousは、リアルタイムWebアプリケーションにも対応した強力なフレームワークです。Dancer2は、シンプルで学びやすいフレームワークとして人気があります。どちらもMooやMooseと相性が良いので、今回学んだオブジェクト指向の知識がそのまま活かせます。

{{< linkcard "https://metacpan.org/pod/Mojolicious" >}}

{{< linkcard "https://metacpan.org/pod/Dancer2" >}}

## まとめ

全12回にわたる「Mooで覚えるオブジェクト指向プログラミング」、いかがでしたでしょうか。

この連載で学んだことをまとめると、以下のようになります。

- オブジェクト指向は「関連するデータと機能をまとめる」考え方である
- クラスは設計図、オブジェクトは設計図から作った実体である
- カプセル化でデータを守り、外部からの不正な変更を防ぐ
- 継承でコードを再利用し、親クラスの機能を子クラスに引き継ぐ
- 委譲でオブジェクト間の協調を実現し、柔軟な設計を可能にする
- Roleで横断的な機能を複数のクラスで共有できる
- 多態性で型を気にせずメソッドを呼び出せ、拡張性が高まる

オブジェクト指向は、最初は難しく感じるかもしれません。しかし、一度理解すれば、コードを整理し、保守しやすくするための強力な武器になります。

この連載が、あなたのPerlプログラミングの旅の一助になれば幸いです。

Happy Hacking!
