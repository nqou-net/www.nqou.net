---
title: "GitHub Copilot 使い分けガイド決定版｜月 118/300 リクエストから学ぶ生産性向上の実践法"
draft: true
tags:
  - github-copilot
  - copilot
  - premium-requests
  - developer-productivity
  - ai-tools
description: "プレミアムリクエスト 118/300（39%）の実測データから導く、Web・エディタ・CLI の最適な使い分け戦略と生産性 2 倍化のロードマップ"
---

[@nqounet](https://x.com/nqounet)です。

GitHub Copilot Pro を使っていますが、月間 300 のプレミアムリクエストのうち、わずか 118 しか使えていないことに気づきました。活用率 39% という数字を見て、正直「もったいない使い方をしていたのではないか」と感じました。

しかし、使用状況を分析してみると、実は 3 つのインターフェース（Web UI・エディタ・CLI）を**無意識に使い分けていた**ことが分かりました。この使い分けパターンを意識化することで、さらなる生産性向上の可能性が見えてきました。

本記事では、実体験に基づく 118 リクエストの内訳分析から、それぞれのインターフェースの最適な使い方、そして生産性を 2 倍にするための実践法をお伝えします。

## GitHub Copilot、39% しか使えていなかった理由

### 月間 300 リクエストのうち 118（39%）しか使用していない現実

GitHub Copilot の課金ダッシュボードを確認すると、以下の状況でした。

- **月間プレミアムリクエスト**: 118/300（39% 活用）
- **残り日数**: 5 日で 182 リクエスト残
- **月初の目標**: プレミアムリクエストを使い切る

11 月は見事に 100% 使い切りました。しかし、12 月に入って少し冷静になり、「本当に使い切ることが目的なのか」と考え直しました。

### なぜ使いこなせていなかったのか？

振り返ってみると、以下のような状況でした。

- Web UI、エディタ、CLI の特性を理解していなかった
- どのインターフェースが何に向いているかを知らなかった
- プレミアムリクエストの消費パターンを把握していなかった
- 無意識に「もったいない」と思って高度なモデルを避けていた

### 3 つのインターフェースの「無意識な使い分け」を意識化する

しかし、使用状況を詳しく分析すると、実は**直感的に使い分けていた**ことが分かりました。

- **Web UI**: リポジトリ全体の調査や情報整理に使用
- **エディタ**: 実装作業の中心として使用
- **CLI**: 最近導入したばかりで、まだ探り探りの状態

この無意識な使い分けを意識化し、最適化することで、さらに効率的に使えるのではないかと考えました。

## GitHub Copilot 3 つのインターフェースの本質

GitHub Copilot には、それぞれ異なる特性を持つ 3 つのインターフェースがあります。それぞれの核心的な価値と、向いているタスクを整理します。

### Web UI - リポジトリ全体を見渡す「戦略家」

Web UIは、GitHub.comから直接利用できるインターフェースです。

#### 核心価値: Space による永続的なナレッジ管理

Web UI の最大の強みは、**Space** という機能です。Space では以下が可能になります。

- チャット履歴の永続的な管理
- プロジェクトごとのコンテキスト保持
- チーム内でのナレッジ共有
- 過去の調査結果の再利用

Space のチャット履歴は**Conversations として残る**ため、後から検索して参照できます。ただし、現状ではタイトルが途中で切れる問題があり、検索機能の改善が待たれます。

#### 強み: Issue アサインによる自動修正

Web UI では、Issue に Copilot をアサインすることで、自動的にコード修正を行えます。この機能は非常に強力です。

{{< linkcard "https://www.nqou.net/2025/11/29/094241/" >}}

実際に使ってみた体験記事では、その威力と注意点を詳しく解説しています。

- GitHub Actions を使った安全なサンドボックス環境で実行
- 新しいブランチとドラフト PR が自動作成
- マージは必ず人間が行うため、安全性が担保

#### 向いているタスク

Web UIが最も力を発揮するのは、以下のようなタスクです。

- リポジトリ横断的な調査
- チームでの協業とコードレビュー
- 技術調査とドキュメント作成
- Issue の自動修正（単純な修正タスク）

#### 落とし穴

Web UIを使う上で注意すべき点があります。

- **Issue アサインの過信**: 生成されたコードは必ずレビューが必要
- **プレミアムリクエストの大量消費**: 複雑な質問は一度に多くのリクエストを消費
- **ネットワーク依存**: オフラインでは使用不可

#### 著者の使い方

私は主に以下の用途で Web UI を使用しています。

- **チャットで調べ物**: 無料モデル（GPT-4o mini）をよく使用
- **Issue アサイン**: プレミアムリクエストを消費するが、効率的
- **Space 内でチャット**: Conversations として履歴が残るのが便利
- **ウェブが最も扱いやすく洗練されている**と感じています

### エディタ拡張 - コーディングの「相棒」

エディタ拡張（VS Code や JetBrains など）は、開発環境に統合されたインターフェースです。

#### 核心価値: リアルタイムのインライン提案（プレミアムリクエスト消費なし）

エディタ拡張の最大の価値は、**インライン提案**です。これは以下の特徴があります。

- コーディング中にリアルタイムで提案
- タブキーで受け入れるだけで使用可能
- **プレミアムリクエストを消費しない**（無制限に使用可能）
- 関数全体や複数行のコードを一度に提案可能

#### 強み: AgentモードとPlanモードの使い分け

エディタには複数のモードがあり、タスクによって使い分けることができます。

**Agent モード**
- 複数ステップのタスクを自動実行
- ファイルの読み取り、編集、作成を一括で実行可能
- 複雑なリファクタリングに最適

**Plan モード**
- インタラクティブな対話で計画を立てる
- 短文のプロンプトでラリーしながら進行
- 大きめのタスクを段階的に実装

**Ask モード**
- 質問と回答のシンプルなチャット
- 最近はあまり使わなくなった（調べ物は Web へ移行）

#### awesome-copilot でのカスタマイズ

エディタ拡張は、カスタムエージェントで強化できます。

{{< linkcard "https://www.nqou.net/2025/12/06/212332/" >}}

`.github/agents/`ディレクトリにカスタムエージェントを定義することで、プロジェクト固有の知識を持たせることができます。

#### 向いているタスク

エディタ拡張が最も力を発揮するのは、以下のようなタスクです。

- 実装作業全般（新機能開発、バグ修正）
- リファクタリング（小規模から大規模まで）
- テストコード作成
- コードレビューと改善提案

#### 落とし穴

エディタ拡張を使う上で注意すべき点があります。

- **Agent モードのプレミアムリクエスト無意識消費**: 複雑なタスクでは 10-20 リクエストを消費する場合あり
- **過度な期待**: 完璧なコードが生成されるわけではない
- **ワークスペース外の理解不足**: リポジトリ全体のコンテキストは Web UI に劣る

#### 著者の使い方

私のエディタの使い方は以下の通りです。

- **ほぼ Agent モード**: Edit モードでも結局 Agent の方が上手く動く
- **Ask モードは使わなくなった**: 調べ物は Web へ移行
- **短文のプロンプト**: 使い捨て感覚でサクサク依頼
- **すぐできるタスク**: Agent モードでそのまま実行
- **大きめのタスク**: Plan モードで短文ラリー
- **エディタを開いている時間が最も長い**ため、自然と使用頻度も高い

### CLI - ターミナルの「執事」

GitHub Copilot CLIは、ターミナルから直接Copilotを利用できるインターフェースです。

#### 核心価値: 簡潔なレスポンスによる高速サイクル

CLIの最大の特徴は、**レスポンスが短く簡潔**であることです。

- 必要最小限の情報だけを返す
- トークン数が少ないため、プレミアムリクエストの消費が少ない
- インターフェースとして最も軽量
- ターミナルから離れずに作業可能

#### 強み: 最近のアップデートで信頼性向上

2025 年 12 月 10 日のアップデート（v0.0.368）で、以下の改善がありました。

- プレミアムリクエスト表示の修正
- 信頼性とセキュリティの向上
- MCP サーバーのサポート強化

{{< linkcard "https://docs.github.com/en/copilot/how-tos/use-copilot-agents/use-copilot-cli" >}}

#### 主なコマンド

CLIでは以下のコマンドが利用できます。

```bash
# コマンドの説明を取得
gh copilot explain "docker ps -a"

# タスクからコマンドを提案
gh copilot suggest "ポート3000で動いているプロセスを停止"

# インタラクティブなチャット
gh copilot chat

# 設定管理
gh copilot config

# エイリアス設定
gh copilot alias
```

#### 向いているタスク

CLIが最も力を発揮するのは、以下のようなタスクです。

- コマンド生成とスクリプト作成
- コマンドの説明と学習
- DevOps とインフラ作業
- CI/CD パイプラインへの統合

#### 落とし穴

CLIを使う上で注意すべき点があります。

- **信頼設定の見落とし**: コマンド実行前の確認が重要（改善されたが、依然として注意が必要）
- **履歴機能の弱さ**: 重要な出力は別途保存する必要あり
- **学習曲線**: ターミナル初心者には敷居が高い

#### 著者の使い方

私の CLI の使い方は以下の通りです。

- **最近のアップデート（2025-12-10 v0.0.368）でプレミアムリクエスト表示が修正された**
- **レスポンスが短く簡潔**で心地よい
- **インターフェースとして最も軽量**
- **まだ探り探り**で、できないことが多い？
- **アクセス制限について考える必要がありそう**

## 118 リクエストの使い方を徹底分析 - 何に使った？何が無駄だった？

月間 118 リクエストの内訳を分析することで、自分の使い方のパターンが見えてきました。

### Web UI: 47 リクエスト（40%） - 調査とナレッジ構築

**主な用途**
- チャットでの技術調査とリポジトリ探索
- 無料モデル（GPT-4o mini）での調べ物
- Issue アサイン（Coding Agent）によるプレミアムリクエスト消費

**学び**
- Space でのナレッジベース化が非常に効果的
- Conversations として履歴が残るため、後から参照しやすい
- ただし、チャットログの検索機能が欲しい（タイトルが途中で切れる問題あり）

**改善点**
- Issue アサインの使い方をさらに洗練させる余地あり
- Space 内のナレッジを体系化する必要あり
- 無料モデルと有料モデルの使い分けをもっと意識する必要あり

### エディタ: 65 リクエスト（55%） - 実装の中心

**主な用途**
- Agent モードでのリファクタリングと新機能実装
- Edit モードでの細かな修正（ただし、結局 Agent を使うことが多い）
- 短文プロンプトによる高速イテレーション

**学び**
- **Agent モード中心**の使い方が定着
- 短文プロンプトで使い捨て感覚で依頼するのが効率的
- すぐできるタスクは Agent モードでそのまま実行
- 大きめのタスクは Plan モードで短文ラリー

**改善点**
- Plan モードをもっと活用できた可能性あり
- Ask モードは使わなくなったが、適切な用途があるかもしれない
- プレミアムリクエストの消費を意識しながら使う必要あり

### CLI: 6 リクエスト（5%） - まだ探索段階

**主な用途**
- スクリプト生成とコマンド説明
- 試験的な利用

**学び**
- レスポンスが短く簡潔で心地よい
- インターフェースとして最も軽量
- 最近のアップデート（2025-12-10 v0.0.368）でプレミアムリクエスト表示が修正された

**改善点**
- **今後の活用余地が非常に大きい**（目標: 15% に引き上げ）
- まだ探り探りで、できることとできないことの境界が見えていない
- アクセス制限や信頼設定について理解を深める必要あり

## プレミアムリクエストの基礎知識 - 賢く使うための前提

効率的に使うためには、プレミアムリクエストの仕組みを理解することが重要です。

### プレミアムリクエストとは

プレミアムリクエストは、高度な AI モデルを使用する際に消費される単位です。

- **月間 300 リクエスト** = 1 日平均 10 リクエスト（月額 $20）
- **リセットタイミング**: 毎月 1 日 UTC 00:00:00
- **対象プラン**: Copilot Pro および Business（Enterprise は 1,000 以上）

{{< linkcard "https://docs.github.com/en/billing/concepts/product-billing/github-copilot-premium-requests" >}}

#### モデル別マルチプライヤー

各モデルには異なる「マルチプライヤー」が設定されています。

- **GPT-4o、GPT-4.1**: 0×（プレミアム制限にカウントされない、実質無制限）
- **Gemini 2.0 Flash**: 0.25×（300 リクエスト枠で 1,200 回使える）
- **Claude 3.5 Sonnet**: 1×（300 回で上限）
- **Claude Opus 4**: 10×（30 回で上限）
- **GPT-4.5**: 最大 50×（わずか 6 回で上限）

つまり、**GPT-4o は無制限に使える**ため、基本的にはこれを使うのが賢明です。

### 実は「使い切らなくても良い」という視点

重要なのは「使用量」ではなく「成果」です。

- 118 リクエストで十分な価値を得られているか
- 無理に使い切ることが目的になっていないか
- ROI（投資対効果）を意識しているか

月初に「プレミアムリクエストを使い切る」という目標を立てましたが、本質的には**成果を最大化すること**が目的であるべきです。

### 使用状況のモニタリング習慣

定期的に使用状況を確認し、振り返ることが重要です。

#### 週 1 回: VS Code ステータスバーで確認

VS Code のステータスバーには、Copilot のアイコンがあり、そこから以下が確認できます。

- プレミアムリクエスト使用状況
- 月間制限までの進捗
- リセット日

#### 月 1 回: GitHub 課金ダッシュボードで振り返り

{{< linkcard "https://github.com/settings/billing" >}}

GitHub 課金ダッシュボードでは、以下が確認できます。

- 総使用量
- ユーザー/モデル/組織別のフィルタリング
- 含まれる/課金されるリクエストの内訳

#### 四半期: CSV レポートで傾向分析

CSV レポートをダウンロードして、以下を分析できます。

- タイムスタンプ別の使用傾向
- モデル別の消費パターン
- インタラクション別の分析

## シーン別インターフェース選択ガイド - 迷わず選ぶ決定木

どのインターフェースを使うべきか迷ったときの指針を示します。

### コードレビューとPR作業 → Web UI

**なぜ Web UI が最適か**
- リポジトリ全体のコンテキストが必要
- PR の差分を見ながらレビュー可能
- Space で過去のレビューを参照可能

**具体的な使い方**
1. PR 画面で Copilot Chat を開く
2. 「この PR の変更内容を要約して」と依頼
3. 「潜在的な問題点を指摘して」と依頼
4. レビューコメントを下書き

### 新機能の設計と実装 → エディタ（Agent モード）

**なぜエディタが最適か**
- 複数ファイルの変更が必要
- リアルタイムでコードを確認しながら進行可能
- インライン提案（プレミアムリクエスト0消費）も活用可能

**具体的な使い方**
1. Plan モードで設計を固める
   - 「〇〇機能を実装したい。どのような手順で進めるべきか？」
   - 提案された計画をレビュー
2. Agent モードで実装
   - 短文プロンプトで段階的に進める
   - 各ステップで動作確認
3. インライン提案で細部を調整

### バグ修正 → エディタ + Web UI の併用

**なぜ併用が最適か**
- エディタ: 原因特定とデバッグ
- Web UI: 関連 Issue や過去の修正履歴の調査

**具体的な使い方**
1. エディタでエラーログを分析
   - Copilot Chat で「このエラーの原因は？」
2. Web UI でリポジトリ全体を検索
   - 「過去に同様のエラーはあったか？」
   - 関連する Issue や PR を確認
3. エディタで修正を実装
4. Web UI でレビューとドキュメント更新

### ドキュメント作成 → Web UI

**なぜ Web UI が最適か**
- Space でドキュメントテンプレートを管理可能
- チームでの共有が容易
- マークダウンのプレビューが見やすい

**具体的な使い方**
1. Space に「ドキュメントテンプレート」を作成
2. 「〇〇についてのドキュメントを作成して」と依頼
3. 生成されたドキュメントをレビュー
4. リポジトリにコミット

### スクリプトと自動化 → CLI + エディタ

**なぜCLI + エディタが最適か**
- CLI: 基本構造を素早く生成
- エディタ: 詳細を実装し、テスト

**具体的な使い方**
1. CLI でスクリプトの骨格を生成
   ```bash
   gh copilot suggest "GitHub の Issue を一括クローズするスクリプト"
   ```
2. 生成されたコマンドをファイルに保存
3. エディタで詳細を実装
   - エラーハンドリング追加
   - ロギング追加
   - テスト追加

## 生産性を 2 倍にする 3 つの実践テクニック

118 リクエストの分析から見えてきた、効率的な使い方のテクニックを紹介します。

### テクニック 1: 「一発必中」プロンプトの作り方

曖昧な指示では、何度も往復することになり、プレミアムリクエストを無駄に消費します。

#### Before（悪い例）

```
このコードをリファクタリングして
```

**問題点**
- 何を改善したいのか不明確
- どのスタイルで書き直すのか分からない
- 何度も往復してしまう

#### After（良い例）

```
このコードを以下の方針でリファクタリングしてください：

1. 関数型プログラミングスタイルに変更
2. 副作用を除去し、純粋関数として実装
3. TypeScriptの型安全性を最大限活用
4. エラーハンドリングを追加（Result型を使用）
5. 各関数に簡潔なJSDocコメントを追加
```

**改善点**
- 具体的な要件が明確
- スタイルや方針が指定されている
- 一度で求める結果が得られる可能性が高い

#### .github/copilot-instructions.md の活用例

プロジェクト固有のコンテキストを `.github/copilot-instructions.md` に記載しておくことで、毎回説明する手間が省けます。

```markdown
# Copilot Instructions

## コーディング規約
- TypeScript を使用
- 関数型プログラミングスタイルを優先
- エラーハンドリングは Result 型を使用
- テストは Jest を使用

## アーキテクチャ
- クリーンアーキテクチャを採用
- ドメイン層、ユースケース層、インフラ層に分離
- DI コンテナは tsyringe を使用
```

### テクニック 2: Space を「第二の脳」にする

Space は単なるチャット履歴ではなく、**ナレッジベース**として活用できます。

#### 技術調査結果を Space に蓄積

- 新しい技術を学んだら、Space に要約を残す
- 公式ドキュメントの重要部分を抽出
- ベストプラクティスを記録

#### プロジェクトごとに Space を作成

- プロジェクト A 用の Space
- プロジェクト B 用の Space
- 学習用の Space

#### 過去の成功パターンを再利用

同じような質問を何度もしないように、Space に記録しておきます。

例：
- 「〇〇のエラーが出たときの対処法」
- 「△△を実装するときのベストプラクティス」
- 「□□のテストの書き方」

これにより、プレミアムリクエストを節約しつつ、効率的に開発できます。

### テクニック 3: インライン提案を最大活用（プレミアムリクエスト 0 消費）

エディタのインライン提案は、**プレミアムリクエストを消費しない**ため、積極的に活用すべきです。

#### インライン提案の特徴

- コーディング中にリアルタイムで提案
- タブキーで受け入れるだけ
- 関数全体や複数行のコードを提案可能
- **無制限に使用可能**

#### Agent モードに頼りすぎない

複雑なタスクは Agent モードが便利ですが、プレミアムリクエストを消費します。

- **簡単なタスク**: インライン提案で十分
- **中程度のタスク**: Agent モードで短文プロンプト
- **複雑なタスク**: Plan モードで計画を立ててから Agent モード

#### 具体的な活用シーン

```typescript
// 関数名を書くだけで、実装を提案してくれる
function calculateTotalPrice(

// ここでタブキーを押すと、以下のような提案が表示される
// items: Item[], taxRate: number): number {
//   const subtotal = items.reduce((sum, item) => sum + item.price, 0);
//   return subtotal * (1 + taxRate);
// }
```

このように、**Agent モードを使わずに**コードが書けるため、プレミアムリクエストを節約できます。

## まとめ - 次の 30 日で実践すること

118 リクエストの分析と、3 つのインターフェースの特性を理解したことで、今後の使い方が明確になりました。

### Week 1: 現在の使用状況をモニタリング

まずは自分の使い方を把握することから始めます。

- VS Code ステータスバーで毎日確認
- どのインターフェースを何に使っているか記録
- プレミアムリクエストの消費パターンを分析

### Week 2: 3 つのインターフェースを意識的に使い分ける実験

意識的に使い分けを試してみます。

- 調査は Web UI（Space に記録）
- 実装はエディタ（インライン提案を優先）
- スクリプト生成は CLI
- 各インターフェースの効果を記録

### Week 3: Space でナレッジベース構築を開始

Space を「第二の脳」として育てます。

- プロジェクトごとに Space を作成
- 技術調査結果を蓄積
- 過去の成功パターンをテンプレート化
- チーム内で共有

### Week 4: 振り返りと自分なりのパターン確立

1 ヶ月の実験を振り返り、最適化します。

- 使用状況を分析（CSV レポートダウンロード）
- 効果的だったパターンを文書化
- 改善点を洗い出す
- 次月の目標を設定

### 参考リンク

**公式ドキュメント**

{{< linkcard "https://docs.github.com/en/copilot/get-started/features" >}}

{{< linkcard "https://docs.github.com/en/billing/concepts/product-billing/github-copilot-premium-requests" >}}

{{< linkcard "https://docs.github.com/en/copilot/how-tos/use-copilot-agents/use-copilot-cli" >}}

{{< linkcard "https://docs.github.com/en/copilot/get-started/best-practices" >}}

**関連記事**

{{< linkcard "https://www.nqou.net/2025/11/29/094241/" >}}

{{< linkcard "https://www.nqou.net/2025/12/06/212332/" >}}

**GitHub公式ブログ**

{{< linkcard "https://github.blog/ai-and-ml/github-copilot/" >}}

---

GitHub Copilot の 3 つのインターフェースは、それぞれ異なる強みを持っています。**「選択」ではなく「組み合わせ」**が重要です。

プレミアムリクエストは「節約」ではなく「最適化」を意識し、次の 30 日で自分なりの使い分けパターンを見つけていきましょう。

最後まで読んでいただき、ありがとうございました。
