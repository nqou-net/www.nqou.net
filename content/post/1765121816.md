---
title: "MooによるTDD講座 #5 - テストカバレッジと実践テクニック"
draft: true
tags:
  - perl
  - test-driven-development
  - code-coverage
  - best-practices
  - testing
  - tutorial
description: "テストカバレッジ（網羅率）を計測し、テストの品質を可視化します。実践的なTDDのテクニックとアンチパターン、継続的な改善方法を学んでシリーズを完結します。"
---

## はじめに

いよいよ最終回です！これまでの4回で、TDDの基本から環境構築、メソッドのテスト、そしてCI環境まで構築してきました。

この最終回では、**テストの品質を測る指標**であるカバレッジと、**実践的なTDDテクニック**を学びます。また、よくある落とし穴（アンチパターン）を知り、継続的に改善していく方法を身につけましょう。

### これまでの旅路

簡単に振り返ってみます。

- **#1**：環境構築とTDDの基本サイクル（レッド→グリーン→リファクタリング）
- **#2**：メソッドのテストとTest2の便利な機能（例外テスト、サブテスト）
- **#3**：テストに守られながらリファクタリング（Mooのロール機能の活用）
- **#4**：GitHub ActionsでCI環境を構築

そして今回は、これらの知識を総動員して、**より良いテスト**を書くためのノウハウを学びます。

## テストカバレッジとは

テストカバレッジ（網羅率）とは、**テストによってどれだけのコードが実行されたか**を示す指標です。

### カバレッジの種類

主なカバレッジには以下の種類があります。

**1. 行カバレッジ（Line Coverage）**

コードの行が何%実行されたかを測定します。最も基本的な指標です。

```perl
sub calculate {
    my ($self, $x) = @_;
    
    if ($x > 0) {      # この行は実行された
        return $x * 2; # この行も実行された
    } else {
        return 0;      # この行は実行されなかった（カバレッジ不足）
    }
}
```

**2. 分岐カバレッジ（Branch Coverage）**

`if`文などの分岐において、すべての分岐パスが通ったかを測定します。

```perl
# 分岐カバレッジ50%の例（trueのパスしかテストしていない）
if ($condition) {
    # テスト済み
} else {
    # 未テスト
}
```

**3. 条件カバレッジ（Condition Coverage）**

論理演算子（`&&`, `||`）の各条件が真偽両方の値を取ったかを測定します。

```perl
if ($x > 0 && $y > 0) {
    # $x > 0 が true/false、$y > 0 が true/false のすべての組み合わせをテスト
}
```

### カバレッジ100%は目指すべきか

結論から言うと、**100%を盲目的に目指す必要はありません**。

カバレッジはあくまで**目安**です。重要なのは以下の点です。

- **意味のあるテストを書く**：カバレッジのためだけのテストは避ける
- **重要な部分を優先**：ビジネスロジックや複雑な処理を重点的にテストする
- **エッジケースを忘れない**：境界値や異常系のテストが大切

カバレッジ80〜90%を目安に、重要な部分がしっかりテストされていれば十分です。

### 意味のあるテストとは

良いテストの条件を整理しましょう。

```perl
# 悪い例：カバレッジのためだけのテスト
subtest 'getter exists' => sub {
    my $person = Person->new(name => 'Alice');
    ok($person->can('name'), 'name method exists');
};

# 良い例：振る舞いをテストする
subtest 'name getter returns correct value' => sub {
    my $person = Person->new(name => 'Alice');
    is($person->name, 'Alice', 'name returns the set value');
};
```

良いテストは、**コードの振る舞い**をテストします。メソッドが存在するかではなく、**期待通りに動作するか**を確認しましょう。

## Devel::Coverでカバレッジ計測

Perlには`Devel::Cover`という強力なカバレッジ計測ツールがあります。

### Devel::Coverのインストール

`cpanfile`に追加します。

```perl
# cpanfile
requires 'Moo', '2.005005';
requires 'Test2::V0', '0.000145';

# テスト・開発時のみ必要な依存関係
on 'test' => sub {
    requires 'Test2::Tools::Exception';
    requires 'Devel::Cover';
};
```

インストールを実行します。

```bash
docker-compose run --rm app cpanm --installdeps .
```

### カバレッジレポートの生成

カバレッジを計測しながらテストを実行します。

```bash
# カバレッジデータを収集しながらテストを実行
docker-compose run --rm app cover -test

# または、より詳細なオプション付きで
docker-compose run --rm app perl -MDevel::Cover=-db,cover_db,-coverage,all prove -lv t/
```

実行すると、`cover_db`ディレクトリにカバレッジデータが保存されます。

### HTMLレポートの生成

見やすいHTMLレポートを生成しましょう。

```bash
# HTMLレポートを生成
docker-compose run --rm app cover -report html_basic

# レポートを開く（ローカル環境の場合）
open cover_db/coverage.html
```

レポートには以下の情報が表示されます。

- **File**：ファイル名
- **stmt**：行カバレッジ
- **bran**：分岐カバレッジ
- **cond**：条件カバレッジ
- **sub**：サブルーチンカバレッジ
- **total**：総合カバレッジ

### HTMLレポートの読み方

レポートを開くと、各ファイルの行ごとにカバレッジが色分けされています。

- **緑色**：カバー済み（実行された）
- **赤色**：未カバー（実行されなかった）
- **黄色**：部分的にカバー（分岐の一部のみ実行）

未カバーの行を見つけて、必要なテストを追加していきます。

## カバレッジの改善

実際にカバレッジを改善してみましょう。

### 未カバー箇所の特定

たとえば、以下のような`BankAccount`クラスがあったとします。

```perl
package BankAccount;
use Moo;

has 'balance' => (is => 'rw', default => 0);

sub deposit {
    my ($self, $amount) = @_;
    
    if ($amount <= 0) {
        die "Amount must be positive";
    }
    
    $self->balance($self->balance + $amount);
    return $self->balance;
}

sub withdraw {
    my ($self, $amount) = @_;
    
    if ($amount <= 0) {
        die "Amount must be positive";
    }
    
    if ($amount > $self->balance) {
        die "Insufficient funds";
    }
    
    $self->balance($self->balance - $amount);
    return $self->balance;
}

1;
```

カバレッジレポートを見ると、`withdraw`の`"Insufficient funds"`のパスがカバーされていないことがわかったとします。

### エッジケースのテスト追加

未カバーの残高不足のケースをテストに追加します。

```perl
use strict;
use warnings;
use Test2::V0;
use Test2::Tools::Exception;

use BankAccount;

subtest 'withdraw with insufficient funds' => sub {
    my $account = BankAccount->new(balance => 100);
    
    like(
        dies { $account->withdraw(200) },
        qr/Insufficient funds/,
        'dies when withdrawing more than balance'
    );
    
    is($account->balance, 100, 'balance unchanged after failed withdrawal');
};

done_testing;
```

このテストを追加することで、分岐カバレッジが向上します。

### テストしにくいコードの改善

テストしにくいコードは、往々にして**設計上の問題**を抱えています。

```perl
# 悪い例：テストしにくい（現在時刻に依存）
sub is_business_hours {
    my $hour = (localtime)[2];
    return $hour >= 9 && $hour < 18;
}
```

このコードは、実行時刻によって結果が変わるため、テストが困難です。改善しましょう。

```perl
# 良い例：時刻を引数で受け取る
sub is_business_hours {
    my ($self, $hour) = @_;
    $hour //= (localtime)[2];  # デフォルトは現在時刻
    return $hour >= 9 && $hour < 18;
}

# テストが簡単になる
is($obj->is_business_hours(10), 1, '10時は営業時間内');
is($obj->is_business_hours(20), '', '20時は営業時間外');
```

**依存性の注入**によって、テスタビリティが向上しました。

## 実践的なTDDテクニック

経験から学んだ、実践で役立つテクニックを紹介します。

### テストの粒度の考え方

テストの粒度（どこまで細かくテストするか）は、バランスが重要です。

```perl
# 細かすぎる例（内部実装に依存しすぎ）
subtest 'increment counter internal' => sub {
    my $counter = Counter->new;
    is($counter->{_count}, 0, 'internal count is 0');  # 実装詳細に依存
    $counter->increment;
    is($counter->{_count}, 1, 'internal count is 1');
};

# 適切な粒度（公開インターフェースをテスト）
subtest 'increment counter' => sub {
    my $counter = Counter->new;
    is($counter->count, 0, 'initial count is 0');
    $counter->increment;
    is($counter->count, 1, 'count incremented to 1');
};
```

**公開インターフェース**をテストし、内部実装の詳細には立ち入らないようにしましょう。

### モック・スタブの使い方

外部依存をモックすることで、テストの独立性を保ちます。

```perl
use Test2::Mock;

subtest 'email notification with mock' => sub {
    my $mock = Test2::Mock->new(
        class => 'EmailService',
        override => [
            send => sub {
                my ($self, %args) = @_;
                return {
                    success => 1,
                    message_id => 'test-123'
                };
            }
        ]
    );
    
    my $notifier = Notifier->new(email_service => EmailService->new);
    my $result = $notifier->notify_user('user@example.com', 'Hello');
    
    ok($result->{success}, 'notification succeeded with mock');
};
```

モックを使うことで、実際にメールを送信せずにテストできます。

### テストダブルのパターン

テストダブルには複数のパターンがあります。

**スタブ（Stub）**：決まった値を返すだけのシンプルな代用品

```perl
my $stub_db = StubDatabase->new(
    find_user => sub { return { id => 1, name => 'Test User' } }
);
```

**モック（Mock）**：呼び出しを記録し、検証できる代用品

```perl
my $mock = Test2::Mock->new(class => 'Logger');
# ... テスト実行 ...
# 呼び出しが行われたかを検証
```

**フェイク（Fake）**：本物に近い動作をする簡易実装（例：インメモリDB）

```perl
my $fake_cache = FakeCache->new;  # 実際のRedisの代わりにハッシュを使用
```

使い分けのポイント：

- **スタブ**：単純な戻り値のテストに
- **モック**：呼び出しの検証が必要なときに
- **フェイク**：複雑な振る舞いが必要なときに

## TDDのアンチパターン

陥りがちな失敗例を知って、避けましょう。

### テストのためのコード（避けるべき）

本番コードに「テストのため"だけ"のコード」を入れるのは避けるべきです。

```perl
# アンチパターン：テストのためのフラグ
package UserService;

has 'test_mode' => (is => 'rw', default => 0);  # 避けるべき

sub send_email {
    my ($self, $email) = @_;
    return if $self->test_mode;  # テストモードでは送信しない
    # 実際のメール送信処理
}
```

代わりに、**依存性の注入**を使いましょう。

```perl
# 良い例：依存性の注入
package UserService;

has 'email_sender' => (is => 'ro', required => 1);

sub send_email {
    my ($self, $email) = @_;
    $self->email_sender->send($email);
}

# テストではモックを注入
my $service = UserService->new(email_sender => $mock_sender);
```

### テストの重複

同じことを何度もテストするのは、メンテナンスコストを増やすだけです。

```perl
# 重複したテスト（避けるべき）
subtest 'name validation test 1' => sub {
    my $person = Person->new(name => 'Alice');
    is($person->name, 'Alice', 'name is Alice');
};

subtest 'name validation test 2' => sub {
    my $person = Person->new(name => 'Alice');
    is($person->name, 'Alice', 'name is Alice again');  # 重複
};
```

テストは**異なるケース**をカバーするようにしましょう。

### 壊れやすいテスト

実装の些細な変更でテストが壊れるのは、テストが実装に密結合しているサインです。

```perl
# 壊れやすいテスト
subtest 'internal implementation' => sub {
    my $obj = MyClass->new;
    is(ref($obj->{_internal_cache}), 'HASH', 'uses hash for cache');  # 実装詳細
};

# 堅牢なテスト（振る舞いに着目）
subtest 'caching behavior' => sub {
    my $obj = MyClass->new;
    my $result1 = $obj->expensive_operation;
    my $result2 = $obj->expensive_operation;
    is($result1, $result2, 'results are consistent (cached)');
};
```

**what（何をするか）** をテストし、**how（どうやるか）** には立ち入らないのがコツです。

## 継続的な改善

TDDは一度やって終わりではなく、継続的に改善していくものです。

### リファクタリングのタイミング

「いつリファクタリングするか？」の答えは、**テストが通っているとき**です。

TDDのサイクルを思い出してください。

1. **レッド**：失敗するテストを書く
2. **グリーン**：テストを通す（最小実装でOK）
3. **リファクタリング**：テストが通った状態でコードを改善 ← ここ！

テストがあるからこそ、安心してリファクタリングできるのです。

```bash
# リファクタリングの流れ
$ prove -lv t/              # グリーン確認
$ # コードを改善する
$ prove -lv t/              # まだグリーン？
$ git commit -m "refactor: improve readability"
```

### テストコードもリファクタリング対象

テストコード自体も、読みやすく保守しやすくする必要があります。

**共通処理をヘルパーメソッドに**

```perl
# Before：重複が多い
subtest 'test 1' => sub {
    my $db = TestDB->new;
    $db->setup_schema;
    $db->insert_test_data;
    # テスト本体
};

subtest 'test 2' => sub {
    my $db = TestDB->new;
    $db->setup_schema;
    $db->insert_test_data;
    # テスト本体
};

# After：ヘルパーを使う
sub create_test_db {
    my $db = TestDB->new;
    $db->setup_schema;
    $db->insert_test_data;
    return $db;
}

subtest 'test 1' => sub {
    my $db = create_test_db();
    # テスト本体
};
```

### チームでのTDD文化の育て方

TDDを個人だけでなく、チーム全体に広げるためのヒントです。

**1. 小さく始める**

いきなり全てをTDDで書く必要はありません。

- まずは新機能だけTDDで書いてみる
- バグ修正時に、再現テストを先に書く習慣をつける
- レビュー時にテストの質を確認し合う

**2. ペアプログラミング・モブプログラミング**

一人で悩むより、チームで一緒にTDDを実践すると学びが深まります。

```bash
# ペアでTDD：役割を交代しながら
Alice: テストを書く（レッド）
Bob: 実装を書く（グリーン）
Alice: リファクタリング
# 役割交代して次のテストへ
```

**3. 成功体験を共有する**

- テストのおかげで救われたバグの話
- リファクタリングが安全にできた話
- カバレッジが上がったことでの安心感

こうした体験をチームで共有すると、TDDの価値が伝わります。

**4. CI/CDと組み合わせる**

前回（#4）で構築したCIがあれば、テストが自動で走ります。これが「テストを書かないと気持ち悪い」文化を作ります。

```yaml
# .github/workflows/test.yml
name: Test
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Run tests with coverage
        run: |
          docker-compose run --rm app cover -test
      - name: Upload coverage
        uses: codecov/codecov-action@v3  # カバレッジを可視化
```

カバレッジレポートをCIに統合すれば、コードレビュー時にカバレッジの変化を確認できます。

## まとめ：TDDの旅を振り返る

全5回の連載、お疲れさまでした！一緒にたくさんのことを学んできましたね。

### 5回で学んだこと

**#1 環境構築とはじめてのテスト駆動開発**

- Dockerでの開発環境構築
- TDDの基本サイクル（レッド→グリーン→リファクタリング）
- Test2とMooの基礎

**#2 メソッドのテストとTest2の便利な機能**

- 戻り値のテスト、例外のテスト
- Test2の多彩なアサーション（`like`, `is_deeply`, `match`など）
- サブテストによる整理

**#3 依存関係のテストとモックの活用**

- 外部依存のモック化
- Test2::Mockの使い方
- テスト可能な設計（依存性の注入）

**#4 GitHub ActionsでCI環境を構築**

- CIの重要性と自動テストの価値
- GitHub Actionsの基本
- DockerとCIの統合

**#5 テストカバレッジと実践テクニック（今回）**

- カバレッジの計測と改善
- 実践的なTDDテクニック
- アンチパターンの回避
- 継続的な改善とチーム文化

### これからの学習リソース

TDDの旅は、ここで終わりではありません。さらに学びを深めるためのリソースを紹介します。

**書籍**

- 『テスト駆動開発』Kent Beck（オーム社）：TDDのバイブル的存在
- 『リファクタリング』Martin Fowler（オーム社）：テストとセットで学ぶべき必読書

**オンラインリソース**

- [Test2::Suite Documentation](https://metacpan.org/pod/Test2::Suite)：公式ドキュメント
- [Moo Documentation](https://metacpan.org/pod/Moo)：Mooの公式ドキュメント
- [Perl Testing: A Developer's Notebook](http://www.modernperlbooks.com/)：実践的なPerlテスト技法

**コミュニティ**

- CPAN Testersの活動を見る：オープンソースのテスト文化を学べます
- 社内勉強会でTDDを実践してみる：仲間と一緒に学ぶのが一番です

### おわりに

TDDは、最初は「面倒だな」と感じるかもしれません。テストを先に書くのは、慣れないうちは不自然に思えるでしょう。

でも、続けていくうちに、こう感じる瞬間が来ます。

- 「テストがあるから、安心してリファクタリングできる」
- 「バグを見つけたとき、まずテストで再現できる」
- 「CIが通っているから、自信を持ってデプロイできる」

これがTDDの魅力です。

**最初から完璧を目指す必要はありません**。小さく始めて、少しずつ改善していきましょう。

テストを書く習慣を身につけ、それを楽しめるようになったとき、あなたのコーディングライフは大きく変わっているはずです。

最後まで読んでいただき、ありがとうございました。この連載が、あなたのTDDの第一歩になれば嬉しいです。

Happy Testing! 🎉

---

**連載リンク**

- [#1 環境構築とはじめてのテスト駆動開発](#)
- [#2 メソッドのテストとTest2の便利な機能](#)
- [#3 依存関係のテストとモックの活用](#)
- [#4 GitHub ActionsでCI環境を構築](#)
- **#5 テストカバレッジと実践テクニック（この記事）**
