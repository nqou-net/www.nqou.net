---
comments: true
date: 2025-12-18T12:00:00+09:00
description: エージェントに外部APIやサービスを統合し、Slack、GitHub、データベース、クラウドサービスとの連携で高度な自動化を実現する方法を学びます
draft: true
hidden: false
image: /favicon.png
iso8601: 2025-12-18T12:00:00+09:00
license: ~
math: ~
tags:
  - github
  - copilot
  - ai
  - agent
  - api-integration
  - automation
  - hands-on
series: "GitHub エージェントパネル実践ガイド"
title: 【第9回】カスタムツール統合 - 外部APIとの連携パターン

---

[@nqounet](https://x.com/nqounet)です。

GitHub エージェントパネル実践ガイド第9回です。今回は、エージェントに外部APIやサービスを統合し、より高度な自動化を実現する方法を学びます。

## この記事で学べること

- カスタムツールの統合方法
- 外部API連携のパターン
- Slack、GitHub API の活用
- データベースとの連携
- クラウドサービス統合

## カスタムツール統合の基本

### ツール統合の3つのレベル

**レベル1: 読み取り専用**
```
エージェント → 外部API → データ取得
例: GitHub Issues 一覧取得
```

**レベル2: 読み書き**
```
エージェント ⇄ 外部API
例: Slack メッセージ送信、応答受信
```

**レベル3: ワークフロー統合**
```
エージェント → API1 → API2 → API3 → 統合結果
例: GitHub Issue作成 → Jira同期 → Slack通知
```

## 実践例1: Slack 統合

### ユースケース

```
コードレビュー完了時に Slack に通知
↓
1. code-reviewer がレビュー完了
2. レビュー結果を整形
3. Slack に投稿
```

### AGENTS.md の設定

```markdown
## slack-notifier エージェント

### 役割
Slack への通知送信

### 設定

```yaml
slack:
  webhook_url: ${SLACK_WEBHOOK_URL}  # 環境変数から取得
  default_channel: #dev-notifications
  mention_users:
    critical: @channel
    high: @tech-lead
    normal: null
```

### 通知テンプレート

#### コードレビュー完了
```json
{
  "channel": "#dev-notifications",
  "username": "Code Review Bot",
  "icon_emoji": ":mag:",
  "blocks": [
    {
      "type": "header",
      "text": {
        "type": "plain_text",
        "text": "コードレビュー完了"
      }
    },
    {
      "type": "section",
      "fields": [
        {
          "type": "mrkdwn",
          "text": "*PR:* <{{pr_url}}|#{{pr_number}}>"
        },
        {
          "type": "mrkdwn",
          "text": "*Status:* {{status}}"
        }
      ]
    },
    {
      "type": "section",
      "text": {
        "type": "mrkdwn",
        "text": "*指摘事項:*\n{{issues}}"
      }
    }
  ]
}
```
```

### 実装例

**カスタムツール定義**:
```javascript
// tools/slack-notifier.js
const axios = require('axios');

class SlackNotifier {
  constructor(webhookUrl) {
    this.webhookUrl = webhookUrl;
  }

  /**
   * コードレビュー結果を Slack に投稿
   */
  async notifyCodeReview(reviewResult) {
    const message = this.formatReviewResult(reviewResult);
    
    try {
      await axios.post(this.webhookUrl, message);
      console.log('Slack notification sent successfully');
      return { success: true };
    } catch (error) {
      console.error('Failed to send Slack notification:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * レビュー結果をSlackメッセージに整形
   */
  formatReviewResult(result) {
    const { prNumber, prUrl, status, issues = [] } = result;
    
    const statusEmoji = {
      approved: ':white_check_mark:',
      changes_requested: ':warning:',
      commented: ':speech_balloon:'
    };

    const issueText = issues.length > 0
      ? issues.map((issue, i) => `${i + 1}. ${issue.message}`).join('\n')
      : 'なし';

    return {
      channel: '#dev-notifications',
      username: 'Code Review Bot',
      icon_emoji: ':mag:',
      blocks: [
        {
          type: 'header',
          text: {
            type: 'plain_text',
            text: `${statusEmoji[status]} コードレビュー完了`
          }
        },
        {
          type: 'section',
          fields: [
            {
              type: 'mrkdwn',
              text: `*PR:* <${prUrl}|#${prNumber}>`
            },
            {
              type: 'mrkdwn',
              text: `*Status:* ${status}`
            },
            {
              type: 'mrkdwn',
              text: `*Issues:* ${issues.length}件`
            }
          ]
        },
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: `*指摘事項:*\n${issueText}`
          }
        },
        {
          type: 'actions',
          elements: [
            {
              type: 'button',
              text: {
                type: 'plain_text',
                text: 'PRを確認'
              },
              url: prUrl,
              style: 'primary'
            }
          ]
        }
      ]
    };
  }

  /**
   * デプロイ通知
   */
  async notifyDeployment(deployInfo) {
    const { environment, version, status, deployer } = deployInfo;
    
    const message = {
      channel: '#deployments',
      username: 'Deploy Bot',
      icon_emoji: ':rocket:',
      text: `${environment} へのデプロイが${status === 'success' ? '成功' : '失敗'}しました`,
      blocks: [
        {
          type: 'section',
          fields: [
            { type: 'mrkdwn', text: `*環境:* ${environment}` },
            { type: 'mrkdwn', text: `*バージョン:* ${version}` },
            { type: 'mrkdwn', text: `*ステータス:* ${status}` },
            { type: 'mrkdwn', text: `*実行者:* ${deployer}` }
          ]
        }
      ]
    };

    await axios.post(this.webhookUrl, message);
  }
}

module.exports = SlackNotifier;
```

### エージェントパネルでの使用

```
タスク: PR #123 のコードレビューを実行し、結果を Slack に通知

ワークフロー:
1. code-reviewer で PR をレビュー
2. slack-notifier で結果を通知

通知先: #dev-notifications
```

## 実践例2: GitHub API 統合

### ユースケース: Issue自動作成

```
コードレビューで Critical な問題が見つかった場合、
自動的に GitHub Issue を作成
```

### 実装

```javascript
// tools/github-issue-creator.js
const { Octokit } = require('@octokit/rest');

class GitHubIssueCreator {
  constructor(token) {
    this.octokit = new Octokit({ auth: token });
  }

  /**
   * レビュー結果から Issue を作成
   */
  async createIssuesFromReview(owner, repo, reviewResult) {
    const criticalIssues = reviewResult.issues.filter(
      issue => issue.severity === 'critical'
    );

    const createdIssues = [];

    for (const issue of criticalIssues) {
      const githubIssue = await this.createIssue(owner, repo, {
        title: `[Critical] ${issue.title}`,
        body: this.formatIssueBody(issue, reviewResult),
        labels: ['bug', 'critical', 'code-review'],
        assignees: [reviewResult.author]
      });

      createdIssues.push(githubIssue);
    }

    return createdIssues;
  }

  /**
   * Issue を作成
   */
  async createIssue(owner, repo, issueData) {
    try {
      const response = await this.octokit.issues.create({
        owner,
        repo,
        ...issueData
      });

      console.log(`Issue created: #${response.data.number}`);
      return response.data;
    } catch (error) {
      console.error('Failed to create issue:', error);
      throw error;
    }
  }

  /**
   * Issue 本文をフォーマット
   */
  formatIssueBody(issue, reviewContext) {
    return `
## 問題の説明

${issue.message}

## 発生箇所

- **ファイル:** ${issue.file}
- **行:** ${issue.line}
- **PR:** #${reviewContext.prNumber}

## コードスニペット

\`\`\`${issue.language}
${issue.code}
\`\`\`

## 推奨される修正方法

${issue.suggestion || '要検討'}

## 優先度

**Critical** - 即座に対応が必要

---

_このIssueはコードレビューエージェントにより自動生成されました_
`;
  }

  /**
   * PR にコメントを追加
   */
  async addPRComment(owner, repo, prNumber, comment) {
    await this.octokit.issues.createComment({
      owner,
      repo,
      issue_number: prNumber,
      body: comment
    });
  }

  /**
   * PR のラベルを更新
   */
  async updatePRLabels(owner, repo, prNumber, labels) {
    await this.octokit.issues.addLabels({
      owner,
      repo,
      issue_number: prNumber,
      labels
    });
  }
}

module.exports = GitHubIssueCreator;
```

## 実践例3: データベース統合

### ユースケース: レビュー統計の記録

```
コードレビューの統計情報をデータベースに記録し、
チームのパフォーマンスを分析
```

### スキーマ設計

```sql
-- レビュー統計テーブル
CREATE TABLE code_review_stats (
  id SERIAL PRIMARY KEY,
  pr_number INTEGER NOT NULL,
  repository VARCHAR(255) NOT NULL,
  reviewer VARCHAR(100) NOT NULL,
  review_date TIMESTAMP NOT NULL,
  issues_found INTEGER DEFAULT 0,
  critical_issues INTEGER DEFAULT 0,
  high_issues INTEGER DEFAULT 0,
  medium_issues INTEGER DEFAULT 0,
  low_issues INTEGER DEFAULT 0,
  review_duration_minutes INTEGER,
  status VARCHAR(50) NOT NULL,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_review_stats_repo ON code_review_stats(repository);
CREATE INDEX idx_review_stats_date ON code_review_stats(review_date);
```

### 実装

```javascript
// tools/review-stats-recorder.js
const { Pool } = require('pg');

class ReviewStatsRecorder {
  constructor(dbConfig) {
    this.pool = new Pool(dbConfig);
  }

  /**
   * レビュー統計を記録
   */
  async recordReviewStats(reviewData) {
    const {
      prNumber,
      repository,
      reviewer,
      issues,
      startTime,
      endTime,
      status
    } = reviewData;

    const issueCounts = this.categorizeIssues(issues);
    const durationMinutes = Math.round((endTime - startTime) / 60000);

    const query = `
      INSERT INTO code_review_stats (
        pr_number,
        repository,
        reviewer,
        review_date,
        issues_found,
        critical_issues,
        high_issues,
        medium_issues,
        low_issues,
        review_duration_minutes,
        status
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
      RETURNING id
    `;

    const values = [
      prNumber,
      repository,
      reviewer,
      new Date(),
      issues.length,
      issueCounts.critical,
      issueCounts.high,
      issueCounts.medium,
      issueCounts.low,
      durationMinutes,
      status
    ];

    try {
      const result = await this.pool.query(query, values);
      console.log(`Review stats recorded: ID ${result.rows[0].id}`);
      return result.rows[0];
    } catch (error) {
      console.error('Failed to record review stats:', error);
      throw error;
    }
  }

  /**
   * Issue を重要度別に分類
   */
  categorizeIssues(issues) {
    return {
      critical: issues.filter(i => i.severity === 'critical').length,
      high: issues.filter(i => i.severity === 'high').length,
      medium: issues.filter(i => i.severity === 'medium').length,
      low: issues.filter(i => i.severity === 'low').length
    };
  }

  /**
   * レビュー統計を取得
   */
  async getReviewStats(repository, startDate, endDate) {
    const query = `
      SELECT 
        COUNT(*) as total_reviews,
        AVG(issues_found) as avg_issues,
        AVG(review_duration_minutes) as avg_duration,
        SUM(critical_issues) as total_critical,
        SUM(high_issues) as total_high
      FROM code_review_stats
      WHERE repository = $1
        AND review_date BETWEEN $2 AND $3
    `;

    const result = await this.pool.query(query, [repository, startDate, endDate]);
    return result.rows[0];
  }

  /**
   * レビュアー別統計
   */
  async getReviewerStats(repository, reviewer, period = '30 days') {
    const query = `
      SELECT 
        COUNT(*) as reviews_count,
        AVG(issues_found) as avg_issues_found,
        AVG(review_duration_minutes) as avg_review_time,
        SUM(CASE WHEN status = 'approved' THEN 1 ELSE 0 END) as approved_count
      FROM code_review_stats
      WHERE repository = $1
        AND reviewer = $2
        AND review_date > NOW() - INTERVAL '${period}'
    `;

    const result = await this.pool.query(query, [repository, reviewer]);
    return result.rows[0];
  }
}

module.exports = ReviewStatsRecorder;
```

## 実践例4: AWS S3 統合

### ユースケース: ドキュメントの自動アップロード

```
生成されたドキュメントを S3 にアップロードして
静的ウェブサイトとして公開
```

### 実装

```javascript
// tools/s3-uploader.js
const AWS = require('aws-sdk');
const fs = require('fs').promises;
const path = require('path');
const mime = require('mime-types');

class S3Uploader {
  constructor(config) {
    this.s3 = new AWS.S3({
      accessKeyId: config.accessKeyId,
      secretAccessKey: config.secretAccessKey,
      region: config.region
    });
    this.bucket = config.bucket;
  }

  /**
   * ドキュメントディレクトリをS3にアップロード
   */
  async uploadDocumentation(localDir, s3Prefix = 'docs/') {
    const files = await this.getFilesRecursively(localDir);
    const uploadResults = [];

    for (const file of files) {
      const relativePath = path.relative(localDir, file);
      const s3Key = path.join(s3Prefix, relativePath);
      
      const result = await this.uploadFile(file, s3Key);
      uploadResults.push(result);
    }

    return uploadResults;
  }

  /**
   * 単一ファイルをS3にアップロード
   */
  async uploadFile(filePath, s3Key) {
    const fileContent = await fs.readFile(filePath);
    const contentType = mime.lookup(filePath) || 'application/octet-stream';

    const params = {
      Bucket: this.bucket,
      Key: s3Key,
      Body: fileContent,
      ContentType: contentType,
      ACL: 'public-read'  // 公開アクセス
    };

    try {
      const result = await this.s3.upload(params).promise();
      console.log(`Uploaded: ${s3Key} → ${result.Location}`);
      return {
        success: true,
        key: s3Key,
        url: result.Location
      };
    } catch (error) {
      console.error(`Failed to upload ${s3Key}:`, error);
      return {
        success: false,
        key: s3Key,
        error: error.message
      };
    }
  }

  /**
   * ディレクトリ内のすべてのファイルを再帰的に取得
   */
  async getFilesRecursively(dir) {
    const entries = await fs.readdir(dir, { withFileTypes: true });
    const files = await Promise.all(
      entries.map(entry => {
        const fullPath = path.join(dir, entry.name);
        return entry.isDirectory() 
          ? this.getFilesRecursively(fullPath)
          : fullPath;
      })
    );
    return files.flat();
  }

  /**
   * CloudFront キャッシュを無効化
   */
  async invalidateCache(distributionId, paths) {
    const cloudfront = new AWS.CloudFront();
    
    const params = {
      DistributionId: distributionId,
      InvalidationBatch: {
        CallerReference: Date.now().toString(),
        Paths: {
          Quantity: paths.length,
          Items: paths
        }
      }
    };

    await cloudfront.createInvalidation(params).promise();
    console.log('CloudFront cache invalidated');
  }
}

module.exports = S3Uploader;
```

## 統合ワークフローの例

### 完全自動化: PR作成からデプロイまで

```markdown
## 自動化ワークフロー

### トリガー: PR作成

### ステップ1: コードレビュー
エージェント: code-reviewer
  ↓
Issue検出: 3件（Critical: 1, High: 2）

### ステップ2: GitHub Issue 作成
ツール: github-issue-creator
  ↓
Critical Issue #456 作成

### ステップ3: Slack 通知
ツール: slack-notifier
  ↓
#dev-notifications に投稿
メンション: @tech-lead

### ステップ4: 統計記録
ツール: review-stats-recorder
  ↓
DB に記録

### ステップ5: 修正後の再レビュー
（Issue が解決されたら自動実行）

### ステップ6: ドキュメント生成
エージェント: documentation-agent
  ↓
API ドキュメント更新

### ステップ7: S3 アップロード
ツール: s3-uploader
  ↓
https://docs.example.com/ に公開

### ステップ8: 最終通知
ツール: slack-notifier
  ↓
デプロイ完了を通知
```

## セキュリティの考慮事項

### API キーの管理

```markdown
## 推奨される管理方法

### 1. 環境変数を使用
```bash
export SLACK_WEBHOOK_URL="https://hooks.slack.com/..."
export GITHUB_TOKEN="ghp_..."
export AWS_ACCESS_KEY_ID="AKIA..."
```

### 2. GitHub Secrets に保存
リポジトリ設定 → Secrets → Actions

### 3. .env ファイル（ローカル開発のみ）
```env
SLACK_WEBHOOK_URL=https://hooks.slack.com/...
GITHUB_TOKEN=ghp_...
```

**.gitignore に追加:**
```
.env
*.key
*.pem
```

### 4. AWS Secrets Manager（本番環境）
```javascript
const AWS = require('aws-sdk');
const secretsManager = new AWS.SecretsManager();

async function getSecret(secretName) {
  const data = await secretsManager
    .getSecretValue({ SecretId: secretName })
    .promise();
  return JSON.parse(data.SecretString);
}
```
```

## 次回予告

第10回「セキュリティとベストプラクティス」では、エージェント運用における セキュリティ対策と、本番環境での安全な運用方法を学びます。

## チェックリスト

- [ ] Slack 統合を実装できた
- [ ] GitHub API を活用できるようになった
- [ ] データベース連携を実装できた
- [ ] クラウドサービス統合を理解した
- [ ] API キーを安全に管理できるようになった

---

**シリーズ目次**
1. [エージェントパネル入門](../1764676800/)
2. [エージェントパネルの基本操作](../1764849600/)
3. [最初のエージェント設定](../1765022400/)
4. [タスクプランニングエージェントの活用](../1765195200/)
5. [コード生成エージェントの実践](../1765368000/)
6. [レビューエージェントの構築](../1765540800/)
7. [ドキュメント生成エージェントの設定](../1765713600/)
8. [マルチエージェント連携](../1765886400/)
9. **カスタムツール統合**（本記事）
10. セキュリティとベストプラクティス
11. トラブルシューティング
12. 実践プロジェクト

質問や感想は [@nqounet](https://x.com/nqounet) までお気軽にどうぞ！
