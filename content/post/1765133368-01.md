---
title: "間違えてコミットした！git reset と git revert の使い分け完全ガイド"
draft: true
tags:
- "git"
- "version-control"
- "git-reset"
- "git-revert"
- "troubleshooting"
description: "コミットを取り消したいとき、resetとrevertのどちらを使うべきか迷う場面を解決。共有済みブランチでの安全な取り消し方法から、ローカルでの柔軟な履歴修正まで、状況に応じた最適な選択肢を実例とともに解説します。"
---

## コミット取り消しの基本戦略

Gitを使っていると誰もが一度は経験する「あ、間違えてコミットしちゃった！」という瞬間。このとき選択肢として浮かぶのが `git reset` と `git revert` です。この2つ、似ているようで全く異なるアプローチでコミットを取り消します。

最も重要な判断基準は**コミットが既にリモートにpushされているかどうか**です。この一点で戦略が大きく変わります。

## git reset の3つのモードと使い分け

`git reset` はコミット履歴そのものを巻き戻すコマンドです。HEADを指定したコミットに移動させ、それ以降のコミットを「なかったこと」にします。

### --soft: コミットだけを取り消す

```bash
git reset --soft HEAD~1
```

コミットのみを取り消し、変更内容はステージング状態で保持されます。コミットメッセージを書き直したいときや、複数のコミットを1つにまとめたいときに便利です。

### --mixed: デフォルト動作

```bash
git reset HEAD~1
# または
git reset --mixed HEAD~1
```

コミットとステージングを取り消し、変更内容はワーキングツリーに残ります。ファイルの追加忘れがあったときなど、コミット内容を調整したい場合に最適です。

### --hard: 完全に削除

```bash
git reset --hard HEAD~1
```

コミット、ステージング、ワーキングツリーの変更すべてを削除します。**データが完全に失われる**ため、慎重に使用してください。誤って実行した場合は `git reflog` で復旧可能です。

## インデックスとワーキングツリーへの影響

それぞれのモードがどこまで影響するかを整理すると：

| モード | コミット履歴 | インデックス | ワーキングツリー |
|--------|------------|------------|----------------|
| --soft | 巻き戻す | 保持 | 保持 |
| --mixed | 巻き戻す | クリア | 保持 |
| --hard | 巻き戻す | クリア | クリア |

この違いを理解すると、状況に応じた適切なモードを選択できます。

## git revert で安全に履歴を残す

`git revert` は既存のコミットを打ち消す**新しいコミット**を作成します。履歴を書き換えないため、すでにpushしたコミットを安全に取り消せます。

```bash
# 直前のコミットを取り消す
git revert HEAD

# 特定のコミットを取り消す
git revert abc1234
```

revertを実行すると、取り消し内容を記録した新しいコミットが作成されます。これにより、「いつ、何を取り消したか」という情報が履歴に残ります。

## リモートにpush済みの場合の鉄則

**他の人と共有しているブランチでは絶対に `git reset` を使わないでください。**

リモートにpushした後は、以下のルールを守りましょう：

```bash
# ❌ 危険：共有ブランチでresetは厳禁
git reset --hard HEAD~1
git push -f origin main  # force pushは他の開発者の作業を破壊する

# ✅ 安全：revertで取り消しコミットを作成
git revert HEAD
git push origin main
```

ただし、個人のfeatureブランチで誰も使っていないことが確実なら、resetも選択肢になります。

## マージコミットのrevert

マージコミットを取り消す場合は、どちらの親を残すかを `-m` オプションで指定します。

```bash
# マージコミットの情報を確認
git show HEAD

# 1番目の親（通常はmainブランチ側）を残す
git revert -m 1 HEAD
```

マージコミットには複数の親があるため、明示的な指定が必要です。

## よくある失敗パターンと解決法

### 間違えたファイルを含めてコミットした

```bash
# 直前のコミットを取り消してファイルを調整
git reset --soft HEAD~1
git restore --staged wrong-file.txt
git commit -m "正しいファイルのみをコミット"
```

### 複数のコミットをまとめて取り消し

```bash
# 過去3つのコミットを取り消す
git revert HEAD~2..HEAD

# または範囲指定
git revert HEAD~2^..HEAD
```

連続した複数コミットの取り消しは、範囲指定で効率的に行えます。

## resetとrevertの判断フローチャート

1. **コミットはpush済み？**
   - YES → `git revert` を使用
   - NO → 次へ

2. **変更内容を完全に削除したい？**
   - YES → `git reset --hard`
   - NO → 次へ

3. **ファイルの変更は保持したい？**
   - ステージング状態で保持 → `git reset --soft`
   - ワーキングツリーに保持 → `git reset --mixed`

## git reflog を使った復旧方法

間違えて `git reset --hard` を実行してしまった場合でも、`git reflog` で復旧できます。

```bash
# HEADの移動履歴を確認
git reflog

# 出力例：
# abc1234 HEAD@{0}: reset: moving to HEAD~1
# def5678 HEAD@{1}: commit: 重要な変更

# 復旧したいコミットに戻る
git reset --hard HEAD@{1}
```

reflogはローカルリポジトリの操作履歴を記録しているため、ほとんどの「やらかし」から復旧できます。通常30日間保持されます。

## まとめ

コミットの取り消しは、状況に応じた適切なコマンド選択が重要です。**push済みなら revert、ローカルのみなら reset** という基本原則を押さえておけば、安全にGit操作を行えます。万が一のときは `git reflog` があなたを救ってくれるでしょう。
