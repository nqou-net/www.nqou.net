---
title: "GitHub Copilot エージェントパネル入門 - 第3回: プロンプトエンジニアリング基礎"
description: "効果的なエージェントプロンプトの書き方を徹底解説。Few-shot learning、Chain of Thought、出力制御のテクニックを実例とともに学ぶ"
date: 2025-12-04T15:00:00+09:00
draft: true
tags:
  - GitHub
  - Copilot
  - Agent Panel
  - プロンプトエンジニアリング
  - AI
image: /favicon.png
---

## はじめに

[@nqounet](https://x.com/nqounet)です。

第3回では、エージェントの性能を左右する「プロンプトエンジニアリング」について深掘りします。良いプロンプトを書くことで、エージェントの精度と有用性が劇的に向上します。

前回のおさらい：カスタムエージェントの作成方法と、基本的なエージェント定義ファイルの書き方を学びました。

## プロンプトエンジニアリングとは

プロンプトエンジニアリングは、AIモデルから望ましい出力を得るために、入力（プロンプト）を最適化する技術です。

### なぜ重要なのか

同じタスクでも、プロンプトの書き方で結果が大きく変わります：

```markdown
❌ 曖昧なプロンプト:
コードをチェックしてください

✅ 具体的なプロンプト:
以下のJavaScriptコードについて、
1. ESLintのrecommendedルールに違反していないか
2. パフォーマンス上の問題がないか
3. セキュリティリスクがないか
を確認し、各問題について行番号と修正案を提示してください。
```

## プロンプトの基本構造

効果的なプロンプトは、以下の要素で構成されます：

```markdown
1. 【役割定義】エージェントの専門性を明確化
2. 【タスク説明】何をすべきか具体的に指示
3. 【制約条件】守るべきルールや制限
4. 【出力形式】結果の形式を明示
5. 【具体例】期待する出力のサンプル（オプション）
```

### 実例: コードレビューエージェント

```markdown
---
name: detailed-code-reviewer
description: 詳細なコードレビューを実施
version: 1.0.0
---

# 【1. 役割定義】
あなたは10年以上の経験を持つシニアソフトウェアエンジニアです。
コードレビューのベストプラクティスを熟知しており、建設的で
具体的なフィードバックを提供することが得意です。

# 【2. タスク説明】
与えられたコードを以下の観点でレビューしてください：

## レビュー観点
1. **コードの正確性**: ロジックエラー、バグの可能性
2. **保守性**: 可読性、命名規則、コメント
3. **パフォーマンス**: 非効率なアルゴリズム、不要な処理
4. **セキュリティ**: 脆弱性のリスク
5. **ベストプラクティス**: 言語/フレームワーク固有の推奨事項

# 【3. 制約条件】
- 批判的ではなく、建設的なトーンを保つ
- 各指摘には必ず具体的な改善案を含める
- 重要度を3段階（Critical/Warning/Info）で分類
- 良い点も必ず指摘する

# 【4. 出力形式】
以下のMarkdown形式で出力してください：

## コードレビュー結果

### 🔴 Critical Issues (修正必須)
- **[行番号]**: 問題の説明
  - 影響: どんな問題が起きるか
  - 修正案: 具体的なコード例

### 🟡 Warnings (推奨改善)
- **[行番号]**: 問題の説明
  - 理由: なぜ改善すべきか
  - 修正案: 具体的なコード例

### 💡 Suggestions (参考情報)
- 改善のヒント

### ✅ Good Practices
- 良い点のリスト

### 総合評価
スコア: [0-100]/100
コメント: 総評

# 【5. 具体例】
（例は次のセクションで詳述）
```

## Few-Shot Learning: 例示による学習

Few-Shot Learningは、いくつかの例を示すことでエージェントの出力品質を向上させる手法です。

### Zero-Shot vs Few-Shot

```markdown
## Zero-Shot（例なし）
関数に適切な名前を付けてください。

## Few-Shot（例あり）
以下の例のように、関数に適切な名前を付けてください。

例1:
❌ Before: `function f(x) { return x * 2; }`
✅ After:  `function double(number) { return number * 2; }`

例2:
❌ Before: `function g(a, b) { return a + b; }`
✅ After:  `function calculateSum(firstNumber, secondNumber) { ... }`

例3:
❌ Before: `function h(arr) { return arr.filter(x => x > 0); }`
✅ After:  `function filterPositiveNumbers(numbers) { ... }`
```

### 実践例: TypeScript型推論エージェント

```markdown
---
name: typescript-type-inferer
description: TypeScriptの型を推論して追加
version: 1.0.0
---

# TypeScript型推論エージェント

## あなたの役割
TypeScriptのエキスパートとして、型アノテーションが欠落している
コードに適切な型を追加します。

## 型推論のルール
1. 可能な限り具体的な型を使用（`any`は避ける）
2. Union型やジェネリクスを適切に活用
3. 既存のインターフェースを尊重

## 出力例（Few-Shot Examples）

### 例1: 関数の引数と戻り値
\`\`\`typescript
// Before
function greet(name) {
  return `Hello, ${name}!`;
}

// After
function greet(name: string): string {
  return `Hello, ${name}!`;
}
\`\`\`

### 例2: 複雑なオブジェクト
\`\`\`typescript
// Before
function processUser(user) {
  return {
    id: user.id,
    fullName: `${user.firstName} ${user.lastName}`,
    age: user.age
  };
}

// After
interface User {
  id: number;
  firstName: string;
  lastName: string;
  age: number;
}

interface ProcessedUser {
  id: number;
  fullName: string;
  age: number;
}

function processUser(user: User): ProcessedUser {
  return {
    id: user.id,
    fullName: `${user.firstName} ${user.lastName}`,
    age: user.age
  };
}
\`\`\`

### 例3: 配列とジェネリクス
\`\`\`typescript
// Before
function findById(items, id) {
  return items.find(item => item.id === id);
}

// After
function findById<T extends { id: number }>(
  items: T[],
  id: number
): T | undefined {
  return items.find(item => item.id === id);
}
\`\`\`

## 実行時の指示
与えられたコードに対して、上記の例と同様のスタイルで型を追加してください。
```

## Chain of Thought: 思考プロセスの明示

Chain of Thought（CoT）は、エージェントに段階的な思考プロセスを明示させる手法です。

### 基本的なCoTプロンプト

```markdown
## 分析プロセス

以下の手順で分析を進めてください：

### ステップ1: 全体像の把握
- コードの目的を特定
- 使用されている技術やパターンを識別

### ステップ2: 詳細な検証
- 各行を順番にチェック
- 潜在的な問題を洗い出し

### ステップ3: 優先順位付け
- 見つかった問題を重要度で分類
- 影響範囲を評価

### ステップ4: 改善案の作成
- 各問題に対する具体的な修正案を作成
- 代替案がある場合は複数提示

### ステップ5: 最終レポート
- 分析結果を構造化して出力
```

### 実践例: セキュリティ監査エージェント

```markdown
---
name: security-auditor-cot
description: Chain of Thoughtを使ったセキュリティ監査
version: 1.0.0
---

# セキュリティ監査エージェント

## 監査プロセス（Chain of Thought）

あなたの思考プロセスを以下のように明示してください：

### 🔍 Phase 1: コードの理解
\`\`\`
思考: このコードは何をしているのか？
- 入力: [入力データの種類]
- 処理: [主な処理内容]
- 出力: [出力データの種類]
\`\`\`

### 🎯 Phase 2: 脆弱性の特定
\`\`\`
思考: OWASP Top 10の観点でチェック

1. インジェクション攻撃のリスク
   - ユーザー入力の検証: [有/無]
   - サニタイゼーション: [有/無]
   - 判定: [安全/危険]

2. 認証・認可の問題
   - 認証メカニズム: [確認内容]
   - 判定: [安全/危険]

（以下同様）
\`\`\`

### ⚠️ Phase 3: リスク評価
\`\`\`
思考: 各脆弱性の影響度を評価

発見した脆弱性:
1. [脆弱性名]
   - 影響度: High/Medium/Low
   - 理由: [なぜその評価か]
   - 悪用シナリオ: [具体例]
\`\`\`

### 💡 Phase 4: 修正案の検討
\`\`\`
思考: どう修正すべきか

脆弱性1への対策:
- Option A: [修正案1]
  - メリット: [...]
  - デメリット: [...]
- Option B: [修正案2]
  - メリット: [...]
  - デメリット: [...]
- 推奨: [Option A/B] 理由: [...]
\`\`\`

### 📋 Phase 5: 最終レポート
（上記の思考プロセスを基に、構造化されたレポートを出力）
```

## 出力制御のテクニック

### 1. 構造化された出力を強制

```markdown
## 出力形式（厳守）

以下の JSON Schema に準拠した出力をしてください：

\`\`\`json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "required": ["fileName", "issues", "score"],
  "properties": {
    "fileName": {
      "type": "string",
      "description": "分析対象ファイル名"
    },
    "issues": {
      "type": "array",
      "items": {
        "type": "object",
        "required": ["severity", "line", "message"],
        "properties": {
          "severity": {
            "type": "string",
            "enum": ["critical", "warning", "info"]
          },
          "line": {
            "type": "integer",
            "minimum": 1
          },
          "message": {
            "type": "string"
          },
          "suggestion": {
            "type": "string"
          }
        }
      }
    },
    "score": {
      "type": "integer",
      "minimum": 0,
      "maximum": 100
    }
  }
}
\`\`\`

**重要**: 上記以外の形式での出力は受け付けられません。
```

### 2. テンプレートベースの出力

```markdown
## 出力テンプレート

以下のテンプレートを埋めてください。[...]の部分を置き換えます。

---
# Code Review: [ファイル名]

## Summary
- Total Issues: [数値]
- Critical: [数値]
- Warnings: [数値]
- Info: [数値]

## Critical Issues
[問題がない場合は「None」と記載]

1. **Line [行番号]**: [問題の説明]
   - **Impact**: [影響]
   - **Fix**: 
     \`\`\`[言語]
     [修正後のコード]
     \`\`\`

## Warnings
[同上]

## Recommendations
- [推奨事項1]
- [推奨事項2]

## Score: [0-100]/100

---
```

### 3. 長さと詳細度の制御

```markdown
## 出力の詳細度

### Mode: Concise（簡潔モード）
- 各問題を1行で要約
- 修正案は示さない
- 最大10個の問題まで報告

### Mode: Standard（標準モード）
- 各問題に説明と修正案を含める
- 最大20個の問題まで報告

### Mode: Detailed（詳細モード）
- すべての問題を報告
- 各問題に詳細な説明、影響、修正案、代替案を含める
- コード例を豊富に含める

**現在のモード**: Standard
```

## プロンプトの検証とデバッグ

### テストケースの作成

```markdown
## テストケース

このエージェントは以下のテストケースで検証されています：

### Test Case 1: 基本的なバグ検出
入力:
\`\`\`javascript
function divide(a, b) {
  return a / b;
}
\`\`\`

期待される出力:
- ゼロ除算チェックの欠落を指摘
- エラーハンドリングの追加を提案

### Test Case 2: セキュリティ問題
入力:
\`\`\`javascript
app.get('/user', (req, res) => {
  const userId = req.query.id;
  const query = `SELECT * FROM users WHERE id = ${userId}`;
  db.query(query, (err, results) => {
    res.json(results);
  });
});
\`\`\`

期待される出力:
- SQLインジェクションの脆弱性を指摘
- プリペアドステートメントの使用を提案

### Test Case 3: パフォーマンス問題
入力:
\`\`\`javascript
function findUser(users, targetId) {
  for (let i = 0; i < users.length; i++) {
    for (let j = 0; j < users.length; j++) {
      if (users[i].id === targetId) {
        return users[i];
      }
    }
  }
}
\`\`\`

期待される出力:
- 不要なネストループを指摘
- シンプルな実装を提案
```

### デバッグ用のバーボースモード

```markdown
## デバッグモード

`debug: true` が設定されている場合、以下の追加情報を出力してください：

### 処理ステップの記録
\`\`\`
[DEBUG] Step 1: コードの読み込み完了 (125 lines)
[DEBUG] Step 2: 字句解析開始
[DEBUG] Step 3: 構文解析完了 (15 functions detected)
[DEBUG] Step 4: 静的解析実行中...
[DEBUG] Step 5: 問題を12件検出
[DEBUG] Step 6: レポート生成中...
[DEBUG] 完了: 処理時間 1.2秒
\`\`\`

### 内部判断の記録
\`\`\`
[DEBUG] Line 42: `var` detected
  -> Severity判定: Warning (ES6環境のため)
  -> 修正案生成: const への置換を推奨

[DEBUG] Line 58: `eval()` detected
  -> Severity判定: Critical (セキュリティリスク)
  -> 代替案検索: JSON.parse, Function constructor
\`\`\`
```

## プロンプト改善のイテレーション

### ステップ1: 初期プロンプト

```markdown
コードをレビューして問題点を指摘してください。
```

### ステップ2: 具体化

```markdown
JavaScriptコードをレビューして、以下の問題を指摘してください：
- 構文エラー
- ベストプラクティス違反
- パフォーマンス問題
```

### ステップ3: 構造化

```markdown
JavaScriptコードをレビューして、問題を以下の形式で出力してください：

## 問題リスト
1. [行番号]: 問題の説明
   - 重要度: High/Medium/Low
   - 修正案: [具体的なコード]

## スコア
[0-100]/100
```

### ステップ4: 例示追加

```markdown
（ステップ3の内容 +）

## 出力例

### 例1
\`\`\`
## 問題リスト
1. Line 5: var の使用
   - 重要度: Medium
   - 修正案: const userName = 'John';

## スコア
75/100
\`\`\`
```

### ステップ5: 制約と役割の明確化

```markdown
（最終的なプロンプト - 前述の詳細なコードレビューエージェント参照）
```

## 動作確認チェックリスト

- [ ] Zero-Shotプロンプトと Few-Shotプロンプトの違いを理解した
- [ ] Chain of Thoughtプロンプトを実装した
- [ ] 構造化された出力制御を試した
- [ ] テストケースを作成した
- [ ] プロンプトのイテレーションを行った
- [ ] デバッグモードを実装した
- [ ] 実際のコードで精度が向上することを確認した

## 次回予告

第4回では、エージェント設定ファイルの詳細を掘り下げます：

- パラメータの高度な使い方
- 環境変数とシークレット管理
- 依存関係の定義
- エージェントのバージョニングと更新

## まとめ

この記事では、プロンプトエンジニアリングの核心を学びました：

1. **プロンプトの基本構造**
   - 役割定義、タスク説明、制約条件、出力形式、具体例

2. **Few-Shot Learning**
   - 具体例を示してエージェントの理解を助ける
   - Zero-Shotよりも精度が大幅に向上

3. **Chain of Thought**
   - 思考プロセスを段階的に明示
   - 複雑なタスクの精度向上

4. **出力制御**
   - 構造化された出力の強制
   - テンプレートベースの一貫性確保
   - 詳細度のコントロール

次回は、これらのテクニックを活かしながら、エージェント設定ファイルのさらに高度な機能を探求します！

## 参考リンク

- [OpenAI Prompt Engineering Guide](https://platform.openai.com/docs/guides/prompt-engineering)
- [Few-Shot Learning 論文](https://arxiv.org/abs/2005.14165)
- [Chain-of-Thought Prompting](https://arxiv.org/abs/2201.11903)
