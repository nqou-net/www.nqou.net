---
title: "過去の変更を探せ！git bisect で問題のコミットを特定する"
draft: true
tags:
- "git"
- "git-bisect"
- "debugging"
- "troubleshooting"
- "automation"
description: "バグがいつ混入したか分からない時の救世主、git bisectの使い方を実践的に解説。二分探索で効率的に問題コミットを見つける手法から、自動化スクリプトとの組み合わせまで、デバッグを加速する技術を紹介します。"
---

## git bisect とは：二分探索でバグを追跡

「昨日は動いていたのに、今日は動かない…」「どのコミットでバグが混入したんだろう？」こんな時、全コミットを1つずつチェックするのは非効率です。`git bisect`は二分探索アルゴリズムを使って、問題のコミットを効率的に特定します。

### 手動で探すより圧倒的に速い理由

1000コミットの中からバグ混入コミットを探す場合：

- **線形探索（1つずつ確認）**: 最悪1000回、平均500回のチェック
- **二分探索（bisect使用）**: 最大10回程度のチェック（log₂1000 ≈ 10）

この劇的な効率化が、bisectの最大の魅力です。

## 基本的な bisect の流れ

bisectは、「良い」と「悪い」の2つの状態を定義し、その境界を絞り込んでいきます。

### ステップ1: bisect開始

```bash
# bisectセッションを開始
git bisect start

# 現在（バグがある）のコミットを「悪い」とマーク
git bisect bad

# 正常に動作していたコミットを「良い」とマーク
git bisect good v1.2.0  # タグやハッシュを指定
```

### ステップ2: 中間点をテスト

Gitが自動的に中間地点のコミットにチェックアウトします。

```bash
# ここでテストを実行
npm test
# または
./run-test.sh

# 結果に応じてマーク
git bisect good  # テストが成功した場合
# または
git bisect bad   # テストが失敗した場合
```

### ステップ3: 繰り返し

good/badを繰り返すと、Gitが範囲を半分に絞り込みながら問題コミットを特定します。

```bash
# 出力例
Bisecting: 15 revisions left to test after this (roughly 4 steps)
[abc1234] feat: ユーザー認証を改善

# テスト → good/bad → 次の中間点へ
```

### ステップ4: 特定完了

```bash
# 最終的に問題のコミットが特定される
abc1234 is the first bad commit
commit abc1234
Author: Developer <dev@example.com>
Date: Mon Dec 4 10:30:00 2023

    feat: キャッシュ機能を追加

# bisectセッションを終了
git bisect reset
```

## ログから問題コミットを突き止める

実際の使用例を見てみましょう。

```bash
# bisect開始
git bisect start

# 現在のHEADを「悪い」とマーク
git bisect bad HEAD

# 1週間前のコミットを「良い」とマーク  
git bisect good HEAD~50

# 出力
Bisecting: 25 revisions left to test after this (roughly 5 steps)
[def5678] refactor: データベース接続処理を最適化

# ここでテスト
npm run test:integration
# → 失敗

git bisect bad

Bisecting: 12 revisions left to test after this (roughly 4 steps)
[ghi9012] fix: バリデーションエラーを修正

# テスト
npm run test:integration
# → 成功

git bisect good

# これを繰り返して特定
```

## 自動化で更に効率アップ

### git bisect run でテストスクリプトを実行

手動で繰り返すのが面倒な場合、テストスクリプトを自動実行できます。

```bash
# テストスクリプトを作成（test.sh）
#!/bin/bash
npm run build && npm test
exit $?

# スクリプトに実行権限を付与
chmod +x test.sh

# bisect runで自動実行
git bisect start
git bisect bad HEAD
git bisect good v1.0.0
git bisect run ./test.sh
```

### 終了コードの制御

スクリプトの終了コードで good/bad を判定します：

- **0**: good（テスト成功）
- **1-124, 126-127**: bad（テスト失敗）
- **125**: skip（このコミットはテスト不可）

```bash
#!/bin/bash
# test-bisect.sh

# ビルドできない場合はスキップ
npm run build || exit 125

# テスト実行
npm test
exit $?
```

## 実践例：パフォーマンス劣化の原因特定

アプリケーションの応答時間が遅くなった原因を探します。

```bash
# パフォーマンステストスクリプト
cat > perf-test.sh << 'SCRIPT'
#!/bin/bash

# APIエンドポイントのレスポンスタイムを計測
time=$(curl -o /dev/null -s -w '%{time_total}\n' http://localhost:3000/api/users)

# 0.5秒以上かかったらNG
if (( $(echo "$time > 0.5" | bc -l) )); then
    echo "Performance degraded: ${time}s"
    exit 1
else
    echo "Performance OK: ${time}s"
    exit 0
fi
SCRIPT

chmod +x perf-test.sh

# 自動bisect実行
git bisect start
git bisect bad HEAD
git bisect good v2.1.0
git bisect run ./perf-test.sh
```

## bisect 中のトラブル対処

### skipを使った対応不能コミットの扱い

ビルドエラーがあるコミットなど、テストできない場合は skip します。

```bash
# 手動でスキップ
git bisect skip

# 範囲指定でスキップ
git bisect skip abc1234..def5678
```

### bisectのリセットと再開

```bash
# 途中で中断したい場合
git bisect reset

# 途中経過を保存
git bisect log > bisect-log.txt

# 後で再開
git bisect replay bisect-log.txt
```

## visualize で探索状況を可視化

bisectの進行状況をビジュアルに確認できます。

```bash
# グラフィカルツールで表示
git bisect visualize

# またはテキストベースで表示
git bisect view
```

これにより、現在の探索範囲と残りのコミット数が視覚的に分かります。

## 実用的なビスケクトテンプレート

よく使うパターンをスクリプト化しておくと便利です。

```bash
#!/bin/bash
# quick-bisect.sh - 特定の機能が壊れた時点を探す

# 引数チェック
if [ $# -ne 2 ]; then
    echo "Usage: $0 <good-commit> <test-command>"
    exit 1
fi

GOOD_COMMIT=$1
TEST_CMD=$2

# bisect開始
git bisect start HEAD $GOOD_COMMIT

# 自動テスト実行
git bisect run bash -c "$TEST_CMD"

# 結果を表示
echo "問題のコミット:"
git bisect log | grep "first bad commit"

# クリーンアップ
git bisect reset
```

使用例：

```bash
./quick-bisect.sh v1.0.0 "npm test -- user.test.js"
```

## まとめ

`git bisect`は、バグ混入コミットを効率的に特定する強力なツールです。

- **基本操作**: start → bad → good → 繰り返し → reset
- **自動化**: `git bisect run`でテストスクリプトを実行
- **スキップ**: テスト不可能なコミットは`skip`
- **可視化**: `visualize`で進行状況を確認

数百、数千のコミットがある大規模プロジェクトでこそ、真価を発揮します。次にバグの原因が分からなくなったら、bisectを思い出してください。デバッグ時間が劇的に短縮されるはずです。
