---
date: 2026-01-04T21:04:47+09:00
description: URL短縮に必要なデータ構造を設計します。SQLのCREATE TABLEでテーブルを作成し、各カラムの意味と制約を理解しましょう。
draft: false
epoch: 1767528287
image: /public_images/2026/url-shortener-series-image.jpg
iso8601: 2026-01-04T21:04:47+09:00
tags:
  - perl
  - database-schema
  - sqlite
title: 第6回-データの住所を決めよう — URL短縮サポーターを作ってみよう
---

[@nqounet](https://x.com/nqounet)です。

連載「URL短縮サポーターを作ってみよう」の第6回です。

## 前回の振り返り

第5回では、DBIを使ってSQLiteデータベースに接続する方法を学びました。

{{< linkcard "/2026/01/04/210446/" >}}

前回学んだ内容を簡単に振り返ります。

- メモリ上のデータはサーバー再起動で消えるため、永続化が必要である
- `DBI->connect("dbi:SQLite:dbname=urls.db", "", "", { RaiseError => 1, AutoCommit => 1 })`でSQLiteに接続した
- `$dbh->disconnect`で接続を切断する

今回は、URLを保存するための「テーブル」を設計し、実際に作成します。

## 今回のゴール

第6回では、以下を達成することを目標とします。

- テーブルとカラムの役割を理解する
- URL短縮に必要なデータ構造を設計する
- CREATE TABLE文でテーブルを作成する

## どんな情報を保存する？

### タカシさんとの会話

前回、データベースへの接続が成功したタカシさん。次の疑問が湧いてきました。

「データベースには何を保存すればいいの？」

良い質問です。URL短縮サービスを動かすために、最低限必要な情報を考えてみましょう。

### 必要なデータを洗い出す

URL短縮サービスの基本的な動作を思い出してみます。

1. ユーザーが長いURLを入力する
2. 短縮コードを生成して保存する
3. 短縮コードにアクセスされたら元のURLへ転送する

この動作に必要な情報は以下のとおりです。

- 元のURL（どこに転送するか）
- 短縮コード（どのコードでアクセスするか）

さらに、データ管理のために以下も欲しいところです。

- 識別子（各レコードを一意に特定するため）
- 登録日時（いつ登録されたかを記録するため）

これらを整理すると、4つのカラム（列）が必要だとわかります。

## テーブルを設計する

### テーブルとカラム

データベースでは、情報を「テーブル」という表形式で管理します。Excelのシートをイメージすると分かりやすいでしょう。

- テーブル: 1つのデータの種類を管理する単位（例: urlsテーブル）
- カラム（列）: データの項目（例: id, original_url, short_code, created_at）
- レコード（行）: 1件分のデータ

今回作成するテーブルは以下のような構造になります。

| id | original_url | short_code | created_at |
|----|-------------|------------|------------|
| 1 | https://example.com/very-long-url | a1b2c3 | 2025-01-01 12:00:00 |
| 2 | https://another-site.com/page | d4e5f6 | 2025-01-01 12:05:00 |

### 各カラムの意味

4つのカラムの役割を詳しく見ていきましょう。

#### id

```
id INTEGER PRIMARY KEY
```

各レコードを一意に識別するための番号です。SQLiteでは`INTEGER PRIMARY KEY`を指定すると、レコード挿入時に自動的に連番が割り当てられます。

#### original_url

```
original_url TEXT NOT NULL
```

転送先となる元のURLを保存します。`TEXT`型は文字列を格納するデータ型です。`NOT NULL`は「空の値を許可しない」という制約で、必ず値が入っている必要があることを示します。

#### short_code

```
short_code TEXT UNIQUE NOT NULL
```

短縮コード（例: a1b2c3）を保存します。`UNIQUE`制約により、同じ短縮コードが重複して登録されることを防ぎます。これは重要な制約で、1つの短縮コードが複数のURLに対応することを防止します。

#### created_at

```
created_at TEXT DEFAULT CURRENT_TIMESTAMP
```

レコードが作成された日時を保存します。`DEFAULT CURRENT_TIMESTAMP`を指定すると、値を明示的に指定しなくても現在日時が自動的に設定されます。

## CREATE TABLE文でテーブルを作成する

### CREATE TABLE文の書き方

これらの設計をSQL文にまとめると、以下のようになります。

```sql
-- Perl: 5.10以上
-- 依存: DBI, DBD::SQLite（cpanmでインストール）
CREATE TABLE IF NOT EXISTS urls (
    id INTEGER PRIMARY KEY,
    original_url TEXT NOT NULL,
    short_code TEXT UNIQUE NOT NULL,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP
)
```

この文をポイントごとに解説します。

#### CREATE TABLE IF NOT EXISTS

`CREATE TABLE`はテーブルを作成するSQL文です。`IF NOT EXISTS`を付けると、テーブルが既に存在する場合はエラーにならず、何もしません。これにより、スクリプトを何度実行してもエラーにならない「冪等性」を確保できます。

#### カラム定義

括弧の中にカラム名、データ型、制約を記述します。複数のカラムはカンマで区切ります。

- `INTEGER`: 整数型
- `TEXT`: 文字列型
- `PRIMARY KEY`: 主キー（一意かつNOT NULL）
- `UNIQUE`: 重複を許可しない
- `NOT NULL`: 空の値を許可しない
- `DEFAULT`: デフォルト値を設定

## Perlからテーブルを作成する

### $dbh->do()でSQLを実行する

Perlからテーブルを作成するには、前回学んだ`$dbh`（データベースハンドル）の`do`メソッドを使います。

```perl
#!/usr/bin/env perl
# create_table.pl
# Perl: 5.10以上
# 依存: DBI, DBD::SQLite（cpanmでインストール）
use strict;
use warnings;
use DBI;

my $dbh = DBI->connect(
    "dbi:SQLite:dbname=urls.db",
    "",
    "",
    { RaiseError => 1, AutoCommit => 1 }
);

my $sql = <<'SQL';
CREATE TABLE IF NOT EXISTS urls (
    id INTEGER PRIMARY KEY,
    original_url TEXT NOT NULL,
    short_code TEXT UNIQUE NOT NULL,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP
)
SQL

$dbh->do($sql);

print "テーブルを作成しました！\n";

$dbh->disconnect;
```

コードの各部分を解説します。

#### ヒアドキュメント

```perl
my $sql = <<'SQL';
CREATE TABLE IF NOT EXISTS urls (
    ...
)
SQL
```

複数行にまたがるSQL文を読みやすく書くために、ヒアドキュメントを使用しています。`<<'SQL'`から`SQL`までの間の文字列がそのまま変数`$sql`に格納されます。シングルクォートで囲んでいるため、変数展開は行われません。

#### $dbh->do($sql)

```perl
$dbh->do($sql);
```

`do`メソッドは、結果を返さないSQL文を実行するためのメソッドです。CREATE TABLE、INSERT、UPDATE、DELETEなど、データを取得しないSQL文に使用します。

`RaiseError => 1`を設定しているため、SQL文にエラーがあれば自動的に例外が発生してスクリプトが停止します。

## 動作確認

### スクリプトを実行する

上記のコードを`create_table.pl`として保存し、ターミナルで実行してください。

```bash
perl create_table.pl
```

「テーブルを作成しました！」と表示されれば成功です。

### テーブルの存在を確認する

SQLiteには、データベースの構造を確認するためのコマンドラインツール`sqlite3`があります。以下のコマンドでテーブルが作成されたことを確認できます。

```bash
sqlite3 urls.db ".schema urls"
```

以下のような出力が表示されれば、テーブルが正しく作成されています。

```sql
CREATE TABLE urls (
    id INTEGER PRIMARY KEY,
    original_url TEXT NOT NULL,
    short_code TEXT UNIQUE NOT NULL,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP
);
```

もし`sqlite3`コマンドが使えない環境でも心配ありません。次回以降、Perlからデータを挿入・取得することでテーブルの動作を確認していきます。

## まとめ

### 今回学んだこと

第6回では、以下のことを学びました。

- テーブルはデータを表形式で管理する単位であり、カラムはデータの項目を表す
- URL短縮に必要なカラムはid、original_url、short_code、created_atの4つである
- `CREATE TABLE IF NOT EXISTS`で冪等なテーブル作成ができる
- `$dbh->do($sql)`でPerlからDDL（データ定義言語）を実行できる

### 次回予告

次回は「URLを登録しよう — INSERT文とプレースホルダ」をテーマに、短縮したURLをデータベースに保存する方法を学びます。プレースホルダを使った安全なSQL実行も紹介します。お楽しみに。
