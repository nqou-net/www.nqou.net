---
title: '第4回-複数サービスを統一インターフェースで扱う設計 - 天気情報ツールで覚えるPerl'
draft: false
date: 2026-01-07T22:34:20+09:00
iso8601: 2026-01-07T22:34:20+09:00
tags:
  - perl
  - moo
  - multi-service
  - polymorphism
  - unified-interface
description: '3つ目のサービスを追加し複数サービスをループ処理。統一インターフェースの効果を体験します。Perl/Moo連載第4回。'
---

## はじめに

前回は、`OldWeatherAPI` を `WeatherService` と同じインターフェースで使えるようにする橋渡しクラス `OldWeatherAdapter` を作成しました。

{{< linkcard "/2026/01/07/223217/" >}}

今回は、3つ目の天気サービスを追加し、複数のサービスをループで統一的に処理する方法を学びます。

### 前回の振り返り

前回作成した橋渡しクラスにより、以下が実現しました。

- `OldWeatherAPI` を `WeatherService` と同じ `get_weather` / `show_weather` メソッドで呼び出せる
- 戻り値の形式も統一された
- 既存のコードを変更せずに対応できた

## 今回の目標

第4回となる今回は、海外の天気サービス `ForeignWeatherService` を追加し、3つのサービスをループで処理します。統一インターフェースの真価を体験しましょう。

### 新しい概念: 複数サービスの統一処理（多態性）

今回学ぶ新しい概念は「複数サービスの統一処理」、つまり**多態性（ポリモーフィズム）**の実践です。

多態性とは、異なるクラスのオブジェクトを同じインターフェースで扱える性質のことです。橋渡しクラスを使って複数のサービスを同じ形式に揃えることで、この多態性を実現します。

## ForeignWeatherServiceの登場

新たに、海外の天気情報を提供する `ForeignWeatherService` を追加します。このサービスも独自のインターフェースを持っています。

### ForeignWeatherServiceクラスの定義

```perl
package ForeignWeatherService {
    use v5.36;
    use Moo;

    # メソッド名: retrieve_conditions
    # 戻り値: 配列リファレンス ['Sunny', 25]
    sub retrieve_conditions ($self, $city_code) {
        my %data = (
            'NYC' => ['Sunny',  20],
            'LON' => ['Cloudy', 15],
            'PAR' => ['Rainy',  12],
        );

        return $data{$city_code} // ['Unknown', 0];
    }

    # 都市コードと日本語名のマッピング
    sub city_codes ($self) {
        return {
            'ニューヨーク' => 'NYC',
            'ロンドン'     => 'LON',
            'パリ'         => 'PAR',
        };
    }
}
```

このサービスの特徴を見てみましょう。

- **メソッド名が異なる**: `retrieve_conditions`
- **戻り値が異なる**: 配列リファレンス `['Sunny', 25]`
- **引数が異なる**: 都市名ではなく都市コード（`'NYC'` など）
- **天気が英語**: `'Sunny'`, `'Cloudy'`, `'Rainy'`

## ForeignWeatherAdapterの作成

`ForeignWeatherService` を統一インターフェースで使えるようにする橋渡しクラスを作成します。

```perl
package ForeignWeatherAdapter {
    use v5.36;
    use Moo;

    has 'foreign_service' => (
        is       => 'ro',
        required => 1,
    );

    # 英語から日本語への変換テーブル
    my %CONDITION_MAP = (
        'Sunny'   => '晴れ',
        'Cloudy'  => '曇り',
        'Rainy'   => '雨',
        'Unknown' => '不明',
    );

    sub get_weather ($self, $city) {
        # 都市名を都市コードに変換
        my $codes = $self->foreign_service->city_codes;
        my $city_code = $codes->{$city};

        unless ($city_code) {
            return { condition => '不明', temperature => 0 };
        }

        # ForeignWeatherServiceのメソッドを呼び出し
        my $result = $self->foreign_service->retrieve_conditions($city_code);

        # 戻り値を変換
        my ($condition_en, $temp) = @$result;
        my $condition_ja = $CONDITION_MAP{$condition_en} // '不明';

        return {
            condition   => $condition_ja,
            temperature => $temp,
        };
    }

    sub show_weather ($self, $city) {
        my $weather = $self->get_weather($city);
        say "$city の天気: $weather->{condition}（気温: $weather->{temperature}℃）";
    }
}
```

この橋渡しクラスは、前回の `OldWeatherAdapter` と同様の構造を持っています。

- 委譲先（`foreign_service`）を保持
- `get_weather` で元のメソッドを呼び出し、戻り値を変換
- 都市名→都市コードの変換、英語→日本語の変換を実行

## 複数サービスをループで処理

3つのサービスを配列に格納し、ループで統一的に処理してみましょう。

```perl
#!/usr/bin/env perl
use v5.36;

# WeatherService クラス
package WeatherService {
    use v5.36;
    use Moo;

    has 'name' => (is => 'ro', default => sub { '国内天気サービス' });

    sub get_weather ($self, $city) {
        my %weather_data = (
            '東京' => { condition => '晴れ', temperature => 25 },
            '大阪' => { condition => '曇り', temperature => 23 },
            '札幌' => { condition => '雨',   temperature => 18 },
        );
        return $weather_data{$city} // { condition => '不明', temperature => 0 };
    }

    sub show_weather ($self, $city) {
        my $weather = $self->get_weather($city);
        say "$city の天気: $weather->{condition}（気温: $weather->{temperature}℃）";
    }
}

# OldWeatherAPI クラス
package OldWeatherAPI {
    use v5.36;
    use Moo;

    sub fetch_weather_info ($self, $location) {
        my %data = (
            '東京' => '晴れ/25度',
            '大阪' => '曇り/23度',
            '名古屋' => '晴れ/26度',
        );
        return $data{$location} // '情報なし';
    }
}

# OldWeatherAdapter クラス
package OldWeatherAdapter {
    use v5.36;
    use Moo;

    has 'old_api' => (is => 'ro', required => 1);
    has 'name' => (is => 'ro', default => sub { 'レガシー天気API' });

    sub get_weather ($self, $city) {
        my $info = $self->old_api->fetch_weather_info($city);

        if ($info eq '情報なし') {
            return { condition => '不明', temperature => 0 };
        }

        my ($condition, $temp_str) = split '/', $info;
        $temp_str =~ s/度$//;

        return {
            condition   => $condition,
            temperature => int($temp_str),
        };
    }

    sub show_weather ($self, $city) {
        my $weather = $self->get_weather($city);
        say "$city の天気: $weather->{condition}（気温: $weather->{temperature}℃）";
    }
}

# ForeignWeatherService クラス
package ForeignWeatherService {
    use v5.36;
    use Moo;

    sub retrieve_conditions ($self, $city_code) {
        my %data = (
            'NYC' => ['Sunny',  20],
            'LON' => ['Cloudy', 15],
            'PAR' => ['Rainy',  12],
        );
        return $data{$city_code} // ['Unknown', 0];
    }

    sub city_codes ($self) {
        return {
            'ニューヨーク' => 'NYC',
            'ロンドン'     => 'LON',
            'パリ'         => 'PAR',
        };
    }
}

# ForeignWeatherAdapter クラス
package ForeignWeatherAdapter {
    use v5.36;
    use Moo;

    has 'foreign_service' => (is => 'ro', required => 1);
    has 'name' => (is => 'ro', default => sub { '海外天気サービス' });

    my %CONDITION_MAP = (
        'Sunny'   => '晴れ',
        'Cloudy'  => '曇り',
        'Rainy'   => '雨',
        'Unknown' => '不明',
    );

    sub get_weather ($self, $city) {
        my $codes = $self->foreign_service->city_codes;
        my $city_code = $codes->{$city};

        unless ($city_code) {
            return { condition => '不明', temperature => 0 };
        }

        my $result = $self->foreign_service->retrieve_conditions($city_code);
        my ($condition_en, $temp) = @$result;
        my $condition_ja = $CONDITION_MAP{$condition_en} // '不明';

        return {
            condition   => $condition_ja,
            temperature => $temp,
        };
    }

    sub show_weather ($self, $city) {
        my $weather = $self->get_weather($city);
        say "$city の天気: $weather->{condition}（気温: $weather->{temperature}℃）";
    }
}

# メイン処理
package main {
    use v5.36;

    # 3つのサービスを準備
    my $service1 = WeatherService->new;
    my $service2 = OldWeatherAdapter->new(old_api => OldWeatherAPI->new);
    my $service3 = ForeignWeatherAdapter->new(foreign_service => ForeignWeatherService->new);

    # 配列にまとめる
    my @services = ($service1, $service2, $service3);

    say "=== 複数サービス統合 天気情報ツール ===";
    say "";

    # 各サービスの天気を表示
    for my $service (@services) {
        say "【" . $service->name . "】";

        # 全サービス共通のメソッドで呼び出せる！
        if ($service->name eq '海外天気サービス') {
            $service->show_weather('ニューヨーク');
            $service->show_weather('ロンドン');
            $service->show_weather('パリ');
        } else {
            $service->show_weather('東京');
            $service->show_weather('大阪');
        }

        say "";
    }
}
```

実行結果:

```
=== 複数サービス統合 天気情報ツール ===

【国内天気サービス】
東京 の天気: 晴れ（気温: 25℃）
大阪 の天気: 曇り（気温: 23℃）

【レガシー天気API】
東京 の天気: 晴れ（気温: 25℃）
大阪 の天気: 曇り（気温: 23℃）

【海外天気サービス】
ニューヨーク の天気: 晴れ（気温: 20℃）
ロンドン の天気: 曇り（気温: 15℃）
パリ の天気: 雨（気温: 12℃）

```

## 統一インターフェースの効果

3つのサービスを統一インターフェースで扱えるようになったことで、以下の効果が得られました。

### 効果1: ループ処理が可能に

```perl
for my $service (@services) {
    $service->show_weather('東京');
}
```

どのサービスも同じ `show_weather` メソッドを持っているため、ループで統一的に処理できます。

### 効果2: サービスの追加が容易に

新しいサービスが追加されても、橋渡しクラスを作成するだけで対応できます。メイン処理のロジックを変更する必要がありません。

### 効果3: 既存コードへの影響がない

元のサービスクラス（`OldWeatherAPI`, `ForeignWeatherService`）は一切変更していません。

## 今回の完成コード

今回作成した完成コードを以下に示します。

```perl
#!/usr/bin/env perl
use v5.36;

# WeatherService クラス
# 国内天気サービス（統一インターフェースの基準）
package WeatherService {
    use v5.36;
    use Moo;

    has 'name' => (is => 'ro', default => sub { '国内天気サービス' });

    sub get_weather ($self, $city) {
        my %weather_data = (
            '東京' => { condition => '晴れ', temperature => 25 },
            '大阪' => { condition => '曇り', temperature => 23 },
            '札幌' => { condition => '雨',   temperature => 18 },
        );
        return $weather_data{$city} // { condition => '不明', temperature => 0 };
    }

    sub show_weather ($self, $city) {
        my $weather = $self->get_weather($city);
        say "$city の天気: $weather->{condition}（気温: $weather->{temperature}℃）";
    }
}

# OldWeatherAPI クラス
# レガシーな天気情報API
package OldWeatherAPI {
    use v5.36;
    use Moo;

    sub fetch_weather_info ($self, $location) {
        my %data = (
            '東京' => '晴れ/25度',
            '大阪' => '曇り/23度',
            '名古屋' => '晴れ/26度',
        );
        return $data{$location} // '情報なし';
    }
}

# OldWeatherAdapter クラス
# OldWeatherAPI用の橋渡しクラス
package OldWeatherAdapter {
    use v5.36;
    use Moo;

    has 'old_api' => (is => 'ro', required => 1);
    has 'name' => (is => 'ro', default => sub { 'レガシー天気API' });

    sub get_weather ($self, $city) {
        my $info = $self->old_api->fetch_weather_info($city);

        if ($info eq '情報なし') {
            return { condition => '不明', temperature => 0 };
        }

        my ($condition, $temp_str) = split '/', $info;
        $temp_str =~ s/度$//;

        return {
            condition   => $condition,
            temperature => int($temp_str),
        };
    }

    sub show_weather ($self, $city) {
        my $weather = $self->get_weather($city);
        say "$city の天気: $weather->{condition}（気温: $weather->{temperature}℃）";
    }
}

# ForeignWeatherService クラス
# 海外天気情報サービス
package ForeignWeatherService {
    use v5.36;
    use Moo;

    sub retrieve_conditions ($self, $city_code) {
        my %data = (
            'NYC' => ['Sunny',  20],
            'LON' => ['Cloudy', 15],
            'PAR' => ['Rainy',  12],
        );
        return $data{$city_code} // ['Unknown', 0];
    }

    sub city_codes ($self) {
        return {
            'ニューヨーク' => 'NYC',
            'ロンドン'     => 'LON',
            'パリ'         => 'PAR',
        };
    }
}

# ForeignWeatherAdapter クラス
# ForeignWeatherService用の橋渡しクラス
package ForeignWeatherAdapter {
    use v5.36;
    use Moo;

    has 'foreign_service' => (is => 'ro', required => 1);
    has 'name' => (is => 'ro', default => sub { '海外天気サービス' });

    my %CONDITION_MAP = (
        'Sunny'   => '晴れ',
        'Cloudy'  => '曇り',
        'Rainy'   => '雨',
        'Unknown' => '不明',
    );

    sub get_weather ($self, $city) {
        my $codes = $self->foreign_service->city_codes;
        my $city_code = $codes->{$city};

        unless ($city_code) {
            return { condition => '不明', temperature => 0 };
        }

        my $result = $self->foreign_service->retrieve_conditions($city_code);
        my ($condition_en, $temp) = @$result;
        my $condition_ja = $CONDITION_MAP{$condition_en} // '不明';

        return {
            condition   => $condition_ja,
            temperature => $temp,
        };
    }

    sub show_weather ($self, $city) {
        my $weather = $self->get_weather($city);
        say "$city の天気: $weather->{condition}（気温: $weather->{temperature}℃）";
    }
}

# メイン処理
package main {
    use v5.36;

    say "=== 複数サービス統合 天気情報ツール ===";
    say "";

    # 3つのサービスを準備（橋渡しクラスでラップ）
    my @services = (
        WeatherService->new,
        OldWeatherAdapter->new(old_api => OldWeatherAPI->new),
        ForeignWeatherAdapter->new(foreign_service => ForeignWeatherService->new),
    );

    # 各サービスの情報を表示
    for my $service (@services) {
        say "【" . $service->name . "】";

        if ($service->name eq '海外天気サービス') {
            $service->show_weather('ニューヨーク');
            $service->show_weather('ロンドン');
            $service->show_weather('パリ');
        } else {
            $service->show_weather('東京');
            $service->show_weather('大阪');
        }

        say "";
    }

    say "--- 統一インターフェースの効果 ---";
    say "・3つのサービスを同じメソッドで呼び出せる";
    say "・ループで統一的に処理できる";
    say "・新しいサービスの追加が容易";
}
```

実行方法:

```shell
perl weather_multi_service.pl
```

## まとめ

今回は、3つ目の天気サービス `ForeignWeatherService` を追加し、複数のサービスをループで統一的に処理する方法を学びました。

- 新しいサービスには新しい橋渡しクラスを作成して対応した
- 複数のサービスを配列にまとめてループ処理できた
- 統一インターフェースによる多態性を体験した

## 次回予告

次回は最終回です。ここまで作成してきた「橋渡しクラス」の設計には、実は名前があります。GoFデザインパターンの1つとして知られるその名前と、パターンの本質について解説します。お楽しみに！
