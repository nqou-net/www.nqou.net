---
date: 2026-01-31T00:17:57+09:00
description: RPG戦闘エンジン第4回。Commandパターンを導入し、各行動をコマンドオブジェクトとしてカプセル化します。if/else地獄から脱出し、拡張性の高い設計を実現しましょう。
draft: false
epoch: 1769786277
image: /public_images/2026/rpg-battle-engine-header.png
iso8601: 2026-01-31T00:17:57+09:00
series:
  - PerlとMooでテキストRPG戦闘エンジンを作ろう
tags:
  - perl
  - moo
  - command-pattern
  - rpg
title: '【第4回】行動をコマンドにしよう - PerlとMooでテキストRPG戦闘エンジンを作ろう'
---

前回、if/elseによる行動分岐が破綻する様子を見ました。機能を追加するたびに分岐が増え、コードが読みにくくなり、テストも困難になっていく。

今回は、Commandパターンを導入してこの問題を解決します。

![Commandパターンのコンベアベルト](/public_images/2026/rpg-battle-ep4-command.png)

## Commandパターンとは

Commandパターンは、操作をオブジェクトとしてカプセル化するデザインパターンです。GoF（Gang of Four）の23パターンの1つで、以下の特徴を持ちます。

- 操作（コマンド）をオブジェクトとして表現する
- コマンドの実行者と実行内容を分離する
- コマンドを保存、キューイング、取り消しできる

実は、前回まで作ってきた`Action`クラスは、すでにCommandパターンの基本形になっています。今回はこれをより本格的なCommand設計に発展させます。

## Commandロールを定義する

MooではRoleを使って共通のインターフェースを定義できます。すべてのコマンドが持つべきメソッドを`Command`ロールとして定義しましょう。

```perl
package Command;
use v5.36;
use Moo::Role;

requires 'execute';

has actor => (
    is       => 'ro',
    required => 1,
);

has target => (
    is       => 'ro',
    required => 0,
);
```

`requires 'execute'`により、このロールを使うクラスは必ず`execute`メソッドを実装する必要があります。`actor`は行動者、`target`は行動の対象です。

## 各コマンドを実装する

`Command`ロールを使って各行動を再実装します。

### AttackCommand

```perl
package AttackCommand;
use v5.36;
use Moo;

with 'Command';

sub execute($self) {
    my $actor = $self->actor;
    my $target = $self->target;
    my $damage = $actor->attack_power;
    my $actual = $target->take_damage($damage);
    
    my $msg = $actor->name . "の攻撃！ " . $target->name . "に " . $actual . " のダメージ！";
    $msg .= "（防御で軽減）" if $actual < $damage;
    say $msg;
}
```

`with 'Command'`でロールを取り込み、`execute`メソッドを実装しています。

### DefendCommand

```perl
package DefendCommand;
use v5.36;
use Moo;

with 'Command';

sub execute($self) {
    my $actor = $self->actor;
    $actor->is_defending(1);
    say $actor->name . "は防御の構えをとった！";
}
```

### ItemCommand

```perl
package ItemCommand;
use v5.36;
use Moo;

with 'Command';

has item_name => (
    is      => 'ro',
    default => 'ポーション',
);

has heal_amount => (
    is      => 'ro',
    default => 30,
);

sub execute($self) {
    my $actor = $self->actor;
    my $max_hp = $actor->max_hp;
    my $new_hp = $actor->hp + $self->heal_amount;
    $actor->hp($new_hp > $max_hp ? $max_hp : $new_hp);
    
    say $actor->name . "は" . $self->item_name . "を使った！ HPが " . $self->heal_amount . " 回復！";
}
```

### MagicCommand

```perl
package MagicCommand;
use v5.36;
use Moo;

with 'Command';

has spell_name => (
    is      => 'ro',
    default => 'ファイアボール',
);

has damage => (
    is      => 'ro',
    default => 25,
);

has mp_cost => (
    is      => 'ro',
    default => 10,
);

sub execute($self) {
    my $actor = $self->actor;
    my $target = $self->target;
    
    if ($actor->mp < $self->mp_cost) {
        say $actor->name . "はMPが足りない！";
        return;
    }
    
    $actor->mp($actor->mp - $self->mp_cost);
    my $actual = $target->take_damage($self->damage);
    
    say $actor->name . "は" . $self->spell_name . "を唱えた！ " . $target->name . "に " . $actual . " のダメージ！";
}
```

## コマンドの実行

コマンドを実行する側のコードはシンプルになります。

```perl
# コマンドを作成
my $attack = AttackCommand->new(
    actor  => $hero,
    target => $slime,
);

# コマンドを実行
$attack->execute();
```

コマンドオブジェクトを作成し、`execute`を呼ぶだけです。どんな行動でも同じインターフェースで実行できます。

## CommandInvoker: コマンドの実行者

コマンドを実行する責務を持つクラスを作ります。これにより、コマンドの実行前後に共通の処理を挟めるようになります。

```perl
package CommandInvoker;
use v5.36;
use Moo;

has history => (
    is      => 'ro',
    default => sub { [] },
);

sub invoke($self, $command) {
    push $self->history->@*, $command;
    $command->execute();
}

sub get_history($self) {
    return $self->history->@*;
}
```

`invoke`メソッドでコマンドを実行し、履歴に記録します。この履歴があれば、後で「何が起きたか」を振り返ったり、リプレイ機能を実装したりできます。

## 完成コード

```perl
#!/usr/bin/env perl
use v5.36;

package Command {
    use Moo::Role;
    
    requires 'execute';
    
    has actor => (
        is       => 'ro',
        required => 1,
    );
    
    has target => (
        is       => 'ro',
        required => 0,
    );
}

package Character {
    use Moo;
    
    has name => (
        is       => 'ro',
        required => 1,
    );
    
    has hp => (
        is      => 'rw',
        default => 100,
    );
    
    has max_hp => (
        is      => 'ro',
        default => 100,
    );
    
    has mp => (
        is      => 'rw',
        default => 50,
    );
    
    has attack_power => (
        is      => 'ro',
        default => 10,
    );
    
    has is_defending => (
        is      => 'rw',
        default => 0,
    );
    
    sub is_alive($self) {
        return $self->hp > 0;
    }
    
    sub take_damage($self, $damage) {
        my $actual_damage = $self->is_defending ? int($damage / 2) : $damage;
        my $new_hp = $self->hp - $actual_damage;
        $self->hp($new_hp < 0 ? 0 : $new_hp);
        $self->is_defending(0);
        return $actual_damage;
    }
}

package AttackCommand {
    use Moo;
    with 'Command';
    
    sub execute($self) {
        my $actor = $self->actor;
        my $target = $self->target;
        my $damage = $actor->attack_power;
        my $actual = $target->take_damage($damage);
        
        my $msg = $actor->name . "の攻撃！ " . $target->name . "に " . $actual . " のダメージ！";
        $msg .= "（防御で軽減）" if $actual < $damage;
        say $msg;
    }
}

package DefendCommand {
    use Moo;
    with 'Command';
    
    sub execute($self) {
        my $actor = $self->actor;
        $actor->is_defending(1);
        say $actor->name . "は防御の構えをとった！";
    }
}

package ItemCommand {
    use Moo;
    with 'Command';
    
    has item_name => (
        is      => 'ro',
        default => 'ポーション',
    );
    
    has heal_amount => (
        is      => 'ro',
        default => 30,
    );
    
    sub execute($self) {
        my $actor = $self->actor;
        my $max_hp = $actor->max_hp;
        my $new_hp = $actor->hp + $self->heal_amount;
        $actor->hp($new_hp > $max_hp ? $max_hp : $new_hp);
        
        say $actor->name . "は" . $self->item_name . "を使った！ HPが " . $self->heal_amount . " 回復！";
    }
}

package MagicCommand {
    use Moo;
    with 'Command';
    
    has spell_name => (
        is      => 'ro',
        default => 'ファイアボール',
    );
    
    has damage => (
        is      => 'ro',
        default => 25,
    );
    
    has mp_cost => (
        is      => 'ro',
        default => 10,
    );
    
    sub execute($self) {
        my $actor = $self->actor;
        my $target = $self->target;
        
        if ($actor->mp < $self->mp_cost) {
            say $actor->name . "はMPが足りない！";
            return;
        }
        
        $actor->mp($actor->mp - $self->mp_cost);
        my $actual = $target->take_damage($self->damage);
        
        say $actor->name . "は" . $self->spell_name . "を唱えた！ " . $target->name . "に " . $actual . " のダメージ！";
    }
}

package CommandInvoker {
    use Moo;
    
    has history => (
        is      => 'ro',
        default => sub { [] },
    );
    
    sub invoke($self, $command) {
        push $self->history->@*, $command;
        $command->execute();
    }
}

# メイン処理
my $hero = Character->new(
    name         => '勇者',
    hp           => 100,
    max_hp       => 100,
    mp           => 50,
    attack_power => 15,
);

my $slime = Character->new(
    name         => 'スライム',
    hp           => 50,
    max_hp       => 50,
    attack_power => 10,
);

my $invoker = CommandInvoker->new();

say "=== Commandパターンによる戦闘デモ ===";
say "勇者 HP: " . $hero->hp . " MP: " . $hero->mp;
say "スライム HP: " . $slime->hp;
say "";

# 各種コマンドを実行
$invoker->invoke(AttackCommand->new(actor => $hero, target => $slime));
$invoker->invoke(DefendCommand->new(actor => $slime));
$invoker->invoke(MagicCommand->new(actor => $hero, target => $slime, spell_name => 'ファイアボール', damage => 25, mp_cost => 10));

say "";
say "=== 戦闘履歴 ===";
say "実行されたコマンド数: " . scalar($invoker->history->@*);

say "";
say "最終状態:";
say "勇者 HP: " . $hero->hp . " MP: " . $hero->mp;
say "スライム HP: " . $slime->hp;
```

## 実行結果

```
=== Commandパターンによる戦闘デモ ===
勇者 HP: 100 MP: 50
スライム HP: 50

勇者の攻撃！ スライムに 15 のダメージ！
スライムは防御の構えをとった！
勇者はファイアボールを唱えた！ スライムに 12 のダメージ！（防御で軽減）

=== 戦闘履歴 ===
実行されたコマンド数: 3

最終状態:
勇者 HP: 100 MP: 40
スライム HP: 23
```

Commandパターンにより、行動がオブジェクトとして管理され、履歴も記録できるようになりました。

## if/elseとの比較

| 観点 | if/elseによる分岐 | Commandパターン |
|------|------------------|-----------------|
| 新しい行動の追加 | 分岐を追加 | 新しいクラスを追加 |
| 既存コードの変更 | 必要 | 不要 |
| テストのしやすさ | 全分岐をテスト | クラスごとにテスト |
| 履歴・取り消し | 困難 | 容易 |

## 今回のポイント

- Commandパターンは操作をオブジェクトとしてカプセル化する
- Moo::Roleで共通インターフェースを定義できる
- CommandInvokerでコマンドの実行と履歴管理を行う
- 新しい行動はクラスを追加するだけで実現できる（OCP準拠）

次回は、戦闘のフェーズ（開始→プレイヤーターン→敵ターン→終了）を管理するStateパターンを導入します。

---

前回: {{< linkcard "https://www.nqou.net/2026/01/31/001740/" >}}

次回: {{< linkcard "https://www.nqou.net/2026/01/31/001814/" >}}
