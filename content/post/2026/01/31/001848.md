---
date: 2026-01-31T00:18:48+09:00
description: RPG戦闘エンジン第7回。Observerパターンを導入し、HP変化や戦闘終了などのイベントを購読者に通知します。イベント駆動プログラミングの基礎を学びましょう。
draft: false
epoch: 1769786328
image: /public_images/2026/rpg-battle-engine-header.png
iso8601: 2026-01-31T00:18:48+09:00
series:
  - PerlとMooでテキストRPG戦闘エンジンを作ろう
tags:
  - perl
  - moo
  - observer-pattern
  - event-driven
title: '【第7回】HP変化を画面に通知したい - PerlとMooでテキストRPG戦闘エンジンを作ろう'
---

前回、Strategyパターンで敵のAIを切り替えられるようにしました。これで敵ごとに異なる行動パターンを持たせることができます。

今回は、戦闘中のイベントを扱います。例えば以下のような場面を考えてみてください。

- HPが減ったら画面にダメージエフェクトを表示したい
- 戦闘が終わったら経験値やアイテムを獲得したい
- 特定の条件を満たしたらイベントを発生させたい

これらを実現するために、Observerパターンを導入します。

![Observerパターンのイベント通知](/public_images/2026/rpg-battle-ep7-observer.png)

## Observerパターンとは

Observerパターンは、あるオブジェクトの状態が変化したときに、それに依存する他のオブジェクトに自動的に通知するデザインパターンです。

新聞の購読を例に考えてみましょう。

- 新聞社（Subject）: 新聞を発行する
- 購読者（Observer）: 新聞が届くのを待っている

購読者が新聞社に登録すると、新聞が発行されるたびに自動的に届きます。購読を解除すれば、届かなくなります。

## Subjectロールを定義する

イベントを発行する側（Subject）のインターフェースを定義します。

```perl
package Subject;
use v5.36;
use Moo::Role;

has observers => (
    is      => 'ro',
    default => sub { [] },
);

sub attach($self, $observer) {
    push $self->observers->@*, $observer;
}

sub detach($self, $observer) {
    $self->observers->@* = grep { $_ ne $observer } $self->observers->@*;
}

sub notify($self, $event, $data) {
    for my $observer ($self->observers->@*) {
        $observer->update($event, $data);
    }
}
```

`attach`で購読者を追加、`detach`で削除、`notify`でイベントを通知します。

## Observerロールを定義する

イベントを受け取る側（Observer）のインターフェースを定義します。

```perl
package Observer;
use v5.36;
use Moo::Role;

requires 'update';
```

`update`メソッドでイベントを受け取ります。

## BattleLoggerを実装する

戦闘ログを記録するObserverを作ります。

```perl
package BattleLogger;
use v5.36;
use Moo;

with 'Observer';

has logs => (
    is      => 'ro',
    default => sub { [] },
);

sub update($self, $event, $data) {
    my $timestamp = localtime();
    my $log_entry = "[$timestamp] $event: " . ($data->{message} // '');
    push $self->logs->@*, $log_entry;
    
    # コンソールにも出力
    say "[LOG] $event" if $event =~ /^(battle_|damage_|heal_)/;
}

sub dump_logs($self) {
    say "=== 戦闘ログ ===";
    say $_ for $self->logs->@*;
}
```

すべてのイベントを記録し、重要なイベントはコンソールにも出力します。

## DamageEffectを実装する

ダメージを受けたときにエフェクトを表示するObserverを作ります。

```perl
package DamageEffect;
use v5.36;
use Moo;

with 'Observer';

sub update($self, $event, $data) {
    return unless $event eq 'damage_taken';
    
    my $target = $data->{target};
    my $damage = $data->{damage};
    my $hp_ratio = $target->hp / $target->max_hp;
    
    if ($hp_ratio <= 0.25) {
        say "  ★ " . $target->name . "は瀕死だ！";
    } elsif ($hp_ratio <= 0.5) {
        say "  ※ " . $target->name . "のHPが半分以下！";
    }
}
```

HPが一定以下になったら警告を表示します。

## BattleRewardを実装する

戦闘終了時に報酬を与えるObserverを作ります。

```perl
package BattleReward;
use v5.36;
use Moo;

with 'Observer';

has exp_gained => (
    is      => 'rw',
    default => 0,
);

has gold_gained => (
    is      => 'rw',
    default => 0,
);

sub update($self, $event, $data) {
    return unless $event eq 'battle_end';
    return unless $data->{winner} eq 'player';
    
    my $exp = int(rand(50)) + 10;
    my $gold = int(rand(30)) + 5;
    
    $self->exp_gained($exp);
    $self->gold_gained($gold);
    
    say "";
    say " " . $exp . " の経験値を獲得！ ";
    say " " . $gold . " ゴールドを獲得！ ";
}
```

プレイヤーが勝利した場合のみ報酬を付与します。

## Subjectを組み込む

BattleContextにSubjectロールを組み込み、イベントを発行できるようにします。

```perl
package BattleContext;
use v5.36;
use Moo;

with 'Subject';

has player => (
    is       => 'ro',
    required => 1,
);

has enemy => (
    is       => 'ro',
    required => 1,
);

has current_state => (
    is      => 'rw',
    default => sub { undef },
);

has is_finished => (
    is      => 'rw',
    default => 0,
);

# ... 他のメソッド
```

## イベントを発行する

戦闘の各所でイベントを発行します。

```perl
# ダメージを受けたとき
sub take_damage($self, $damage) {
    my $actual_damage = $self->is_defending ? int($damage / 2) : $damage;
    my $new_hp = $self->hp - $actual_damage;
    $self->hp($new_hp < 0 ? 0 : $new_hp);
    $self->is_defending(0);
    
    # ダメージイベントを発行
    # (実際にはBattleContext経由で発行する必要がある)
    
    return $actual_damage;
}
```

## 完成コード

```perl
#!/usr/bin/env perl
use v5.36;

package Subject {
    use Moo::Role;
    
    has observers => (
        is      => 'ro',
        default => sub { [] },
    );
    
    sub attach($self, $observer) {
        push $self->observers->@*, $observer;
    }
    
    sub detach($self, $observer) {
        $self->observers->@* = grep { $_ ne $observer } $self->observers->@*;
    }
    
    sub notify($self, $event, $data = {}) {
        for my $observer ($self->observers->@*) {
            $observer->update($event, $data);
        }
    }
}

package Observer {
    use Moo::Role;
    requires 'update';
}

package Command {
    use Moo::Role;
    requires 'execute';
    
    has actor => (
        is       => 'ro',
        required => 1,
    );
    
    has target => (
        is       => 'ro',
        required => 0,
    );
    
    has battle => (
        is       => 'ro',
        required => 0,
    );
}

package Character {
    use Moo;
    
    has name => (
        is       => 'ro',
        required => 1,
    );
    
    has hp => (
        is      => 'rw',
        default => 100,
    );
    
    has max_hp => (
        is      => 'ro',
        default => 100,
    );
    
    has attack_power => (
        is      => 'ro',
        default => 10,
    );
    
    has is_defending => (
        is      => 'rw',
        default => 0,
    );
    
    sub is_alive($self) {
        return $self->hp > 0;
    }
    
    sub take_damage($self, $damage) {
        my $actual_damage = $self->is_defending ? int($damage / 2) : $damage;
        my $new_hp = $self->hp - $actual_damage;
        $self->hp($new_hp < 0 ? 0 : $new_hp);
        $self->is_defending(0);
        return $actual_damage;
    }
}

package AttackCommand {
    use Moo;
    with 'Command';
    
    sub execute($self) {
        my $actor = $self->actor;
        my $target = $self->target;
        my $damage = $actor->attack_power;
        my $actual = $target->take_damage($damage);
        
        my $msg = $actor->name . "の攻撃！ " . $target->name . "に " . $actual . " のダメージ！";
        $msg .= "（防御で軽減）" if $actual < $damage;
        say $msg;
        
        if ($self->battle) {
            $self->battle->notify('damage_taken', {
                target => $target,
                damage => $actual,
                message => $msg,
            });
        }
    }
}

package DefendCommand {
    use Moo;
    with 'Command';
    
    sub execute($self) {
        my $actor = $self->actor;
        $actor->is_defending(1);
        say $actor->name . "は防御の構えをとった！";
    }
}

package ItemCommand {
    use Moo;
    with 'Command';
    
    has item_name => (
        is      => 'ro',
        default => 'ポーション',
    );
    
    has heal_amount => (
        is      => 'ro',
        default => 30,
    );
    
    sub execute($self) {
        my $actor = $self->actor;
        my $max_hp = $actor->max_hp;
        my $old_hp = $actor->hp;
        my $new_hp = $old_hp + $self->heal_amount;
        $actor->hp($new_hp > $max_hp ? $max_hp : $new_hp);
        my $actual_heal = $actor->hp - $old_hp;
        
        say $actor->name . "は" . $self->item_name . "を使った！ HPが " . $actual_heal . " 回復！";
        
        if ($self->battle) {
            $self->battle->notify('heal_received', {
                target => $actor,
                amount => $actual_heal,
            });
        }
    }
}

package BattleLogger {
    use Moo;
    with 'Observer';
    
    has logs => (
        is      => 'ro',
        default => sub { [] },
    );
    
    sub update($self, $event, $data) {
        my $message = $data->{message} // '';
        push $self->logs->@*, "[$event] $message";
    }
    
    sub dump_logs($self) {
        say "=== 戦闘ログ（" . scalar($self->logs->@*) . "件）===";
        say $_ for $self->logs->@*;
    }
}

package DamageEffect {
    use Moo;
    with 'Observer';
    
    sub update($self, $event, $data) {
        return unless $event eq 'damage_taken';
        
        my $target = $data->{target};
        my $hp_ratio = $target->hp / $target->max_hp;
        
        if ($hp_ratio <= 0 ) {
            say "  ★★★ " . $target->name . "は倒れた！ ★★★";
        } elsif ($hp_ratio <= 0.25) {
            say "  ★ " . $target->name . "は瀕死だ！";
        } elsif ($hp_ratio <= 0.5) {
            say "  ※ " . $target->name . "のHPが半分以下！";
        }
    }
}

package BattleReward {
    use Moo;
    with 'Observer';
    
    sub update($self, $event, $data) {
        return unless $event eq 'battle_end';
        return unless $data->{winner} eq 'player';
        
        my $exp = int(rand(50)) + 10;
        my $gold = int(rand(30)) + 5;
        
        say "";
        say " " . $exp . " の経験値を獲得！ ";
        say " " . $gold . " ゴールドを獲得！ ";
    }
}

package BattleContext {
    use Moo;
    with 'Subject';
    
    has player => (
        is       => 'ro',
        required => 1,
    );
    
    has enemy => (
        is       => 'ro',
        required => 1,
    );
    
    has is_finished => (
        is      => 'rw',
        default => 0,
    );
}

# メイン処理
my $hero = Character->new(
    name         => '勇者',
    hp           => 100,
    max_hp       => 100,
    attack_power => 15,
);

my $slime = Character->new(
    name         => 'スライム',
    hp           => 40,
    max_hp       => 40,
    attack_power => 8,
);

my $battle = BattleContext->new(
    player => $hero,
    enemy  => $slime,
);

# Observerを登録
my $logger = BattleLogger->new();
my $damage_effect = DamageEffect->new();
my $reward = BattleReward->new();

$battle->attach($logger);
$battle->attach($damage_effect);
$battle->attach($reward);

# 戦闘開始
say "=== 戦闘開始！ ===";
$battle->notify('battle_start', { message => '戦闘開始' });
say $hero->name . " HP: " . $hero->hp . "  vs  " . $slime->name . " HP: " . $slime->hp;
say "";

# 戦闘ループ
my $turn = 0;
while ($hero->is_alive && $slime->is_alive) {
    $turn++;
    say "--- ターン $turn ---";
    
    # プレイヤーターン
    AttackCommand->new(actor => $hero, target => $slime, battle => $battle)->execute();
    last unless $slime->is_alive;
    
    # 敵ターン
    AttackCommand->new(actor => $slime, target => $hero, battle => $battle)->execute();
}

# 戦闘終了
say "";
say "=== 戦闘終了！ ===";
my $winner = $hero->is_alive ? 'player' : 'enemy';
$battle->notify('battle_end', { winner => $winner, message => '戦闘終了' });

if ($winner eq 'player') {
    say $slime->name . "を倒した！";
} else {
    say $hero->name . "は倒れた...";
}

# ログを出力
say "";
$logger->dump_logs();
```

## 実行結果

```
=== 戦闘開始！ ===
勇者 HP: 100  vs  スライム HP: 40

--- ターン 1 ---
勇者の攻撃！ スライムに 15 のダメージ！
  ※ スライムのHPが半分以下！
スライムの攻撃！ 勇者に 8 のダメージ！
--- ターン 2 ---
勇者の攻撃！ スライムに 15 のダメージ！
  ★ スライムは瀕死だ！
スライムの攻撃！ 勇者に 8 のダメージ！
--- ターン 3 ---
勇者の攻撃！ スライムに 15 のダメージ！
  ★★★ スライムは倒れた！ ★★★

=== 戦闘終了！ ===
スライムを倒した！

 42 の経験値を獲得！ 
 28 ゴールドを獲得！ 

=== 戦闘ログ（7件）===
[battle_start] 戦闘開始
[damage_taken] 勇者の攻撃！ スライムに 15 のダメージ！
[damage_taken] スライムの攻撃！ 勇者に 8 のダメージ！
[damage_taken] 勇者の攻撃！ スライムに 15 のダメージ！
[damage_taken] スライムの攻撃！ 勇者に 8 のダメージ！
[damage_taken] 勇者の攻撃！ スライムに 15 のダメージ！
[battle_end] 戦闘終了
```

Observerパターンにより、戦闘中のイベントが各Observerに通知され、それぞれが独自の処理を行っています。

## 今回のポイント

- Observerパターンは状態変化を関係者に自動通知する
- Subjectがイベントを発行し、Observerが受け取る
- 複数のObserverを登録でき、それぞれが独立して動作する
- イベント駆動プログラミングの基礎となるパターン

次回は、ここまで導入した4つのパターン（Command、State、Strategy、Observer）がどのように連携して動作するかを確認します。

---

前回: {{< linkcard "https://www.nqou.net/2026/01/31/001831/" >}}

次回: {{< linkcard "https://www.nqou.net/2026/01/31/001905/" >}}
