---
date: 2026-01-31T00:19:22+09:00
description: RPG戦闘エンジン第9回。これまで作成した全パターンを統合し、プレイヤーがコマンドを入力して敵と戦う対話型のREPLバトルシステムを完成させます。
draft: false
epoch: 1769786362
image: /public_images/2026/rpg-battle-engine-header.png
iso8601: 2026-01-31T00:19:22+09:00
series:
  - PerlとMooでテキストRPG戦闘エンジンを作ろう
tags:
  - perl
  - moo
  - cli
  - interactive
title: '【第9回】完成！テキストRPG戦闘エンジン - PerlとMooでテキストRPG戦闘エンジンを作ろう'
---

いよいよ最終段階です。これまで作成してきた4つのデザインパターンを統合し、プレイヤーが実際に操作できる対話型バトルシステムを完成させましょう。

![完成したRPGバトルシステム](/public_images/2026/rpg-battle-ep9-complete.png)

## 完成イメージ

```
=== 戦闘開始！ ===
オークが現れた！

勇者 HP:100 MP:50  vs  オーク HP:80

あなたのターン。行動を選んでください。
1: 攻撃  2: 防御  3: 魔法  4: アイテム
> 1

勇者の攻撃！ オークに 20 のダメージ！

--- オークのターン ---
オークの攻撃！ 勇者に 12 のダメージ！
```

## プレイヤー入力の処理

PlayerTurnStateを修正し、プレイヤーからの入力を受け付けます。

```perl
package PlayerTurnState {
    use Moo;
    with 'BattleState';
    
    sub enter($self, $ctx) {
        say "";
        say "あなたのターン。行動を選んでください。";
        say "1: 攻撃  2: 防御  3: 魔法  4: アイテム";
    }
    
    sub execute($self, $ctx) {
        print "> ";
        my $choice = <STDIN>;
        chomp $choice;
        
        my $command = $self->create_command($choice, $ctx);
        unless ($command) {
            say "無効な選択です。";
            return;
        }
        
        $command->execute();
        
        unless ($ctx->enemy->is_alive) {
            $ctx->change_state(BattleEndState->new(winner => 'player'));
            return;
        }
        
        $ctx->change_state(EnemyTurnState->new());
    }
    
    sub create_command($self, $choice, $ctx) {
        my $p = $ctx->player;
        my $e = $ctx->enemy;
        my $b = $ctx;
        
        return AttackCommand->new(actor => $p, target => $e, battle => $b) if $choice eq '1';
        return DefendCommand->new(actor => $p, battle => $b) if $choice eq '2';
        return MagicCommand->new(actor => $p, target => $e, battle => $b) if $choice eq '3';
        return ItemCommand->new(actor => $p, battle => $b) if $choice eq '4';
        return undef;
    }
    
    sub exit($self, $ctx) {}
}
```

## ステータス表示の追加

戦闘中のステータスを分かりやすく表示します。

```perl
sub show_status($ctx) {
    my $p = $ctx->player;
    my $e = $ctx->enemy;
    say "";
    say sprintf("%s HP:%d/%d MP:%d  vs  %s HP:%d/%d",
        $p->name, $p->hp, $p->max_hp, $p->mp,
        $e->name, $e->hp, $e->max_hp
    );
}
```

## 完成コード

```perl
#!/usr/bin/env perl
use v5.36;

# === ロール定義 ===
package Subject {
    use Moo::Role;
    has observers => (is => 'ro', default => sub { [] });
    sub attach($self, $o) { push $self->observers->@*, $o }
    sub notify($self, $ev, $d = {}) { $_->update($ev, $d) for $self->observers->@* }
}

package Observer { use Moo::Role; requires 'update' }
package Command {
    use Moo::Role;
    requires 'execute';
    has actor  => (is => 'ro', required => 1);
    has target => (is => 'ro');
    has battle => (is => 'ro');
}
package BattleState { use Moo::Role; requires 'enter', 'execute', 'exit' }
package AIStrategy { use Moo::Role; requires 'decide_action' }

# === キャラクター ===
package Character {
    use Moo;
    has name         => (is => 'ro', required => 1);
    has hp           => (is => 'rw', default => 100);
    has max_hp       => (is => 'ro', default => 100);
    has mp           => (is => 'rw', default => 50);
    has max_mp       => (is => 'ro', default => 50);
    has attack_power => (is => 'ro', default => 10);
    has is_defending => (is => 'rw', default => 0);
    has ai_strategy  => (is => 'rw');
    
    sub is_alive($self) { $self->hp > 0 }
    
    sub take_damage($self, $dmg, $battle = undef) {
        my $actual = $self->is_defending ? int($dmg / 2) : $dmg;
        my $new = $self->hp - $actual;
        $self->hp($new < 0 ? 0 : $new);
        $self->is_defending(0);
        $battle->notify('damage', { target => $self, amount => $actual }) if $battle;
        return $actual;
    }
}

# === コマンド ===
package AttackCommand {
    use Moo; with 'Command';
    sub execute($self) {
        my ($a, $t) = ($self->actor, $self->target);
        my $d = $t->take_damage($a->attack_power, $self->battle);
        my $m = $a->name . "の攻撃！ " . $t->name . "に " . $d . " のダメージ！";
        $m .= "（軽減）" if $d < $a->attack_power;
        say $m;
    }
}

package DefendCommand {
    use Moo; with 'Command';
    sub execute($self) {
        $self->actor->is_defending(1);
        say $self->actor->name . "は防御の構えをとった！";
    }
}

package MagicCommand {
    use Moo; with 'Command';
    has damage  => (is => 'ro', default => 30);
    has mp_cost => (is => 'ro', default => 15);
    
    sub execute($self) {
        my ($a, $t) = ($self->actor, $self->target);
        if ($a->mp < $self->mp_cost) {
            say $a->name . "はMPが足りない！";
            return;
        }
        $a->mp($a->mp - $self->mp_cost);
        my $d = $t->take_damage($self->damage, $self->battle);
        say $a->name . "はファイアボールを唱えた！ " . $t->name . "に " . $d . " のダメージ！";
    }
}

package ItemCommand {
    use Moo; with 'Command';
    has heal => (is => 'ro', default => 30);
    
    sub execute($self) {
        my $a = $self->actor;
        my $old = $a->hp;
        my $new = $old + $self->heal;
        $a->hp($new > $a->max_hp ? $a->max_hp : $new);
        say $a->name . "はポーションを使った！ HPが " . ($a->hp - $old) . " 回復！";
    }
}

# === AI ===
package DefensiveAI {
    use Moo; with 'AIStrategy';
    sub decide_action($self, $a, $t, $b) {
        return ItemCommand->new(actor => $a, battle => $b) if $a->hp <= $a->max_hp / 2;
        return AttackCommand->new(actor => $a, target => $t, battle => $b);
    }
}

# === Observer ===
package DamageEffect {
    use Moo; with 'Observer';
    sub update($self, $ev, $d) {
        return unless $ev eq 'damage';
        my $t = $d->{target};
        my $r = $t->hp / $t->max_hp;
        say "  ★★★ " . $t->name . "は倒れた！" if $r <= 0;
        say "  ★ " . $t->name . "は瀕死！" if $r > 0 && $r <= 0.25;
    }
}

package BattleReward {
    use Moo; with 'Observer';
    sub update($self, $ev, $d) {
        return unless $ev eq 'battle_end' && $d->{winner} eq 'player';
        say "\n*** " . (20 + int rand 40) . " EXP獲得！ ***";
    }
}

# === 戦闘状態 ===
package BattleContext {
    use Moo; with 'Subject';
    has player        => (is => 'ro', required => 1);
    has enemy         => (is => 'ro', required => 1);
    has current_state => (is => 'rw');
    has is_finished   => (is => 'rw', default => 0);
    
    sub change_state($self, $s) {
        $self->current_state->exit($self) if $self->current_state;
        $self->current_state($s);
        $s->enter($self);
    }
    sub update($self) { $self->current_state->execute($self) unless $self->is_finished }
    sub show_status($self) {
        my ($p, $e) = ($self->player, $self->enemy);
        say sprintf("\n%s HP:%d/%d MP:%d  vs  %s HP:%d/%d",
            $p->name, $p->hp, $p->max_hp, $p->mp, $e->name, $e->hp, $e->max_hp);
    }
}

package BattleStartState {
    use Moo; with 'BattleState';
    sub enter($self, $c) { say "=== 戦闘開始！ ===\n" . $c->enemy->name . "が現れた！" }
    sub execute($self, $c) { $c->show_status; $c->change_state(PlayerTurnState->new()) }
    sub exit($self, $c) {}
}

package PlayerTurnState {
    use Moo; with 'BattleState';
    sub enter($self, $c) { say "\n行動を選択: 1:攻撃 2:防御 3:魔法 4:アイテム" }
    sub execute($self, $c) {
        print "> ";
        chomp(my $ch = <STDIN>);
        my $cmd = $self->_cmd($ch, $c);
        unless ($cmd) { say "無効"; return }
        $cmd->execute();
        return $c->change_state(BattleEndState->new(winner => 'player')) unless $c->enemy->is_alive;
        $c->change_state(EnemyTurnState->new());
    }
    sub _cmd($self, $ch, $c) {
        my ($p, $e, $b) = ($c->player, $c->enemy, $c);
        return AttackCommand->new(actor => $p, target => $e, battle => $b) if $ch eq '1';
        return DefendCommand->new(actor => $p, battle => $b) if $ch eq '2';
        return MagicCommand->new(actor => $p, target => $e, battle => $b) if $ch eq '3';
        return ItemCommand->new(actor => $p, battle => $b) if $ch eq '4';
        undef;
    }
    sub exit($self, $c) {}
}

package EnemyTurnState {
    use Moo; with 'BattleState';
    sub enter($self, $c) { say "\n--- " . $c->enemy->name . "のターン ---" }
    sub execute($self, $c) {
        my $cmd = $c->enemy->ai_strategy->decide_action($c->enemy, $c->player, $c);
        $cmd->execute();
        return $c->change_state(BattleEndState->new(winner => 'enemy')) unless $c->player->is_alive;
        $c->show_status;
        $c->change_state(PlayerTurnState->new());
    }
    sub exit($self, $c) {}
}

package BattleEndState {
    use Moo; with 'BattleState';
    has winner => (is => 'ro', required => 1);
    sub enter($self, $c) { say "\n=== 戦闘終了！ ===" }
    sub execute($self, $c) {
        say $self->winner eq 'player' ? $c->enemy->name . "を倒した！" : $c->player->name . "は倒れた...";
        $c->notify('battle_end', { winner => $self->winner });
        $c->is_finished(1);
    }
    sub exit($self, $c) {}
}

# === メイン ===
my $hero = Character->new(name => '勇者', hp => 100, max_hp => 100, mp => 50, attack_power => 20);
my $orc = Character->new(name => 'オーク', hp => 80, max_hp => 80, attack_power => 15, ai_strategy => DefensiveAI->new());

my $battle = BattleContext->new(player => $hero, enemy => $orc);
$battle->attach(DamageEffect->new());
$battle->attach(BattleReward->new());

$battle->change_state(BattleStartState->new());
$battle->update() until $battle->is_finished;
```

## 今回のポイント

- STDINからプレイヤー入力を受け付けるREPLを実装
- 4つのパターンすべてが連携して動作する完成版
- ステータス表示、行動選択、AI応答、イベント通知が統合

次回（最終回）では、今回使用した4つのデザインパターンの組み合わせ方を振り返り、応用例を紹介します。

---

前回: {{< linkcard "https://www.nqou.net/2026/01/31/001905/" >}}

次回: {{< linkcard "https://www.nqou.net/2026/01/31/001939/" >}}
