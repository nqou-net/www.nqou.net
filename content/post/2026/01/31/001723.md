---
date: 2026-01-31T00:17:23+09:00
description: RPG戦闘エンジン第2回。攻撃だけでなく防御やアイテム使用など、行動の種類を増やします。Actionクラスを設計し、各行動を独立したクラスとして分離する方法を学びます。
draft: false
epoch: 1769786243
image: /public_images/2026/rpg-battle-engine-header.png
iso8601: 2026-01-31T00:17:23+09:00
series:
  - PerlとMooでテキストRPG戦闘エンジンを作ろう
tags:
  - perl
  - moo
  - class-design
  - rpg
title: '【第2回】行動の種類を増やしたい - PerlとMooでテキストRPG戦闘エンジンを作ろう'
---

前回は、プレイヤーと敵が交互に攻撃するシンプルな戦闘ループを作りました。しかし実際のRPGでは、攻撃以外にもさまざまな行動があります。

- 防御: 次のターン、受けるダメージを半減させる
- アイテム使用: ポーションでHPを回復する
- 魔法: MPを消費して強力な攻撃を放つ

今回は、これらの行動をどう実装するか考えていきましょう。

![行動をクラスとして分離するイメージ](/public_images/2026/rpg-battle-ep2-actions.png)

## 行動クラスを分離する

現在の`attack`メソッドは`Character`クラスの中に直接書かれています。新しい行動を追加するたびに`Character`クラスにメソッドを追加していくと、クラスが肥大化してしまいます。

そこで、行動を表す専用のクラスを作ることにします。まずは基本となる`Action`クラスを定義しましょう。

```perl
package Action;
use v5.36;
use Moo;

has actor => (
    is       => 'ro',
    required => 1,
);

sub execute($self, $target) {
    die "execute() must be implemented by subclass";
}
```

`actor`は行動を実行するキャラクター、`execute`は実際の行動を実行するメソッドです。`execute`は基底クラスでは実装せず、サブクラスで具体的な処理を定義します。

## 攻撃アクションを作る

`Action`を継承して攻撃アクションを作ります。

```perl
package AttackAction;
use v5.36;
use Moo;

extends 'Action';

sub execute($self, $target) {
    my $actor = $self->actor;
    my $damage = $actor->attack_power;
    my $new_hp = $target->hp - $damage;
    $target->hp($new_hp < 0 ? 0 : $new_hp);
    
    say $actor->name . "の攻撃！ " . $target->name . "に " . $damage . " のダメージ！";
}
```

前回`Character`クラスにあった`attack`メソッドの処理を、`AttackAction`クラスの`execute`メソッドに移動しました。

## 防御アクションを作る

次に防御アクションを作ります。防御すると、次に受けるダメージが半減します。この状態を表現するために、`Character`クラスに`is_defending`フラグを追加します。

また、回復量を安全に上限でクリップできるよう、`max_hp`も持たせておきます。

```perl
package Character;
use v5.36;
use Moo;

has name => (
    is       => 'ro',
    required => 1,
);

has hp => (
    is      => 'rw',
    default => 100,
);

has attack_power => (
    is      => 'ro',
    default => 10,
);

has max_hp => (
    is      => 'ro',
    default => 100,
);

has is_defending => (
    is      => 'rw',
    default => 0,
);

sub is_alive($self) {
    return $self->hp > 0;
}

sub take_damage($self, $damage) {
    my $actual_damage = $self->is_defending ? int($damage / 2) : $damage;
    my $new_hp = $self->hp - $actual_damage;
    $self->hp($new_hp < 0 ? 0 : $new_hp);
    $self->is_defending(0);  # 防御状態をリセット
    return $actual_damage;
}
```

`take_damage`メソッドを追加し、ダメージ計算を一箇所にまとめました。防御中の場合はダメージを半減し、ダメージを受けた後は防御状態をリセットします。

HPを回復するときの上限値として`max_hp`を使うことで、魔法の数字（ハードコードされた100）を避けています。

防御アクションは以下のようになります。

```perl
package DefendAction;
use v5.36;
use Moo;

extends 'Action';

sub execute($self, $target) {
    my $actor = $self->actor;
    $actor->is_defending(1);
    say $actor->name . "は防御の構えをとった！";
}
```

`DefendAction`の`execute`では、ターゲットではなく自分自身の防御フラグを立てます。

## アイテム使用アクションを作る

HPを回復するポーションを使うアクションも作ってみましょう。

```perl
package ItemAction;
use v5.36;
use Moo;

extends 'Action';

has item_name => (
    is      => 'ro',
    default => 'ポーション',
);

has heal_amount => (
    is      => 'ro',
    default => 30,
);

sub execute($self, $target) {
    my $actor = $self->actor;
    my $max_hp = 100;  # 最大HPを仮定
    my $new_hp = $actor->hp + $self->heal_amount;
    $actor->hp($new_hp > $max_hp ? $max_hp : $new_hp);
    
    say $actor->name . "は" . $self->item_name . "を使った！ HPが " . $self->heal_amount . " 回復！";
}
```

`ItemAction`には`item_name`と`heal_amount`属性を追加し、アイテムの種類と回復量を設定できるようにしました。

`max_hp`を参照するので、キャラクターごとにHP上限を変えてもコード変更は不要です。

## 攻撃アクションの修正

`AttackAction`も`take_damage`メソッドを使うように修正しましょう。

```perl
package AttackAction;
use v5.36;
use Moo;

extends 'Action';

sub execute($self, $target) {
    my $actor = $self->actor;
    my $damage = $actor->attack_power;
    my $actual = $target->take_damage($damage);
    
    my $msg = $actor->name . "の攻撃！ " . $target->name . "に " . $actual . " のダメージ！";
    $msg .= "（防御で軽減）" if $actual < $damage;
    say $msg;
}
```

防御によってダメージが軽減された場合、その旨を表示するようにしました。

## 行動を使って戦闘する

これらのアクションを使って戦闘を進めてみましょう。

```perl
# プレイヤーは攻撃
my $player_action = AttackAction->new(actor => $hero);
$player_action->execute($slime);

# 敵も攻撃
my $enemy_action = AttackAction->new(actor => $slime);
$enemy_action->execute($hero);
```

行動をオブジェクトとして扱うことで、どの行動を実行するかを柔軟に切り替えられるようになりました。

## 完成コード

```perl
#!/usr/bin/env perl
use v5.36;

package Character {
    use Moo;
    
    has name => (
        is       => 'ro',
        required => 1,
    );
    
    has hp => (
        is      => 'rw',
        default => 100,
    );
    
    has attack_power => (
        is      => 'ro',
        default => 10,
    );
    
    has is_defending => (
        is      => 'rw',
        default => 0,
    );
    
    sub is_alive($self) {
        return $self->hp > 0;
    }
    
    sub take_damage($self, $damage) {
        my $actual_damage = $self->is_defending ? int($damage / 2) : $damage;
        my $new_hp = $self->hp - $actual_damage;
        $self->hp($new_hp < 0 ? 0 : $new_hp);
        $self->is_defending(0);
        return $actual_damage;
    }
}

package Action {
    use Moo;
    
    has actor => (
        is       => 'ro',
        required => 1,
    );
    
    sub execute($self, $target) {
        die "execute() must be implemented by subclass";
    }
}

package AttackAction {
    use Moo;
    extends 'Action';
    
    sub execute($self, $target) {
        my $actor = $self->actor;
        my $damage = $actor->attack_power;
        my $actual = $target->take_damage($damage);
        
        my $msg = $actor->name . "の攻撃！ " . $target->name . "に " . $actual . " のダメージ！";
        $msg .= "（防御で軽減）" if $actual < $damage;
        say $msg;
    }
}

package DefendAction {
    use Moo;
    extends 'Action';
    
    sub execute($self, $target) {
        my $actor = $self->actor;
        $actor->is_defending(1);
        say $actor->name . "は防御の構えをとった！";
    }
}

package ItemAction {
    use Moo;
    extends 'Action';
    
    has item_name => (
        is      => 'ro',
        default => 'ポーション',
    );
    
    has heal_amount => (
        is      => 'ro',
        default => 30,
    );
    
    sub execute($self, $target) {
        my $actor = $self->actor;
        my $new_hp = $actor->hp + $self->heal_amount;
        $actor->hp($new_hp > $actor->max_hp ? $actor->max_hp : $new_hp);
        
        say $actor->name . "は" . $self->item_name . "を使った！ HPが " . $self->heal_amount . " 回復！";
    }
}

# メイン処理
my $hero = Character->new(
    name         => '勇者',
    hp           => 100,
    attack_power => 15,
);

my $slime = Character->new(
    name         => 'スライム',
    hp           => 50,
    attack_power => 10,
);

say "=== 戦闘デモ ===";
say "勇者 HP: " . $hero->hp . "  スライム HP: " . $slime->hp;
say "";

# ターン1: 勇者は攻撃、スライムは防御
AttackAction->new(actor => $hero)->execute($slime);
DefendAction->new(actor => $slime)->execute($slime);

say "";

# ターン2: 勇者は攻撃（スライムは防御中）、スライムはアイテム
AttackAction->new(actor => $hero)->execute($slime);
ItemAction->new(actor => $slime, heal_amount => 20)->execute($slime);

say "";
say "最終状態: 勇者 HP: " . $hero->hp . "  スライム HP: " . $slime->hp;
```

## 実行結果

```
=== 戦闘デモ ===
勇者 HP: 100  スライム HP: 50

勇者の攻撃！ スライムに 15 のダメージ！
スライムは防御の構えをとった！

勇者の攻撃！ スライムに 7 のダメージ！（防御で軽減）
スライムはポーションを使った！ HPが 20 回復！

最終状態: 勇者 HP: 100  スライム HP: 48
```

防御によってダメージが15から7に軽減されていること、アイテムでHPが回復していることが確認できます。

## 今回のポイント

- 行動を`Action`クラスとして分離した
- `AttackAction`、`DefendAction`、`ItemAction`を作成した
- `Character`にダメージ処理を集約する`take_damage`メソッドを追加した
- 防御状態を`is_defending`フラグで管理した

行動がクラスとして分離されたことで、新しい行動を追加しやすくなりました。しかし、現在の実装ではどの行動を実行するかをコードに直接書いています。

次回は、プレイヤーの入力に応じて行動を切り替える処理を追加してみましょう。そこで見えてくる問題点と、その解決策について考えていきます。

---

前回: {{< linkcard "https://www.nqou.net/2026/01/31/001706/" >}}

次回: {{< linkcard "https://www.nqou.net/2026/01/31/001740/" >}}
