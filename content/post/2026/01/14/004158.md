---
date: 2026-01-14T00:41:58+09:00
description: Mooを使って「次のパスワード候補」を生成するクラスを作成。複雑なループ構造をオブジェクトの中に隠蔽し、スッキリとしたコードを実現します。
draft: false
image: /images/post/2026/01/14/004158.png
iso8601: 2026-01-14T00:41:58+09:00
tags:
  - perl
  - iterator
  - moo
  - oop
  - brute-force-simulator
title: 組み合わせ生成機を作る - Mooでループをオブジェクトにする
---

前回は、可変長のパスワード探索において「再帰呼び出し」が必要になり、コードが複雑化する問題に直面しました。

今回は、その複雑さを「オブジェクト」の中に閉じ込め、使う側からは非常にシンプルに見えるようにリファクタリングします。ここで登場するのが「**Iterator（反復子）**」の概念です。

## 目標：`next`メソッドを持つオブジェクト

目指すのは、以下のように使えるクラス `BruteForceIterator` です。

```perl
my $iterator = BruteForceIterator->new(length => 4);

while (my $password = $iterator->next) {
    # ここで $password を使う（0000, 0001, ... 9999）
}
```

この `$iterator->next` を呼ぶたびに、新しいパスワード候補が1つ返ってきます。最後まで出し尽くしたら `undef` を返してループが終了します。

これなら、使う側は「どうやって組み合わせを作っているか（for文なのか再帰なのか）」を知る必要がありません。

## 実装：MooでIteratorを作る

では、`BruteForceIterator.pm` を実装してみましょう。
内部的には、現在の数値を覚えておき、`next` が呼ばれるたびに1つ増やして返す、という単純な仕組みで実現できます（数字のパスワードならではの簡略化です）。

```perl
package BruteForceIterator;
use Moo;
use experimental qw(signatures);

# パスワードの桁数
has length => (
    is       => 'ro',
    required => 1,
);

# 現在の状態（カウンター）
has _current => (
    is      => 'rw',
    default => 0,
);

# 最大値（上限）
has _max => (
    is      => 'lazy',
    builder => sub ($self) {
        return 10 ** $self->length; # 3桁なら1000
    },
);

# 次の値を返すメソッド
sub next ($self) {
    my $val = $self->_current;

    # 上限に達していたら undef を返して終了
    if ($val >= $self->_max) {
        return undef;
    }

    # カウンターを進める
    $self->_current($val + 1);

    # 指定された桁数になるように0埋めする (例: 1 -> "0001")
    return sprintf("%0*d", $self->length, $val);
}

1;
```

見てください。再帰も多重ループも使っていません。単に「今の数字」を覚えておいて、呼ばれるたびにインクリメントしているだけです。

## 使う側のコード（メインスクリプト）

これを使う `cracker_iterator.pl` は以下のようになります。

```perl
use v5.36;
use PasswordLock;
use BruteForceIterator;

my $target_length = 4;
my $lock = PasswordLock->new;

# Iteratorを生成
my $iterator = BruteForceIterator->new(length => $target_length);

say "クラッキングを開始します...";

# nextメソッドを使ってループ
while (defined(my $attempt = $iterator->next)) {
    if ($lock->unlock($attempt)) {
        say "解除成功！ パスワードは [ $attempt ] です！";
        exit;
    }
}

say "見つかりませんでした。";
```

非常にスッキリしました！
再帰ロジックの複雑さは消え去り、直感的な `while` ループになりました。

## Iteratorの利点：遅延評価（Lazy Evaluation）

このアプローチの最大の利点は、**「全ての組み合わせをメモリに展開しなくて良い」** という点です。

もし、8桁のパスワード（1億通り）を全て配列に入れてから処理しようとすると、巨大なメモリを消費します。しかし、このIterator方式なら、メモリ上には「現在のカウント（1つの整数）」しか保持していません。

`next` が呼ばれた瞬間に、必要な値を1つだけ計算して（作り出して）返しています。これを**遅延評価**と呼びます。無限に近いリストでも、これなら扱うことができます。

## 次回予告

今回は数字だけのパスワードだったので、単純なカウンターで実装できました。しかし、もし「英字」が含まれていたら？ 「辞書にある単語」を使いたかったら？

単純なインクリメントでは対応できません。

次回は、この `next` メソッドという共通インターフェースを守りながら、内部の実装を差し替えることで、**「辞書攻撃」** にも対応できる柔軟なツールへと進化させます。**ポリモーフィズム（多態性）** の威力を体験しましょう。

[前回記事: 4桁、5桁...ループが止まらない - 多重ループの絶望]({{< linkcard "/2026/01/14/004141/" >}})
