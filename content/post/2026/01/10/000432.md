---
date: 2026-01-10T00:04:32+09:00
description: 複数のStateクラスに共通ルールを設けたい。Moo::Roleのrequiresでインターフェースを定義し、統一的なAPI設計を実現します。
draft: false
epoch: 1767971072
image: /public_images/2026/state-pattern-series-image.jpg
iso8601: 2026-01-10T00:04:32+09:00
tags:
  - perl
  - moo
  - moo-role
  - interface
  - requires
title: '第4回-Moo::Roleで共通の約束を決めよう - Mooを使って自動販売機シミュレーターを作ってみよう'
---

[@nqounet](https://x.com/nqounet)です。

前回は、状態ごとにクラスを作ることで、if/elseの肥大化問題を解決しました。

{{< linkcard "/2026/01/10/000229/" >}}

しかし、まだ問題が残っています。すべての状態クラスが同じメソッド（`insert_coin`、`select_product`、`dispense`）を持つ必要がありますが、それを強制する仕組みがありません。

今回は、Moo::Roleを使って「共通の約束」を定義しましょう。

## 問題点を確認する

前回作った状態クラスを振り返ってみましょう。

WaitingStateもCoinInsertedStateも、同じ3つのメソッドを持っています。

- `insert_coin`
- `select_product`
- `dispense`

しかし、もし新しい状態クラスを作るときに、うっかりメソッドを1つ忘れてしまったらどうなるでしょうか？

実行時にエラーが発生してしまいます。これを事前に防ぐ仕組みが欲しいですね。

## Moo::Roleでインターフェースを定義する

Moo::Roleの`requires`を使うと、「このロールを使うクラスは、これらのメソッドを必ず実装してください」という約束を定義できます。

```perl
package VendingMachineState {
    use Moo::Role;

    requires 'insert_coin';
    requires 'select_product';
    requires 'dispense';
}
```

このロールは「自動販売機の状態として振る舞うなら、3つのメソッドを必ず持ってください」という約束です。

## 状態クラスにロールを適用する

各状態クラスで`with`を使ってロールを適用します。

```perl
#!/usr/bin/env perl
use v5.36;
use Moo;

package VendingMachineState {
    use Moo::Role;

    requires 'insert_coin';
    requires 'select_product';
    requires 'dispense';
}

package WaitingState {
    use Moo;
    use v5.36;

    with 'VendingMachineState';

    sub insert_coin ($self) {
        say "コインを受け付けました";
        return CoinInsertedState->new;
    }

    sub select_product ($self) {
        say "先にコインを入れてください";
        return $self;
    }

    sub dispense ($self) {
        say "払い出す商品がありません";
        return $self;
    }
}

package CoinInsertedState {
    use Moo;
    use v5.36;

    with 'VendingMachineState';

    sub insert_coin ($self) {
        say "すでにコインが入っています";
        return $self;
    }

    sub select_product ($self) {
        say "商品を選択しました";
        return WaitingState->new;
    }

    sub dispense ($self) {
        say "先に商品を選択してください";
        return $self;
    }
}

# 動作確認
say "=== VendingMachineStateロールのテスト ===";
say "";

my $state = WaitingState->new;

# ロールが適用されているか確認
if ($state->does('VendingMachineState')) {
    say "WaitingStateはVendingMachineStateロールを持っています";
}
say "";

say "[操作] コインを投入";
$state = $state->insert_coin;
say "現在の状態: " . ref($state);

if ($state->does('VendingMachineState')) {
    say "CoinInsertedStateもVendingMachineStateロールを持っています";
}
say "";

say "[操作] 商品を選択";
$state = $state->select_product;
say "現在の状態: " . ref($state);
```

## requiresの効果を確認する

もし、メソッドを実装し忘れたらどうなるでしょうか？

試しに、`dispense`メソッドを削除してみましょう。

```perl
package BrokenState {
    use Moo;
    use v5.36;

    with 'VendingMachineState';

    sub insert_coin ($self) {
        say "コインを受け付けました";
        return $self;
    }

    sub select_product ($self) {
        say "商品を選択しました";
        return $self;
    }

    # dispenseメソッドがない！
}
```

このコードを実行すると、以下のようなエラーが発生します。

```
Can't apply VendingMachineState to BrokenState - missing dispense
```

コンパイル時（正確には`with`の時点）でエラーになるため、うっかりミスを早期に発見できます。

## 今回のポイント

Moo::Roleの`requires`を使うことで、以下のメリットが得られます。

- すべての状態クラスが統一されたAPIを持つことを保証できる
- メソッドの実装漏れを早期に発見できる
- 新しい状態クラスを作るときの「チェックリスト」になる

## 今回の完成コード

```perl
#!/usr/bin/env perl
use v5.36;
use Moo;

package VendingMachineState {
    use Moo::Role;

    requires 'insert_coin';
    requires 'select_product';
    requires 'dispense';
}

package WaitingState {
    use Moo;
    use v5.36;

    with 'VendingMachineState';

    sub insert_coin ($self) {
        say "コインを受け付けました";
        return CoinInsertedState->new;
    }

    sub select_product ($self) {
        say "先にコインを入れてください";
        return $self;
    }

    sub dispense ($self) {
        say "払い出す商品がありません";
        return $self;
    }
}

package CoinInsertedState {
    use Moo;
    use v5.36;

    with 'VendingMachineState';

    sub insert_coin ($self) {
        say "すでにコインが入っています";
        return $self;
    }

    sub select_product ($self) {
        say "商品を選択しました";
        return WaitingState->new;
    }

    sub dispense ($self) {
        say "先に商品を選択してください";
        return $self;
    }
}

# 動作確認
say "=== VendingMachineStateロールのテスト ===";
say "";

my $state = WaitingState->new;

# ロールが適用されているか確認
if ($state->does('VendingMachineState')) {
    say "WaitingStateはVendingMachineStateロールを持っています";
}
say "";

say "[操作] コインを投入";
$state = $state->insert_coin;
say "現在の状態: " . ref($state);

if ($state->does('VendingMachineState')) {
    say "CoinInsertedStateもVendingMachineStateロールを持っています";
}
say "";

say "[操作] 商品を選択";
$state = $state->select_product;
say "現在の状態: " . ref($state);
```

## まとめ

- `VendingMachineState`ロールを作成し、必須メソッドを`requires`で定義しました
- 各状態クラスで`with 'VendingMachineState'`を宣言しました
- メソッドの実装漏れがあれば、`with`の時点でエラーになります
- `$object->does('RoleName')`でロールの適用を確認できます

次回「第5回-状態を管理するクラスを作ろう」では、状態を一元管理するContextクラスを作成します。お楽しみに！
