---
date: 2026-01-10T00:10:41+09:00
description: 間違ったオブジェクトが状態として設定されるバグを防ぎたい。does制約を使った型チェックで実行時エラーを未然に防ぐ方法を解説。
draft: false
epoch: 1767971441
image: /public_images/2026/state-pattern-series-image.jpg
iso8601: 2026-01-10T00:10:41+09:00
tags:
  - perl
  - moo
  - type-check
  - does-constraint
  - validation
title: '第7回-does制約で型チェックしよう - Mooを使って自動販売機シミュレーターを作ってみよう'
---

[@nqounet](https://x.com/nqounet)です。

前回は、状態クラスがContextへの参照を受け取り、自ら状態遷移を行う仕組みを実装しました。

{{< linkcard "https://www.nqou.net/2026/01/10/000838/" >}}

今回は、型チェックを追加して、間違ったオブジェクトが状態として設定されるバグを防ぎます。

## 現在の問題点

現在のVendingMachineクラスでは、`state`属性にどんなオブジェクトでも設定できてしまいます。

```perl
my $vm = VendingMachine->new;
$vm->set_state("これは文字列です");  # エラーにならない！
$vm->insert_coin;  # ここでエラーになる
```

このコードは`set_state`の時点ではエラーにならず、`insert_coin`を呼び出したときに初めてエラーになります。

問題が発覚するタイミングが遅いため、デバッグが難しくなります。

## isaで解決する

Mooでは、属性の検証手段として、`isa`を指定することができます。

指定できるのは、コードリファレンスで、仕組みとしては単純です。属性の値として指定されようとしている値が`@_`で渡されるので、その値が正しいかどうかを検証することができます。

`Type::Tiny`（実質的には`Types::Standard`）を使用する場合は、型を指定するように書けるのですが、Mooの本来のisaの仕組みは関数が実行されるだけです。

ですが、その仕組みを使うと、属性の型だけではなく、様々なバリデーションを行うことができます。

余談ですが、Mooseには`does`制約があり、これを使うと、「このロールを持つオブジェクトのみ受け付ける」という条件を設定できます。

```perl
    has state => (
        is      => 'rw',
        default => sub { WaitingState->new },
        isa    => sub {
            my $value = shift;
            die "state must do VendingMachineState role"
                unless $value->does('VendingMachineState');
        },
    );
```

`$obj->state($state)` のように実行した場合、`isa`のコードリファレンスには`$state`が第1引数として渡されます。

上記の例では、isaの中で`$state`を`$value`に代入して、メソッドの`does`を使用して、ロールを持っているかどうかを判定しています。

ここでは、実質的に正しいロール以外は例外を出せば良いという考え方で、`$value->does()`を直接呼んでいます。ですが、厳格に書く場合は、リファレンスかどうか、`does`が実行できるか、といった検証のための準備も必要です。

## 型エラーのデモ

isaを追加したコードで、間違ったオブジェクトを設定しようとするとどうなるか見てみましょう。

```perl
#!/usr/bin/env perl
use v5.36;
use Moo;

package VendingMachineState {
    use Moo::Role;

    requires 'insert_coin';
    requires 'select_product';
    requires 'dispense';
}

package WaitingState {
    use Moo;
    use v5.36;

    with 'VendingMachineState';

    sub insert_coin ($self, $context) {
        say "コインを受け付けました";
        $context->set_state(CoinInsertedState->new);
    }

    sub select_product ($self, $context) {
        say "先にコインを入れてください";
    }

    sub dispense ($self, $context) {
        say "払い出す商品がありません";
    }
}

# 他の状態クラスは省略

package VendingMachine {
    use Moo;
    use v5.36;

    has state => (
        is      => 'rw',
        default => sub { WaitingState->new },
        isa    => sub { # 型チェック追加
            my $value = shift;
            die "state must do VendingMachineState role"
                unless $value->does('VendingMachineState');
        },
    );

    has stock => (
        is      => 'rw',
        default => sub { 5 },
    );

    sub set_state ($self, $new_state) {
        $self->state($new_state);
    }
}

# 正しい使い方
my $vm = VendingMachine->new;
say "正常: 初期状態は " . ref($vm->state);

# 間違った使い方（エラーになる）
eval {
    $vm->set_state("文字列を渡してみる");
};
if ($@) {
    say "エラー発生: 文字列は状態として設定できません";
}
```

## 実行結果

```
正常: 初期状態は WaitingState
エラー発生: 文字列は状態として設定できません
```

`set_state`の時点でエラーが発生し、問題を早期に発見できます。

## isaのメリット

isaを使うことで、以下のメリットが得られます。

- 間違ったオブジェクトが設定された時点でエラーになる
- エラーメッセージが明確で、デバッグしやすい
- コードを読む人に「どんなオブジェクトが期待されているか」が伝わる
- ドキュメントとしての役割も果たす

## 完成コード

isaを追加した完成コードです。

```perl
#!/usr/bin/env perl
use v5.36;
use Moo;

package VendingMachineState {
    use Moo::Role;

    requires 'insert_coin';
    requires 'select_product';
    requires 'dispense';
}

package WaitingState {
    use Moo;
    use v5.36;

    with 'VendingMachineState';

    sub insert_coin ($self, $context) {
        say "コインを受け付けました";
        $context->set_state(CoinInsertedState->new);
    }

    sub select_product ($self, $context) {
        say "先にコインを入れてください";
    }

    sub dispense ($self, $context) {
        say "払い出す商品がありません";
    }
}

package CoinInsertedState {
    use Moo;
    use v5.36;

    with 'VendingMachineState';

    sub insert_coin ($self, $context) {
        say "すでにコインが入っています";
    }

    sub select_product ($self, $context) {
        if ($context->stock > 0) {
            say "商品を選択しました。払い出しを開始します";
            $context->set_state(DispensingState->new);
        }
        else {
            say "申し訳ありません。売り切れです";
            say "コインを返却します";
            $context->set_state(WaitingState->new);
        }
    }

    sub dispense ($self, $context) {
        say "先に商品を選択してください";
    }
}

package DispensingState {
    use Moo;
    use v5.36;

    with 'VendingMachineState';

    sub insert_coin ($self, $context) {
        say "払い出し中です。お待ちください";
    }

    sub select_product ($self, $context) {
        say "払い出し中です。お待ちください";
    }

    sub dispense ($self, $context) {
        say "商品を払い出しました";
        $context->stock($context->stock - 1);
        say "残り在庫: " . $context->stock . "個";
        $context->set_state(WaitingState->new);
    }
}

package VendingMachine {
    use Moo;
    use v5.36;

    has state => (
        is      => 'rw',
        default => sub { WaitingState->new },
        isa    => sub { # 型チェック追加
            my $value = shift;
            die "state must do VendingMachineState role"
                unless $value->does('VendingMachineState');
        },
    );

    has stock => (
        is      => 'rw',
        default => sub { 5 },
    );

    sub set_state ($self, $new_state) {
        $self->state($new_state);
    }

    sub insert_coin ($self) {
        $self->state->insert_coin($self);
    }

    sub select_product ($self) {
        $self->state->select_product($self);
    }

    sub dispense ($self) {
        $self->state->dispense($self);
    }

    sub current_state_name ($self) {
        return ref($self->state);
    }
}

# 動作確認
say "=== 型チェックのデモ ===";
say "";

my $vm = VendingMachine->new;
say "正常な状態オブジェクト: " . $vm->current_state_name;
say "";

say "[操作] コインを投入";
$vm->insert_coin;
say "現在の状態: " . $vm->current_state_name;
say "";

# 型エラーのテスト
say "=== 型エラーのテスト ===";
eval {
    $vm->set_state("無効な値");
};
if ($@) {
    say "エラー: 不正な値は状態として設定できません";
}
```

## 今回のポイント

does制約を追加することで、型安全性が向上しました。

- `has state`に`does => 'VendingMachineState'`を追加
- `VendingMachineState`ロールを持たないオブジェクトは拒否される
- 間違ったオブジェクトが設定された時点でエラーになる
- デバッグがしやすくなる

## まとめ

- `does`制約を使って、state属性に設定できるオブジェクトを制限しました
- `VendingMachineState`ロールを持つオブジェクトのみ受け付けます
- 間違ったオブジェクトを設定しようとすると、その時点でエラーになります
- 型チェックにより、バグの早期発見が可能になりました

次回「第8回-売り切れ状態を追加しよう（OCP実践）」では、新しい状態を追加して、既存コードを変更せずに機能拡張できることを確認します。お楽しみに！
