---
date: 2026-01-18T06:13:57+09:00
description: IntrusionHubにdoes制約を導入し、IntrusionObserverロールを実装していないオブジェクトの登録を拒否します。型制約による堅牢な設計を学びましょう。
draft: false
epoch: 1737155637
image: /public_images/2026/honeypot-intrusion-radar-series-image.jpg
iso8601: 2026-01-18T06:13:57+09:00
tags:
  - perl
  - moo
  - type-constraint
  - validation
  - honeypot-intrusion-radar
title: 第7回-偽物Observerを排除 - Perlでハニーポット侵入レーダーを作ろう
---

[@nqounet](https://x.com/nqounet)です。

[前回](/2026/01/18/061340/)はObserverを動的に登録・解除する機能を実装しました。深夜だけアラートをONにする、といった柔軟な運用が可能になりましたね。

でも、今のIntrusionHubには危険な穴があります。

## 問題: 何でも登録できてしまう

現在の`attach`メソッドを見てみましょう。

```perl
sub attach ($self, $observer) {
    push $self->observers->@*, $observer;
}
```

引数の`$observer`に対して、何のチェックもしていません。つまり、`IntrusionObserver`ロールを実装していないオブジェクトでも登録できてしまいます。

```perl
# こんな偽物でも登録できてしまう
package FakeObserver;
use Moo;

# updateメソッドを持っていない！

package main;

my $fake = FakeObserver->new;
$hub->attach($fake);  # エラーにならない...

$hub->notify($event);  # ←ここで爆発
```

`notify`で全Observerの`update`を呼び出すときに初めてエラーになります。これでは遅い。登録時点で弾きたいのです。

## does制約で型チェック

Mooには`does`という型制約があります。これは「指定したRoleを実装しているか」をチェックします。

```perl
#!/usr/bin/env perl
# 言語: perl
# バージョン: 5.36以上
# 依存: Moo（cpanmでインストール）

use v5.36;

package IntrusionEvent;
use Moo;

has timestamp => (
    is       => 'ro',
    required => 1,
);

has source_ip => (
    is       => 'ro',
    required => 1,
);

has attack_type => (
    is       => 'ro',
    required => 1,
);

package IntrusionObserver;
use Moo::Role;

requires 'update';

package RadarLogObserver;
use Moo;
with 'IntrusionObserver';

sub update ($self, $event) {
    say "[ログ] " . $event->attack_type . " from " . $event->source_ip;
}

package FakeObserver;
use Moo;
# updateメソッドを持たない偽物

package IntrusionHub;
use Moo;

has observers => (
    is      => 'ro',
    default => sub { [] },
);

sub attach ($self, $observer) {
    # does制約でチェック
    unless ($observer->does('IntrusionObserver')) {
        die "Error: IntrusionObserverロールを実装していないオブジェクトは登録できません";
    }
    push $self->observers->@*, $observer;
    say "[司令塔] Observerを登録しました: " . ref($observer);
}

sub detach ($self, $observer) {
    $self->observers->@* = grep { $_ != $observer } $self->observers->@*;
}

sub notify ($self, $event) {
    for my $observer ($self->observers->@*) {
        $observer->update($event);
    }
}

package main;

my $hub = IntrusionHub->new;

# 正規のObserver
my $log_observer = RadarLogObserver->new;
$hub->attach($log_observer);  # OK

# 偽物を登録しようとすると...
my $fake = FakeObserver->new;
eval { $hub->attach($fake) };  # エラー！
if ($@) {
    say "登録拒否: $@";
}
```

実行結果はこうなります。

```
[司令塔] Observerを登録しました: RadarLogObserver
登録拒否: Error: IntrusionObserverロールを実装していないオブジェクトは登録できません at ...
```

## doesメソッドの仕組み

Mooでは、クラスが`with`でRoleを取り込むと、そのクラスのインスタンスは`does`メソッドで確認できるようになります。

```perl
$log_observer->does('IntrusionObserver');  # true
$fake->does('IntrusionObserver');          # false
```

これを利用して、`attach`の入り口で不正なオブジェクトを排除しています。

## 早期発見の価値

型チェックを登録時点で行うことの価値は大きいです。

*チェックなしの場合*

1. `attach`で偽物を登録（エラーなし）
2. しばらく運用...
3. `notify`で`update`を呼び出し
4. `Can't locate object method "update"`でクラッシュ

*チェックありの場合*

1. `attach`で偽物を登録しようとする
2. 即座にエラー
3. 問題の原因が明確

バグの発見が早ければ早いほど、修正コストは下がります。

## 今回のまとめ

今回はIntrusionHubに型チェックを導入し、偽物Observerの登録を防ぎました。

- `does`メソッドでRoleの実装を確認
- 登録時点で不正なオブジェクトを排除
- 問題の早期発見で保守性向上

これで司令塔の堅牢性が向上しました。

## 次回予告

次回は「新しい脅威判定を追加しても既存コードを変更しない」という話です。開放閉鎖の原則（OCP）を実践し、RiskLevelObserverを追加します。

拡張に開き、修正に閉じる設計の真価をご覧ください。
