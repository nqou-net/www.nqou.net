---
date: 2026-01-18T06:13:40+09:00
description: 深夜帯だけアラートを有効にするなど、Observerを動的に登録・解除する機能を実装します。attach/detachを活用したランタイム制御で柔軟な運用を実現しましょう。
draft: false
epoch: 1737155620
image: /public_images/2026/honeypot-intrusion-radar-series-image.jpg
iso8601: 2026-01-18T06:13:40+09:00
tags:
  - perl
  - moo
  - dynamic-registration
  - attach-detach
  - honeypot-intrusion-radar
title: 第6回-監視ON/OFFを切り替える - Perlでハニーポット侵入レーダーを作ろう
---

[@nqounet](https://x.com/nqounet)です。

[前回](/2026/01/18/061323/)は司令塔（IntrusionHub）を作成し、Observerを一元管理できるようにしました。`attach`で登録、`detach`で解除、`notify`で一斉通知という構造です。

今回は「深夜帯だけアラートを有効にしたい」という運用要件に応えます。`detach`の出番です。

## 運用シナリオ

ハニーポットの運用では、こんな要望が出てきます。

- 日中はログとスコア計算だけでいい
- 深夜（侵入が多い時間帯）はアラート通知も欲しい
- 状況に応じて通知先を切り替えたい

攻撃者は夜行性なのでしょうか？深夜帯のほうが侵入試行が増える傾向にあります（まあ、どこかのタイムゾーンでは昼間ですが）。

これを実現するには、Observerを**動的に登録・解除**できる必要があります。

## AlertObserverを追加する

まず、アラート通知を担当するObserverを作りましょう。

```perl
#!/usr/bin/env perl
# 言語: perl
# バージョン: 5.36以上
# 依存: Moo（cpanmでインストール）

use v5.36;

package IntrusionEvent;
use Moo;

has timestamp => (
    is       => 'ro',
    required => 1,
);

has source_ip => (
    is       => 'ro',
    required => 1,
);

has attack_type => (
    is       => 'ro',
    required => 1,
);

package IntrusionObserver;
use Moo::Role;

requires 'update';

package RadarLogObserver;
use Moo;
with 'IntrusionObserver';

sub update ($self, $event) {
    say "[ログ] " . $event->timestamp . " / " . $event->source_ip . " / " . $event->attack_type;
}

package ThreatScoreObserver;
use Moo;
with 'IntrusionObserver';

my %threat_scores = (
    'SSH Brute Force'       => 80,
    'Port Scan'             => 30,
    'SQL Injection Attempt' => 90,
);

has total_score => (
    is      => 'rw',
    default => 0,
);

sub update ($self, $event) {
    my $score = $threat_scores{$event->attack_type} // 50;
    $self->total_score($self->total_score + $score);
    say "[スコア] 累計: " . $self->total_score;
}

# アラート担当（新規追加）
package AlertObserver;
use Moo;
with 'IntrusionObserver';

sub update ($self, $event) {
    say "!!! [警報] 侵入検知: " . $event->attack_type . " from " . $event->source_ip . " !!!";
}

package IntrusionHub;
use Moo;

has observers => (
    is      => 'ro',
    default => sub { [] },
);

sub attach ($self, $observer) {
    push $self->observers->@*, $observer;
}

sub detach ($self, $observer) {
    $self->observers->@* = grep { $_ != $observer } $self->observers->@*;
}

sub notify ($self, $event) {
    for my $observer ($self->observers->@*) {
        $observer->update($event);
    }
}

package main;

my $hub = IntrusionHub->new;

# 常時稼働のObserver
my $log_observer   = RadarLogObserver->new;
my $score_observer = ThreatScoreObserver->new;
$hub->attach($log_observer);
$hub->attach($score_observer);

# 深夜帯専用のObserver
my $alert_observer = AlertObserver->new;

# イベントを用意
my @events = (
    IntrusionEvent->new(
        timestamp   => '2026-01-18T14:00:00+09:00',
        source_ip   => '192.168.1.100',
        attack_type => 'Port Scan',
    ),
    IntrusionEvent->new(
        timestamp   => '2026-01-18T02:30:00+09:00',
        source_ip   => '10.0.0.55',
        attack_type => 'SSH Brute Force',
    ),
    IntrusionEvent->new(
        timestamp   => '2026-01-18T03:15:00+09:00',
        source_ip   => '172.16.0.22',
        attack_type => 'SQL Injection Attempt',
    ),
);

say "=== 日中モード ===";
$hub->notify($events[0]);

say "";
say "=== 深夜モード（アラートON）===";
$hub->attach($alert_observer);  # 深夜になったのでアラートを有効化
$hub->notify($events[1]);

say "";
say "=== 引き続き深夜モード ===";
$hub->notify($events[2]);

say "";
say "=== 朝になったのでアラートOFF ===";
$hub->detach($alert_observer);  # 朝になったのでアラートを無効化
$hub->notify($events[0]);  # 再度同じイベントで確認
```

実行結果はこうなります。

```
=== 日中モード ===
[ログ] 2026-01-18T14:00:00+09:00 / 192.168.1.100 / Port Scan
[スコア] 累計: 30

=== 深夜モード（アラートON）===
[ログ] 2026-01-18T02:30:00+09:00 / 10.0.0.55 / SSH Brute Force
[スコア] 累計: 110
!!! [警報] 侵入検知: SSH Brute Force from 10.0.0.55 !!!

=== 引き続き深夜モード ===
[ログ] 2026-01-18T03:15:00+09:00 / 172.16.0.22 / SQL Injection Attempt
[スコア] 累計: 200
!!! [警報] 侵入検知: SQL Injection Attempt from 172.16.0.22 !!!

=== 朝になったのでアラートOFF ===
[ログ] 2026-01-18T14:00:00+09:00 / 192.168.1.100 / Port Scan
[スコア] 累計: 230
```

## 動的登録・解除の威力

注目すべきは、コードの変更なしに通知先を切り替えられる点です。

```perl
$hub->attach($alert_observer);  # アラートを追加
# ...しばらく運用...
$hub->detach($alert_observer);  # アラートを解除
```

既存のコード（`RadarLogObserver`や`ThreatScoreObserver`）には一切手を加えていません。これが**開放閉鎖の原則（OCP）**の効果です。

## 現実的な使い方

実際の運用では、時刻判定を組み合わせることになるでしょう。

```perl
# 疑似コード
my $hour = (localtime)[2];
if ($hour >= 22 || $hour < 6) {
    $hub->attach($alert_observer);  # 深夜帯
} else {
    $hub->detach($alert_observer);  # 日中
}
```

外部の条件（時刻、負荷状況、設定ファイルなど）に応じて、柔軟に通知先を制御できます。

## 今回のまとめ

今回はObserverの動的登録・解除を実装しました。

- `AlertObserver`を新規作成（アラート通知担当）
- `attach`で深夜モードに切り替え
- `detach`で日中モードに切り替え
- 既存コードへの変更なしで機能追加

ランタイムでの柔軟な制御が可能になりました。

## 次回予告

次回は「偽物のObserverを排除する」話です。現在の`attach`は何でも受け入れてしまいますが、`IntrusionObserver`ロールを実装していないものを弾けるようにしましょう。

Mooの型制約機能を使った堅牢化です。
