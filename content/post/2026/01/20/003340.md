---
categories:
  - Perl
  - プログラミング
date: 2026-01-20T00:33:40+09:00
description: PerlとMooでMarkdown目次生成器を作る第7回。同じツリー構造からMarkdown、HTML、JSON形式で出力。Compositeパターンの統一インターフェースの威力を体感します。
draft: false
epoch: 1768836820
image: /public_images/2026/composite-markdown-toc-series-image.jpg
iso8601: 2026-01-20T00:33:40+09:00
series: 'PerlとMooで学ぶComposite - Markdown目次生成ツリー構造'
tags:
  - perl
  - moo
  - composite-pattern
  - html
  - json
title: '第7回-HTML/JSON形式で目次を出力しよう - PerlとMooで学ぶComposite'
---

## 前回の振り返り

前回は、`TOCParser`クラスを実装し、見出しの配列からツリー構造を自動構築できるようになりました。現時点では、Markdown形式（インデント付きリスト）でのみ出力しています。

{{< linkcard url="https://www.nqou.net/2026/01/20/003323/" title="前回" >}}

今回は、同じツリー構造からHTML形式やJSON形式でも出力できるようにします。

## 今回のゴール

ツリー構造を引数で指定されたフォーマット（markdown、html、json）で出力する機能を実装します。

## 設計アプローチ：renderメソッドの拡張

現在の`SectionHeading`と`LeafHeading`の`render`メソッドは、Markdown形式固定です。これをformat引数付きに拡張します。

## SectionHeadingクラスの改良

```perl
package SectionHeading;
use v5.36;
use Moo;
use JSON::PP;

with 'Heading';

has 'level' => (
    is       => 'ro',
    required => 1,
);

has 'text' => (
    is       => 'ro',
    required => 1,
);

has 'children' => (
    is      => 'ro',
    default => sub { [] },
);

sub add_child ($self, $child) {
    push $self->children->@*, $child;
    return $self;
}

sub render ($self, $indent = 0, $format = 'markdown') {
    if ($format eq 'markdown') {
        return $self->_render_markdown($indent);
    } elsif ($format eq 'html') {
        return $self->_render_html($indent);
    } elsif ($format eq 'json') {
        return $self->_to_hash;
    }
    die "Unknown format: $format";
}

sub _render_markdown ($self, $indent) {
    my $spaces = '  ' x $indent;
    my @lines = ($spaces . '- ' . $self->text);
    
    for my $child ($self->children->@*) {
        push @lines, $child->render($indent + 1, 'markdown');
    }
    
    return join("\n", @lines);
}

sub _render_html ($self, $indent) {
    my $spaces = '  ' x $indent;
    my @lines;
    
    push @lines, "$spaces<li>" . $self->text;
    
    if ($self->children->@*) {
        push @lines, "$spaces  <ul>";
        for my $child ($self->children->@*) {
            push @lines, $child->render($indent + 2, 'html');
        }
        push @lines, "$spaces  </ul>";
    }
    
    push @lines, "$spaces</li>";
    
    return join("\n", @lines);
}

sub _to_hash ($self) {
    return {
        level    => $self->level,
        text     => $self->text,
        children => [map { $_->render(0, 'json') } $self->children->@*],
    };
}

1;
```

### コードの解説

#### フォーマット分岐

```perl
sub render ($self, $indent = 0, $format = 'markdown') {
    if ($format eq 'markdown') {
        return $self->_render_markdown($indent);
    } elsif ($format eq 'html') {
        return $self->_render_html($indent);
    } elsif ($format eq 'json') {
        return $self->_to_hash;
    }
    die "Unknown format: $format";
}
```

`format`引数でどの形式で出力するかを切り替えます。

#### HTML形式

```perl
sub _render_html ($self, $indent) {
    my $spaces = '  ' x $indent;
    my @lines;
    
    push @lines, "$spaces<li>" . $self->text;
    
    if ($self->children->@*) {
        push @lines, "$spaces  <ul>";
        for my $child ($self->children->@*) {
            push @lines, $child->render($indent + 2, 'html');
        }
        push @lines, "$spaces  </ul>";
    }
    
    push @lines, "$spaces</li>";
    
    return join("\n", @lines);
}
```

子要素がある場合のみ`<ul>`を入れ子にします。再帰的に`render`を呼び出すことで、深い階層も正しく処理されます。

#### JSON形式（ハッシュに変換）

```perl
sub _to_hash ($self) {
    return {
        level    => $self->level,
        text     => $self->text,
        children => [map { $_->render(0, 'json') } $self->children->@*],
    };
}
```

ハッシュリファレンスを返します。最終的に`JSON::PP`でJSON文字列に変換します。

## LeafHeadingクラスの改良

```perl
package LeafHeading;
use v5.36;
use Moo;

with 'Heading';

has 'level' => (
    is       => 'ro',
    required => 1,
);

has 'text' => (
    is       => 'ro',
    required => 1,
);

sub render ($self, $indent = 0, $format = 'markdown') {
    if ($format eq 'markdown') {
        return $self->_render_markdown($indent);
    } elsif ($format eq 'html') {
        return $self->_render_html($indent);
    } elsif ($format eq 'json') {
        return $self->_to_hash;
    }
    die "Unknown format: $format";
}

sub _render_markdown ($self, $indent) {
    my $spaces = '  ' x $indent;
    return $spaces . '- ' . $self->text;
}

sub _render_html ($self, $indent) {
    my $spaces = '  ' x $indent;
    return "$spaces<li>" . $self->text . "</li>";
}

sub _to_hash ($self) {
    return {
        level => $self->level,
        text  => $self->text,
    };
}

1;
```

`LeafHeading`には子要素がないため、よりシンプルな実装になります。

## TOCParserクラスの改良

```perl
package TOCParser;
use v5.36;
use Moo;
use JSON::PP;
use SectionHeading;
use LeafHeading;

has 'headings' => (
    is       => 'ro',
    required => 1,
);

has 'root' => (
    is      => 'lazy',
    builder => '_build_root',
);

sub _build_root ($self) {
    my $root = SectionHeading->new(
        level => 0,
        text  => 'ROOT',
    );
    
    my @stack = ($root);
    
    for my $h ($self->headings->@*) {
        my $level = $h->{level};
        my $text  = $h->{text};
        
        while (@stack > 1 && $stack[-1]->level >= $level) {
            pop @stack;
        }
        
        my $parent = $stack[-1];
        
        my $new_heading = SectionHeading->new(
            level => $level,
            text  => $text,
        );
        
        $parent->add_child($new_heading);
        push @stack, $new_heading;
    }
    
    return $root;
}

sub render ($self, $format = 'markdown') {
    if ($format eq 'json') {
        my @data = map { $_->render(0, 'json') } $self->root->children->@*;
        return JSON::PP->new->pretty->encode(\@data);
    }
    
    my @lines;
    
    if ($format eq 'html') {
        push @lines, '<ul>';
    }
    
    for my $child ($self->root->children->@*) {
        push @lines, $child->render($format eq 'html' ? 1 : 0, $format);
    }
    
    if ($format eq 'html') {
        push @lines, '</ul>';
    }
    
    return join("\n", @lines);
}

1;
```

## 使用例

```perl
#!/usr/bin/env perl
use v5.36;
use lib '.';
use MarkdownReader;
use HeadingExtractor;
use TOCParser;

my $reader = MarkdownReader->new(
    filepath => 'sample.md',
);

my $extractor = HeadingExtractor->new(
    lines => $reader->lines,
);

my $parser = TOCParser->new(
    headings => $extractor->headings,
);

say "=== Markdown形式 ===";
say $parser->render('markdown');
say "";

say "=== HTML形式 ===";
say $parser->render('html');
say "";

say "=== JSON形式 ===";
say $parser->render('json');
```

### 実行結果

Markdown形式：

```
=== Markdown形式 ===
- はじめに
  - 第1章
    - セクション1.1
  - 第2章
```

HTML形式：

```
=== HTML形式 ===
<ul>
  <li>はじめに
    <ul>
      <li>第1章
        <ul>
          <li>セクション1.1</li>
        </ul>
      </li>
      <li>第2章</li>
    </ul>
  </li>
</ul>
```

JSON形式：

```
=== JSON形式 ===
[
   {
      "children" : [
         {
            "children" : [
               {
                  "children" : [],
                  "level" : 3,
                  "text" : "セクション1.1"
               }
            ],
            "level" : 2,
            "text" : "第1章"
         },
         {
            "children" : [],
            "level" : 2,
            "text" : "第2章"
         }
      ],
      "level" : 1,
      "text" : "はじめに"
   }
]
```

## セキュリティ上の注意

本シリーズで生成したHTML出力をWebページに埋め込む場合、XSS（クロスサイトスクリプティング）対策が必要です。

ユーザー入力を直接HTML内に埋め込む場合は、必ずHTMLエスケープ処理を行ってください。

```perl
use HTML::Entities;
my $escaped = encode_entities($text);
```

## 関連：Strategyパターンとの違い

複数フォーマット出力は、Strategyパターンでも実現可能です：

- [Strategyパターン（データエクスポーター）](/2026/01/09/005530/) - アルゴリズムの切り替え

違いは、Compositeはツリー構造の統一的扱いが主、Strategyはアルゴリズム切り替えが主です。

## まとめ

今回は、同じツリー構造から複数フォーマット（Markdown、HTML、JSON）で出力する機能を実装しました。

学んだこと：

- `render`メソッドへのフォーマット引数追加
- 再帰的なHTML生成（入れ子の`<ul><li>`）
- `JSON::PP`によるPerlデータ構造のJSON変換
- Compositeパターンの「統一インターフェース」の威力

次回は、見出しテキストからアンカーID（`#introduction`等）を自動生成し、リンク付きの目次を実現します。また、開放閉鎖原則（OCP）を実践し、シリーズを完成させます。

{{< linkcard url="https://www.nqou.net/2026/01/20/003323/" title="前回" >}}
{{< linkcard url="https://www.nqou.net/2026/01/20/003357/" title="次回" >}}
