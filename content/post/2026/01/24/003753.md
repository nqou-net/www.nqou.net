---
categories:
  - perl
date: 2026-01-24T00:37:53+09:00
description: 同じ種類の弾は1つのオブジェクトを共有しよう！BulletFactoryでオブジェクトプールを管理し、「1000発の弾を5オブジェクトで」を実現します。
draft: false
epoch: 1769182673
image: /public_images/2026/flyweight-series-header.png
iso8601: 2026-01-24T00:37:53+09:00
series:
  - PerlとMooで弾幕シューティングを作ってみよう
series_order: 3
tags:
  - perl
  - moo
  - factory
  - cache
title: 【第3回】BulletFactoryで弾を使い回そう
---

前回、弾の「種類」と「位置」を分離することを学びました。でも、弾の種類を毎回手動で作成するのは面倒ですし、同じ種類の弾を間違えて2回 `new` してしまうかもしれません。

今回は、`BulletFactory` クラスを作って、この問題を解決しましょう！

![BulletFactoryによるオブジェクトプール](/public_images/2026/flyweight-ep3-factory.png)

{{< linkcard "https://www.nqou.net/2026/01/24/003736/" >}}

## 前回の振り返り

前回達成したこと：

- `BulletType` クラスで「内部状態」（形状、色、サイズ）を管理
- 位置情報（外部状態）は弾ごとにハッシュで管理
- メモリ使用量を約60%削減できた

残っている問題：

```perl
# 毎回手動で種類を管理している
my $red_circle = BulletType->new(
    shape => 'circle', color => 'red', size => 8, char => '●',
);

# 間違えて同じ種類を2回作ってしまうかも？
my $red_circle2 = BulletType->new(
    shape => 'circle', color => 'red', size => 8, char => '●',
);
# $red_circle と $red_circle2 は別オブジェクト！（メモリの無駄）
```

## BulletFactoryの役割

`BulletFactory` クラスを作り、以下の役割を持たせます：

1. 弾の種類を一元管理：「赤い丸」「青い星」などの種類を管理
2. 同じ種類は同じオブジェクトを返す：キャッシュ機構で重複を防ぐ
3. 種類の取得を簡単にする：キー（例：`red_circle`）で取得できる

## キャッシュ機構を実装する

Perlには、「なければ作って返す」を簡潔に書ける `//=` 演算子があります：

```perl
my %cache;

# キャッシュになければ新規作成、あればキャッシュから返す
$cache{$key} //= create_something($key);
```

この演算子を使って、`BulletFactory` を実装しましょう：

```perl
#!/usr/bin/env perl
use v5.36;

package BulletType {
    use Moo;

    has shape => (is => 'ro', required => 1);
    has color => (is => 'ro', required => 1);
    has size  => (is => 'ro', required => 1);
    has char  => (is => 'ro', required => 1);

    sub render($self, $x, $y) {
        my $char = $self->char;
        say "$char at ($x, $y)";
    }
}

package BulletFactory {
    use Moo;

    # 内部キャッシュ（先頭の _ は「外から触らないで」の慣習）
    has _cache => (
        is      => 'ro',
        default => sub { {} },
    );

    # 弾の種類定義（キー → 属性のマッピング）
    has _definitions => (
        is      => 'ro',
        default => sub {
            {
                red_circle   => { shape => 'circle', color => 'red',    size => 8,  char => '●' },
                blue_star    => { shape => 'star',   color => 'blue',   size => 12, char => '★' },
                green_laser  => { shape => 'laser',  color => 'green',  size => 4,  char => '|' },
                yellow_arrow => { shape => 'arrow',  color => 'yellow', size => 6,  char => '→' },
                purple_wave  => { shape => 'wave',   color => 'purple', size => 10, char => '〜' },
            }
        },
    );

    sub get($self, $type_key) {
        my $cache = $self->_cache;
        my $defs  = $self->_definitions;

        # キャッシュになければ新規作成
        $cache->{$type_key} //= do {
            my $def = $defs->{$type_key}
                or die "Unknown bullet type: $type_key";
            BulletType->new(%$def);
        };

        return $cache->{$type_key};
    }

    sub cache_stats($self) {
        my $cache = $self->_cache;
        my @keys = keys %$cache;
        return {
            count => scalar(@keys),
            types => \@keys,
        };
    }
}

# Factoryを作成
my $factory = BulletFactory->new;

# 同じ種類を何度取得しても、同じオブジェクトが返る
my $bullet1 = $factory->get('red_circle');
my $bullet2 = $factory->get('red_circle');
my $bullet3 = $factory->get('blue_star');

say "bullet1とbullet2は同じオブジェクト？";
say $bullet1 == $bullet2 ? "  → はい！同じオブジェクトです" : "  → いいえ、別オブジェクトです";

say "";
say "キャッシュの状態:";
my $stats = $factory->cache_stats;
say "  キャッシュ数: " . $stats->{count};
say "  キャッシュ内容: " . join(", ", @{$stats->{types}});
```

実行結果：

```
bullet1とbullet2は同じオブジェクト？
  → はい！同じオブジェクトです

キャッシュの状態:
  キャッシュ数: 2
  キャッシュ内容: red_circle, blue_star
```

`red_circle` を2回取得しても、作られる `BulletType` オブジェクトは1つだけです！

## 1000発の弾を5オブジェクトで管理

いよいよ、弾幕シューティングらしいコードを書いてみましょう：

```perl
#!/usr/bin/env perl
use v5.36;
use Devel::Size qw(total_size);

package BulletType {
    use Moo;

    has shape => (is => 'ro', required => 1);
    has color => (is => 'ro', required => 1);
    has size  => (is => 'ro', required => 1);
    has char  => (is => 'ro', required => 1);

    sub render($self, $x, $y) {
        my $char = $self->char;
        print "$char";
    }
}

package BulletFactory {
    use Moo;

    has _cache => (is => 'ro', default => sub { {} });

    has _definitions => (
        is      => 'ro',
        default => sub {
            {
                red_circle   => { shape => 'circle', color => 'red',    size => 8,  char => '●' },
                blue_star    => { shape => 'star',   color => 'blue',   size => 12, char => '★' },
                green_laser  => { shape => 'laser',  color => 'green',  size => 4,  char => '|' },
                yellow_arrow => { shape => 'arrow',  color => 'yellow', size => 6,  char => '→' },
                purple_wave  => { shape => 'wave',   color => 'purple', size => 10, char => '〜' },
            }
        },
    );

    sub get($self, $type_key) {
        my $cache = $self->_cache;
        my $defs  = $self->_definitions;

        $cache->{$type_key} //= do {
            my $def = $defs->{$type_key}
                or die "Unknown bullet type: $type_key";
            BulletType->new(%$def);
        };

        return $cache->{$type_key};
    }

    sub cache_count($self) {
        return scalar(keys %{$self->_cache});
    }
}

# 弾幕を生成
my $factory = BulletFactory->new;
my @type_keys = qw(red_circle blue_star green_laser yellow_arrow purple_wave);

my @bullets;
for my $i (0 .. 999) {
    # 5種類の弾をランダムに配置
    my $type_key = $type_keys[$i % 5];
    push @bullets, {
        type => $factory->get($type_key),
        x    => $i % 50,
        y    => int($i / 50),
        vx   => 0,
        vy   => 1,
    };
}

say "=== 弾幕の統計 ===";
say "弾の総数: " . scalar(@bullets);
say "BulletTypeオブジェクトの数: " . $factory->cache_count;
say "";

# メモリ使用量を確認
my $bullets_size = total_size(\@bullets);
my $cache_size = total_size($factory->_cache);

say "=== メモリ使用量 ===";
say "弾1000発分: " . sprintf("%.1f", $bullets_size / 1024) . "KB";
say "BulletType 5つ分: " . sprintf("%.1f", $cache_size / 1024) . "KB";
say "";

# 弾幕を20x10の範囲で描画（一部だけ）
say "=== 弾幕プレビュー（先頭200発）===";
for my $row (0 .. 3) {
    for my $col (0 .. 49) {
        my $idx = $row * 50 + $col;
        my $bullet = $bullets[$idx];
        $bullet->{type}->render($bullet->{x}, $bullet->{y});
    }
    say "";
}
```

実行結果：

```
=== 弾幕の統計 ===
弾の総数: 1000
BulletTypeオブジェクトの数: 5

=== メモリ使用量 ===
弾1000発分: 245.8KB
BulletType 5つ分: 3.5KB

=== 弾幕プレビュー（先頭200発）===
●★|→〜●★|→〜●★|→〜●★|→〜●★|→〜●★|→〜●★|→〜●★|→〜●★|→〜●★|→〜
●★|→〜●★|→〜●★|→〜●★|→〜●★|→〜●★|→〜●★|→〜●★|→〜●★|→〜●★|→〜
●★|→〜●★|→〜●★|→〜●★|→〜●★|→〜●★|→〜●★|→〜●★|→〜●★|→〜●★|→〜
●★|→〜●★|→〜●★|→〜●★|→〜●★|→〜●★|→〜●★|→〜●★|→〜●★|→〜●★|→〜
```

1000発の弾を、たった5つの `BulletType` オブジェクトで管理できました！

## オブジェクトプールの威力

前回との比較をしてみましょう：

| 項目 | 第1回（分離なし） | 第2回（手動分離） | 今回（Factory） |
|-----|-----------------|------------------|-----------------|
| 弾1000発のメモリ | 約600KB | 約250KB | 約250KB |
| BulletType管理 | なし | 手動 | 自動（キャッシュ） |
| 同じ種類の重複 | 防げない | 注意が必要 | 防げる |

`BulletFactory` の導入により、弾の種類の管理が自動化され、重複オブジェクトの生成を防ぐことができました。

## 次回予告

`BulletFactory` で弾の種類を管理できるようになりました。次回は、実際に弾を動かして描画する方法を学びます。

`render` メソッドに外部状態（位置）を渡して、弾幕を描画してみましょう！

## 今回のまとめ

- `BulletFactory` クラスで弾の種類を一元管理
- `//=` 演算子でキャッシュ機構を実装
- 同じ種類の弾は同じオブジェクトを返す（重複防止）
- 1000発の弾を5つの `BulletType` オブジェクトで管理
- 次回：外部状態を渡して弾幕を描画する

## 今回の完成コード

```perl
#!/usr/bin/env perl
use v5.36;
use Devel::Size qw(total_size);

package BulletType {
    use Moo;

    has shape => (is => 'ro', required => 1);
    has color => (is => 'ro', required => 1);
    has size  => (is => 'ro', required => 1);
    has char  => (is => 'ro', required => 1);

    sub render($self, $x, $y) {
        my $char = $self->char;
        print "$char";
    }

    sub describe($self) {
        my $shape = $self->shape;
        my $color = $self->color;
        return "[$color $shape]";
    }
}

package BulletFactory {
    use Moo;

    has _cache => (is => 'ro', default => sub { {} });

    has _definitions => (
        is      => 'ro',
        default => sub {
            {
                red_circle   => { shape => 'circle', color => 'red',    size => 8,  char => '●' },
                blue_star    => { shape => 'star',   color => 'blue',   size => 12, char => '★' },
                green_laser  => { shape => 'laser',  color => 'green',  size => 4,  char => '|' },
                yellow_arrow => { shape => 'arrow',  color => 'yellow', size => 6,  char => '→' },
                purple_wave  => { shape => 'wave',   color => 'purple', size => 10, char => '〜' },
            }
        },
    );

    sub get($self, $type_key) {
        my $cache = $self->_cache;
        my $defs  = $self->_definitions;

        $cache->{$type_key} //= do {
            my $def = $defs->{$type_key}
                or die "Unknown bullet type: $type_key";
            BulletType->new(%$def);
        };

        return $cache->{$type_key};
    }

    sub cache_count($self) {
        return scalar(keys %{$self->_cache});
    }

    sub list_cached($self) {
        return keys %{$self->_cache};
    }
}

# メイン処理
my $factory = BulletFactory->new;
my @type_keys = qw(red_circle blue_star green_laser yellow_arrow purple_wave);

# 1000発の弾を生成
my @bullets;
for my $i (0 .. 999) {
    my $type_key = $type_keys[$i % 5];
    push @bullets, {
        type => $factory->get($type_key),
        x    => $i % 50,
        y    => int($i / 50),
        vx   => 0,
        vy   => 1,
    };
}

say "=== 弾幕シューティングエンジン ===";
say "弾の総数: " . scalar(@bullets);
say "BulletTypeオブジェクト数: " . $factory->cache_count;
say "キャッシュ内容: " . join(", ", $factory->list_cached);
say "";

# メモリ使用量
my $size = total_size(\@bullets);
say "メモリ使用量: " . sprintf("%.1f", $size / 1024) . "KB";
```
