---
categories:
  - design-pattern
date: 2026-02-17T07:07:05+09:00
draft: false
epoch: 1771279625
image: /favicon.png
iso8601: 2026-02-17T07:07:05+09:00
tags:
  - code-doctor
  - decorator
  - perl
  - object-oriented
title: 【コードドクター】第15話：静的継承の呪縛とマトリョーシカの刃【Decorator】
---

深夜のサーバーサイド開発室。空調の音だけが響く中、私は壁一面に貼られたホワイトボードの前で立ち尽くしていた。

「『伝説の剣』に『炎属性』をつけると『LegendaryFireSword』...さらに『耐久度強化』がつくと『DurableLegendaryFireSword』...」

私の名前は継承 累 (Keisho Rui)。このプロジェクトのバックエンドを担当しているが、今まさに「継承」という名の迷宮で遭難しかけていた。
プランナーの要求は無慈悲だ。「次は『氷属性』追加ね。あ、既存の『炎』とも組み合わせられるようにして」。
それを聞いた瞬間、クラス図（家系図）がさらに倍に増える映像が頭をよぎり、私は目の前が真っ暗になった。

その時だった。
音もなくサーバーラックの隙間から、黒い鞄を持った男と、白衣の女性が現れたのは。

「ここか。指数関数的な『悲鳴』が聞こえたのは」

## 診断：静的継承依存症候群

「だ、誰ですか！？ セキュリティアラートは...」
「アラートが鳴る前に、システム自体が重すぎて沈黙していますね」

女性――看護師らしき人――が涼しい顔でタブレットを見ながら言った。
黒衣の男――ドクター――は、私の震える手からホワイトボードのマーカーを取り上げると、巨大な継承図の「根（Root）」を指先で弾いた。

「美しい家系図だ。近親婚を繰り返しすぎて、血が腐りかけているがな」

ドクターの冷徹な声が響く。

「先生、これは...『静的継承依存症候群（Static Inheritance Dependency Syndrome）』ですね」
「ああ。些細な機能追加のために、全遺伝子（クラス定義）をコピー＆ペーストしなければならない末期症状だ」

私は言葉を失った。まさにその通りだったからだ。

### 患部：終わらないクラス増殖

私は恐る恐る、エディタに表示されていたコードを彼らに見せた。

```perl
# --- Patient's Code: The "Inheritance Hell" ---
package Weapon {
    sub new ($class, %args) { bless {%args}, $class }
    sub attack ($self) { 10 }
    sub name   ($self) { "Sword" }
}

# 1st Generation: 単一属性ならまだマシだが...
package FireSword {
    use parent -norequire, 'Weapon';
    sub attack ($self) { $self->SUPER::attack() + 5 }
    sub name   ($self) { "Fire " . $self->SUPER::name() }
}

# 2nd Generation: 組み合わせが発生した瞬間、地獄が始まる
package FireIceSword {
    # どっちを継承する？ 多重継承？ それともコピペ？
    # 結局、コードをコピーしてつなぎ合わせるしかない...！
    use parent -norequire, 'Weapon';
    
    sub attack ($self) { 
        20 # Hardcoded: 10 + 5 + 5
    }
    sub name ($self) { "Fire Ice Sword" }
}
```

「装備品が増えるたびに、クラス定義が爆発的に増えていくんです。もう、どこを直せばいいのか...」

ドクターは画面を一瞥すると、ため息をついた。
「君は、帽子を被り直すたびに、人間そのものをクローンして作り変えるつもりか？」
「えっ？」
「今の君の設計はそういうことだ。『帽子を被った私』という新しい生物種を定義しているに過ぎない。帽子は『被る（Decorate）』ものだろう？ 遺伝子に焼き付けるものではない」

## 処方：Decorator Pattern による「着せ替え」手術

ドクターは鞄から白銀のメスを取り出した。
「継承（is-a）の鎖を断ち切り、集約（has-a）の層で包み込む。Decoratorパターンの適用だ」

「Decorator...飾り付け、ですか？」

「そうだ。オブジェクトに動的に責任を追加する。マトリョーシカのように、基本となるオブジェクトを機能で『包んで』いくのだ」

ドクターの指先がキーボードの上を舞うと、複雑怪奇なクラス階層が消え去り、シンプルな部品へと分解されていく。

### 治療後：柔軟な多層構造

```perl
# --- Doctor's Prescription: Decorator Pattern ---

# 1. Component: 全ての基本となるインターフェース
package Weapon {
    sub new ($class) { bless {}, $class }
    sub attack ($self) { 10 }
    sub name   ($self) { "Sword" }
}

# 2. Decorator Base: 「包むもの」の基底クラス
# 中身（component）を保持し、処理を委譲する
package WeaponDecorator {
    sub new ($class, %args) {
        my $self = bless {%args}, $class;
        die "Component is required" unless $self->{component};
        return $self;
    }
    
    # デフォルトでは何もしない（ただ中身に流すだけ）
    sub attack ($self) { $self->{component}->attack() }
    sub name   ($self) { $self->{component}->name() }
}

# 3. Concrete Decorators: 具体的な「飾り」
package FireAttribute {
    use parent -norequire, 'WeaponDecorator';
    
    sub attack ($self) {
        # 元の攻撃力に +5 する（振る舞いの追加）
        return $self->SUPER::attack() + 5;
    }
    
    sub name ($self) {
        return "Fire " . $self->SUPER::name();
    }
}

package IceAttribute {
    use parent -norequire, 'WeaponDecorator';
    
    sub attack ($self) {
        return $self->SUPER::attack() + 5;
    }
    
    sub name ($self) {
        return "Ice " . $self->SUPER::name();
    }
}
```

「見てみたまえ。これが『組み合わせ』からの解放だ」

ドクターがエンターキーを押すと、今まで定義不可能だった「組み合わせ」が、いとも簡単に生成された。

```perl
# Base weapon
my $sword = Weapon->new;

# 炎属性を追加：SwordをFireで包む
my $fire_sword = FireAttribute->new( component => $sword );
# Output: "Fire Sword" (Atk: 15)

# さらに氷属性を追加：FireSwordをIceで包む
my $fire_ice_sword = IceAttribute->new( component => $fire_sword );
# Output: "Ice Fire Sword" (Atk: 20)
```

「すごい...クラスを増やさなくても、インスタンスを『包む』だけで機能が増えていく...！」
私は感動のあまり、小刻みに震えていた。目の前のコードは、まるで着せ替え人形のように自由だ。

「さらに、順序も自由だ」と助手さんが補足する。「『伝説の（攻撃力2倍）』という飾りを、属性の『前』につけるか『後』につけるかで、計算結果を変えることもできます」

```perl
# 全てを2倍にする「Legendary」デコレータ
package LegendaryAttribute {
    use parent -norequire, 'WeaponDecorator';
    sub attack ($self) { return $self->SUPER::attack() * 2; }
    sub name   ($self) { return "Legendary " . $self->SUPER::name(); }
}

# (10 + 5 + 5) * 2 = 40
my $legendary_sword = LegendaryAttribute->new( component => $fire_ice_sword );
```

## 予後：自由の代償

「ありがとうございます、ドクター！ これなら、明日プランナーがどんな無茶を言ってきても大丈夫です！」

私はあまりの嬉しさに、つい調子に乗ってしまった。
「よーし、じゃあテストとして、全属性・全バフ・全特効を全部乗せした『アルティメット・ゴッド・ウェポン』を作っちゃうぞー！」

私はループを回し、100個以上のDecoratorを幾重にも重ね合わせた。

「あ、患者さん、それは...」

助手が止めるより早く、私は実行キーを押した。
その瞬間。
サーバーのファンがジェットエンジンのような轟音を上げ、画面がフリーズした。

「うわっ！？ 何が！？」
「着ぶくれしすぎて窒息したな」

ドクターが冷ややかに言った。
「機能（服）を重ねれば、その分だけポインタを辿るコスト（体重）は増える。マトリョーシカも100個重ねれば、中身を取り出すだけで日が暮れるだろう？」

「そ、そんな...」
「自由には責任が伴う。必要なものを、必要な分だけ装飾する。それが『大人のファッション』というものだ」

ドクターは最後にそう言い残すと、鞄を持って立ち上がった。

「行くぞ、ナース。次の『スパゲッティ』が待っている」
「お大事にー。あ、着せ替えはほどほどにね？」

二人が去った後の静寂の中で、私は赤くなったサーバーのランプを見つめながら、深く反省した。
でも、その顔は以前のような絶望ではなく、少しだけ晴れやかだった気がする。

---

### Dr. Code's Prescription

- **Name**: Decorator Pattern
- **Problem**: 機能を拡張するために継承を使うと、クラスの組み合わせが爆発的に増えてしまう（クラス爆発）。
- **Solution**: 機能を「継承」ではなく「集約（包み込み）」によって追加する。
- **Effect**:
  - クラス数を増やさず、柔軟に機能を組み合わせられる。
  - 実行時に動的に機能を追加・削除できる。
- **Side Effect**:
  - 小さなオブジェクト（デコレータ）が大量に生成されるため、デバッグ時に構造が分かりにくくなることがある。
  - 装飾の順序に依存するロジック（計算順序など）には注意が必要。

> **Source Code**: [GitHub Gist](https://gist.github.com/nqou-net/...)
