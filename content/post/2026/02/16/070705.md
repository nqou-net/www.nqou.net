---
categories:
  - management
  - design-pattern
date: 2026-02-16T07:07:05+09:00
draft: false
epoch: 1771193225
image: /favicon.png
iso8601: 2026-02-16T07:07:05+09:00
tags:
  - bridge
  - perldoc
  - code-doctor
title: 'コードドクター：Bridge Pattern - 多次元増殖症候群'
---

深夜の会議室は、静寂よりも「行き詰まり」という言葉が似合う場所だった。
ホワイトボード一面に描かれたクラス図は、まるで巨大な蜘蛛の巣だ。私はその前で、ここ数時間ほど頭を抱え続けている。

「完璧なはずだ…なぜSlack通知を追加するだけで10個もクラスを作らなきゃいけないんだ？」

私が設計した『汎用メッセージング基盤 ver.3.0』は、あらゆる通知手段と、あらゆる優先度に対応できる拡張性を持っていた――はずだった。
しかし、現実は非情だ。優先度（Urgent, Normal）と通知手段（Email, SMS）の組み合わせの数だけ、サブクラスが爆発的に増え続けている。

その時、背後でドアが音もなく開いた。

「呼んだか？」

振り返ると、黒い鞄を持ったドクターが立っていた。傍らには、無表情な白衣の助手が控えている。

「呼んでません。セキュリティロックは…」
「コードが悲鳴を上げていたので」

ドクターは私の返事を無視し、ホワイトボードへ歩み寄った。そして、私が苦心して書き上げたクラス図の末端――増えすぎたサブクラスの群れ――を、指で容赦なく擦り消し始めた。

「無駄な枝葉だ」

「やめてください！ それは基盤の要なんです！」

私は思わず叫んだ。
「もし『最優先（Critical）』を追加したら？ もし『LINE通知』を追加したら？ 全ての組み合わせを網羅するには、これが必要なんです！」

ドクターはチョークの粉がついた指先を払い、冷徹に言い放った。

「基盤？ いや、これは『迷宮』だ。出口のないな」

助手が静かに補足する。
「神経と筋肉が癒着してしまっていますね。これでは指一本動かすのにも、全身の骨格を作り変えなければなりません」

# 診断：多次元増殖症候群

ドクターは私のPCの前に座り、エディタを開いた。画面に映し出されたのは、私が誇りとしていたクラス階層だ。

```perl
# lib/Bad/Notifier.pm
package Bad::Notifier;
use v5.36;

sub new {
    my ($class, %args) = @_;
    bless \%args, $class;
}

sub send {
    my ($self, $message) = @_;
    die "Abstract method 'send' called";
}

1;
```

ここまでは良い。問題はその先だ。`Notifier` を継承した `Urgent` と `Normal` があり、さらにそれを継承した `Email` と `SMS` がある。

```perl
# lib/Bad/Notifier/Urgent/Email.pm
package Bad::Notifier::Urgent::Email;
use v5.36;
use parent 'Bad::Notifier::Urgent';

sub send {
    my ($self, $message) = @_;
    my $formatted = $self->format_message($message); # [URGENT] ... !!!
    print "Sending Email: $formatted\n";
}
1;
```

これを使う側のコードはこうなる。

```perl
#!/usr/bin/env perl
use v5.36;
use lib 'lib';

use Bad::Notifier::Urgent::Email;
use Bad::Notifier::Urgent::SMS;
# ... 他にも大量のuseが必要

# 組み合わせごとに異なるクラスが必要
my $urgent_email = Bad::Notifier::Urgent::Email->new();
$urgent_email->send("Server Down");
```

「Slack対応はどうするつもりだ？」ドクターが尋ねる。

「ええ、ですから `MyApp::Notifier::Urgent::Slack`, `MyApp::Notifier::Normal::Slack` を作って…」

「もし『優先度』に『最優先（Critical）』を追加したら？」

「それは… 全ての媒体（Email, SMS, Slack, LINE...）に対して `Critical` クラスを作れば…」

言いながら、私は言葉に詰まった。クラスの数が、掛け算によって指数関数的に増えていく光景が脳裏に浮かんだからだ。

「掛け算が、足し算ではなく『組み合わせ爆発』を起こしています」
助手は診断を下すように告げた。
「多次元増殖症候群の末期ですね。機能（優先度）と実装（通知手段）という2つの次元が、継承という1つの軸で混ざり合ってしまっています」

# 手術：Bridgeによる分離

「切開する」

ドクターの宣言とともに、手術（リファクタリング）が始まった。

「機能と実装の継承関係を断ち切る。これらは本来、別々の階層として生きるべきだ」

ドクターは、新しいディレクトリ `Good/Sender` を作り始めた。

「まず、実装（通知手段）を独立させる」

```perl
# lib/Good/Sender/Role.pm
package Good::Sender::Role;
use v5.36;
use Role::Tiny;

# Implementation Interface
requires 'send';

1;
```

```perl
# lib/Good/Sender/Email.pm
package Good::Sender::Email;
use v5.36;
use Role::Tiny::With;
with 'Good::Sender::Role';

sub new {
    my ($class, %args) = @_;
    bless \%args, $class;
}

sub send {
    my ($self, $body) = @_;
    print "Sending Email: $body\n";
}

1;
```

「次に、機能（優先度）の階層を作る。ただし、ここが重要だ」
ドクターの手が `Notifier` クラスを書き換えていく。

```perl
# lib/Good/Notifier.pm
package Good::Notifier;
use v5.36;

# Abstraction
sub new {
    my ($class, %args) = @_;
    # Bridge: Implementationへの参照を保持
    die "Missing 'sender' argument" unless $args{sender};
    bless \%args, $class;
}

sub sender { shift->{sender} }

sub notify {
    my ($self, $message) = @_;
    # 委譲 (Delegation)
    $self->sender->send($self->format_message($message));
}

# 抽象メソッド的な位置づけ (RefinedAbstractionで実装)
sub format_message {
    my ($self, $message) = @_;
    return $message;
}

1;
```

「継承の代わりに『委譲』を使うのです」
助手解説に合わせて、ドクターがコードを組み上げていく。

「`Notifier` は `Sender` を継承するのではなく、**持っている（Has-a）** 関係になります。これが『機能』と『実装』を繋ぐ『橋（Bridge）』です」

```perl
# lib/Good/UrgentNotifier.pm
package Good::UrgentNotifier;
use v5.36;
use parent 'Good::Notifier';

# RefinedAbstraction
sub format_message {
    my ($self, $message) = @_;
    # 機能拡張: 急ぎのメッセージは強調する
    return "[URGENT] " . uc($message) . " !!!";
}

1;
```

# 予後：疎結合という名の橋

手術後のコードを動かしたとき、私は目を疑った。

```perl
use Good::Sender::Email;
use Good::Sender::SMS;
use Good::UrgentNotifier;
use Good::NormalNotifier;

# Implementations（実装）
my $email = Good::Sender::Email->new;
my $sms   = Good::Sender::SMS->new;

# Abstractions（機能） - ここで橋を架ける
my $urgent_email = Good::UrgentNotifier->new(sender => $email);
my $urgent_sms   = Good::UrgentNotifier->new(sender => $sms);
my $normal_email = Good::NormalNotifier->new(sender => $email);

$urgent_email->notify("Server Down");
# Output: Sending Email: [URGENT] SERVER DOWN !!!
```

「継承が… なくなった？ 私の美しい階層構造が！」

「階層ではない。『橋』を架けたのだ」
ドクターは鞄から何かを取り出し、机の上に置いた。子供用の積み木セットだ。

「機能と実装が独立して動く。Slackを追加したければ、`Good::Sender::Slack` を作るだけでいい。既存のクラスには指一本触れずに済む」

私はその積み木を手に取った。赤いブロック（機能）と青いブロック（実装）が、自由自在に組み合わさる。

「これが…Bridge Pattern…」

目から鱗が落ちるとは、このことだ。私は震える手でそれを握りしめた。
「分かりました… この橋のように、人と人との架け橋になれというメッセージですね！ アーキテクチャとは技術ではなく、心なんだと…！」

私は立ち上がった。
「私、目指します！ 心の架け橋エンジニアを！」

助手が少し困ったような顔をした。
「…リハビリ用の玩具ですが、随分と壮大な解釈をされましたね」

「あながち間違いではない」
ドクターが出口へ向かいながら言った。
「システムも人間関係も、結合（Coupling）より疎通（Communication）が大事だからな」

助手が無言で、ドクターの少し曲がったネクタイを直した。二人が去った会議室には、書き直されたわずかなクラス図と、無限の可能性を秘めた積み木だけが残されていた。


---

### 処方箋：Bridge Pattern

- **概要**: 機能（Abstraction）と実装（Implementation）のクラス階層を分離し、それらを委譲によって繋ぐことで、それぞれを独立して拡張できるようにするパターン。
- **適応症状**:
  - 機能拡張と実装拡張の2つの軸があり、継承による組み合わせ爆発（クラス爆発）が起きている。
  - 実装の詳細を実行時に切り替えたい。
- **効果**:
  - 機能と実装を独立して拡張できる（疎結合）。
  - クラス数を「掛け算」から「足し算」に減らせる。
