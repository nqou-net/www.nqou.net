---
categories:
  - design-pattern
date: 2026-02-19T07:07:05+09:00
description: 「1万体のユニットを出したいだけなんです！」と叫ぶゲーム開発者が運び込まれた。彼のコードは、全ての兵士に辞書を持たせて戦場に送り出していた。
draft: false
epoch: 1771452425
image: /favicon.png
iso8601: 2026-02-19T07:07:05+09:00
tags:
  - flyweight
  - perl
title: 'Flyweight: 1万体の分身と、分別できないゴミたち'
---

## I. 導入 (Admission)

締め切り前の深夜開発。それは全てのプログラマーが最も精神を削られる時間だ。
デスクに散乱したエナジードリンクの空き缶が、僕の焦りを反映しているかのようだ。

「落ちた……またかよ！」

開発中のRTS（リアルタイムストラテジー）「軍団大戦争」。
画面を埋め尽くす1万体の兵士が激突する、圧巻の光景を夢見ていた。
だが現実は、ユニットを500体出した時点でメモリ警告が出て、アプリは無慈悲にクラッシュする。

「たった1万体だぞ？ 最新のPCなら余裕のはずなのに……なんでメモリが足りなくなるんだ！」

キーボードに突っ伏して叫ぶと、不意に玄関のチャイムが鳴った。
こんな時間に誰だ、宅配便か？

ドアを開けると、黒いコートを着た無精髭の男と、白衣の女性が立っていた。
男は僕の顔を見るなり、部屋の奥――つけっぱなしのモニターに視線を走らせた。

「……肥満だな。」

「は？」

「お届けに参りました」と女性が優雅に微笑む。「あなたのコードに、解決策（ソリューション）を」

## II. 検査 (Examination)

彼らは勝手に部屋に上がり込むと、僕の椅子を占領してコードを読み始めた。
ドクターと呼ばれたその男は、スクロールするたびに眉間の皺を深くしていく。

「全員、これを持っているのか」

ドクターは僕のリュックサックを手に取り、中から分厚い英和辞典を取り出して僕に押し付けた。
重い。なんだこれ。

「え？」

「ドクターは仰っています」と助手の女性が解説を入れる。「『なぜ1万体のゴブリン全員が、個別に辞書（重いデータ）を背負って戦場に出るのか』と」

「それは……オブジェクト指向ですから！」僕は反論した。「個々のゴブリンは独立したオブジェクトとして、自分のデータを持つべきでしょう？」

ドクターは短く鼻を鳴らした。

「重すぎる。戦う前に自滅するぞ」

彼は画面上のクラス定義を指差した。

### 患部 (Symptom)

```perl
use v5.36;

# 悪い実装: 全てのインスタンスが巨大なデータを個別に持っている

package Goblin {
    sub new ($class, %args) {
        # 毎回重いデータをロードしている（シミュレーション）
        my $heavy_mesh = "X" x (1024 * 10); # 10KB Mesh
        my $heavy_texture = "Y" x (1024 * 50); # 50KB Texture
        
        return bless {
            name      => 'Goblin',
            mesh      => $heavy_mesh,
            texture   => $heavy_texture,
            animation => ['idle', 'walk', 'attack', 'die'], # 共通データ
            x         => $args{x} || 0,
            y         => $args{y} || 0,
            hp        => 50,
        }, $class;
    }

    sub draw ($self) {
        # 描画処理...
    }
}
```

「インスタンス変数に、不変のデータまで詰め込みすぎだ」ドクターが指摘する。「メッシュ、テクスチャ、アニメーション定義……これらは全てのゴブリンで共通だろう？」

「ええ、まあ……同じ種類のモンスターですから」

「なら、それは『個体』が持つべきものではない。『種族』が持つべきだ」

## III. 処置 (Surgery)

「脂肪吸引を始める」

ドクターがキーボードを叩き始めた。その手つきは、まるでメスで患部を切り取るように鋭い。

「まず、変化しないデータ（Intrinsic State）を切り出す」

彼は `Goblin` クラスから、個体ごとに変わらないデータを引き剥がし、新しいクラス `GoblinType` に移植した。

「そして、個体（Context）には、変化するデータ（Extrinsic State）と、`GoblinType` への参照だけを持たせる」

### 処方 (Prescription)

```perl
use v5.36;

# 良い実装: 変化しないデータ（Intrinsic State）を共有する

# 1. Flyweight (共有されるオブジェクト)
package GoblinType {
    sub new ($class) {
        # 重いデータはここで一度だけ作られる
        my $heavy_mesh = "X" x (1024 * 10);
        my $heavy_texture = "Y" x (1024 * 50);
        
        return bless {
            name      => 'Goblin',
            mesh      => $heavy_mesh,
            texture   => $heavy_texture,
            animation => ['idle', 'walk', 'attack', 'die'],
        }, $class;
    }

    sub draw ($self, $context) {
        # 描画処理にはContext（外部状態）を使う
        # say "Drawing $self->{name} at ($context->{x}, $context->{y})";
    }
}

# 2. Factory (Flyweightを管理・提供する工場)
package UnitFactory {
    my %pool;

    sub get_unit_type ($class, $type_name) {
        # まだ無ければ作る、あれば返す（Cache）
        return $pool{$type_name} //= "${type_name}Type"->new();
    }
}

# 3. Context (個別のインスタンス)
package Goblin {
    sub new ($class, %args) {
        return bless {
            # 参照（ポインタ）のみを持つ
            type => UnitFactory->get_unit_type('Goblin'),
            # 外的状態（Extrinsic State）のみインスタンスが持つ
            x    => $args{x} || 0,
            y    => $args{y} || 0,
            hp   => 50,
        }, $class;
    }

    sub draw ($self) {
        # 実処理はTypeに委譲し、自分の状態（Context）を渡す
        $self->{type}->draw($self);
    }
}
```

コードが書き換わると同時に、サブモニターに表示していたメモリ使用率のグラフが、崖を転がり落ちるように急降下した。

「うわっ、グラフが……！ さっきまで真っ赤だったのに！」

「彼らは身軽になったんです」助手が満足げに頷く。「辞書は図書館（Factory）に置いて、必要な時だけ見に行けばいい。そうでしょう？」

1万体のゴブリンがスムーズに動き回る。ラグも、クラッシュもない。
これが、Flyweightパターン……！

## IV. 予後 (Prognosis)

「これでリリースできます！ ありがとうございます！」

僕は深々と頭を下げた。ドクターは何も言わず、ただ僕のデスクの方を見ていた。
そこには、食べかけのカップ麺がある。
そういえば、徹夜続きで腹が減っているのかもしれない。

（まさか、僕を気遣って……？ 友情のシェア？）

「……あ、あの、食べますか？」

僕がカップ麺を差し出すと、ドクターは無言でそれを受け取った。
そして、中に刺さっていたプラスチックのフォークを抜き取り、カップとは別のゴミ箱へ捨てた。

「……分別」

カップ麺はそのまま僕の手に戻された。

「え？」

「リソースの管理には厳しいんです」助手が困ったように笑う。「メモリもゴミも、混ざっているのが許せない性分でして」

ただの分別マニアかよ……！

ドクターは鞄を持ち上げ、出口へと向かう。

「感謝は、この（軽量化された）コードに」

---

## 処方箋まとめ

| 症状 | 適用すべき | 経過観察 |
| :--- | :---: | :---: |
| 大量のオブジェクトを生成してメモリ枯渇 | ✓ | |
| オブジェクト間で重複するデータが多い | ✓ | |
| オブジェクトのアイデンティティ（同一性）が重要でない | ✓ | |
| インスタンス数が少なく、コードの複雑さを避けたい | | ✓ |

### 治療のステップ

1.  **Intrinsic State（不変・共有部分）の特定**: 全インスタンスで共通するデータ（画像、基本パラメータなど）を洗い出す。
2.  **Flyweightクラスの作成**: 共有データを保持するクラスを作成する。
3.  **Factoryクラスの作成**: Flyweightインスタンスを生成・管理（キャッシュ）する工場を作る。
4.  **Contextクラスの修正**: 元のインスタンスから共有データを削除し、Flyweightへの参照だけを持たせる。
5.  **描画/操作メソッドの委譲**: 実際の処理を行う際は、Context（自分）を引数としてFlyweightのメソッドを呼ぶ。

### 助手より

1万体の兵士を動かす夢、叶ってよかったですね！
でも、現実のゴミもちゃんと分別しないと、お部屋のメモリ（床面積）がオーバーフローしてしまいますよ？
お大事に。
