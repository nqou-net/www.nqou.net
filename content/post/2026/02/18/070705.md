---
categories:
  - code-doctor
  - design-pattern
date: 2026-02-18T07:07:05+09:00
draft: false
epoch: 1771366025
image: /favicon.png
iso8601: 2026-02-18T07:07:05+09:00
tags:
  - composite
  - perl
  - refactoring
title: コードドクター Code:017 「過敏性再帰処理アレルギー」
---

## 救急搬送：再帰の悲鳴

深夜のサーバー室は、冷却ファンの駆動音だけが支配する無機質な空間だった。
その片隅で、私は端末の光に照らされながら頭を抱えていた。28歳のインフラエンジニアである私が任されたのは、古いファイルサーバーの移行スクリプト作成。
しかし、画面の中のコードは、まるで私の混乱をそのまま映し出したかのようにスパゲッティ状態になり、エラーログを吐き続けていた。

「ファイルならコピー、ディレクトリなら中に入って再帰……いや、空ディレクトリの場合は？ `.` と `..` の除外処理はどこに入れた？」

独り言が漏れる。条件分岐が複雑すぎて、どこで処理が止まっているのかさえ分からない。
再帰処理を書くたびに、「これは本当にディレクトリか？ ファイルじゃないか？」と疑心暗鬼になり、至る所で `if (-d $path)` や `ref($node)` を繰り返す。それが私のコードを醜く肥大化させていた。

「……再帰の悲鳴が聞こえたわ。」

不意に背後から凛とした女性の声がした。
振り返ると、静寂の中に似つかわしくない二人の影。黒い往診鞄を持った長身の男と、白衣の上にカーディガンを羽織った女性助手だ。

「呼んでませんけど……」
「コードが助けを求めていたので」

男――ドクターは、許可も求めずにサーバーラックに近づくと、指先でスーッとパネルをなぞった。埃を確認しているように見えたが、その目は私の端末の画面に注がれていた。

## 診断：過剰な区別アレルギー

ドクターは私の席に無言で近づき、画面を覗き込んだ。そこに表示されていたのは、私が苦心して書いたプロセッサー処理だ。

```perl
package Bad::Processor;
use v5.36;
use experimental qw(builtin class);
use builtin qw(blessed);

sub process_backup ($self, $node, $backup_path) {
    my @logs;
    
    # 症状: Nodeの種類によって処理を完全に分けている
    # しかも再帰処理の中に条件分岐が散らばっている
    my $type = blessed($node);
    
    if ($type eq 'Bad::File') {
        # ファイルならコピー
        push @logs, $node->copy_to($backup_path);
    }
    elsif ($type eq 'Bad::Directory') {
        # ディレクトリなら作成して潜る
        push @logs, $node->make_new($backup_path);
        
        # 子要素の処理
        foreach my $child ($node->children) {
            # 再帰呼び出し
            # パス結合ロジックもここに混ざってしまっている
            my $new_path = "$backup_path/" . $node->name;
            push @logs, $self->process_backup($child, $new_path);
        }
    }
    else {
        die "Unknown type: $type";
    }
    
    return \@logs;
}
```

ドクターは一瞥するなり、眉間に深い皺を刻んだ。
「差別だ。通らない。」

短く吐き捨てられた言葉に、私は思わず反論する。
「差別じゃありません！ 区別です！ ファイルはコピーするもの、ディレクトリは潜るもの。扱いが違うんだから、厳密にチェックしないと……」

「ドクターは、『あなたはファイルとディレクトリをまるで敵同士のように扱っている』と仰っています」
助手さんが穏やかな口調で通訳してくれた。
「全てのノードに対して、いちいち身分証の提示を求めて『お前はファイルか？ ディレクトリか？』と尋問していては、処理が渋滞してしまいます。まるで、神経系が過敏になりすぎて、末端まで指令が届く前にショートしている状態です」

「過敏……」
「ええ。細胞（ファイル）と組織（ディレクトリ）を過剰に区別しようとする、一種のアレルギー反応ですね」

## 処置：同一視という鎮静剤

「どけ」
ドクターは私を椅子から追いやり、キーボードの前に座った。
「治療を開始する。全体と部分の合一。」

その指先が、まるでピアノを弾くように滑らかに動き始めた。

「まず、アレルギー源となっている過剰な条件分岐を除去します」
助手さんが解説する。「ファイルもディレクトリも、大きく見れば同じ『ファイルシステムの構成要素（Component）』です。共通のインターフェースという鎮静剤を投与し、それらを『同じもの』として扱えるようにします」

ドクターが定義したのは、たったこれだけのRoleだった。

```perl
package Good::Component;
use v5.36;
use Role::Tiny;

# 共通インターフェース
requires 'backup';
requires 'name';

1;
```

「そして、末端である『ファイル（Leaf）』と、容器である『ディレクトリ（Composite）』の双方に、このRoleを適用します」

```perl
package Good::File;
use v5.36;
use Role::Tiny::With;
with 'Good::Component';
# (省略: new, name)

sub backup ($self, $path) {
    # Leafの処理: 自身のバックアップのみ
    return ["Copying file " . $self->name . " to $path"];
}
```

```perl
package Good::Directory;
use v5.36;
use Role::Tiny::With;
with 'Good::Component';
# (省略: new, name, add)

sub backup ($self, $path) {
    my $my_path = "$path/" . $self->name;
    my @logs;
    
    # 自身の処理
    push @logs, "Creating directory " . $self->name . " at $path";
    
    # 子要素への委譲 (再帰)
    # FileもDirectoryも同じ 'backup' メソッドを持っているので
    # 条件分岐が不要になる (ここがCompositeの肝)
    foreach my $child (@{$self->{children}}) {
        push @logs, @{ $child->backup($my_path) };
    }
    
    return \@logs;
}
```

驚くべきことに、あれほど複雑だった利用側のコード（Processor）は、完全に消滅してしまった。
ドクターはEnterキーを強く叩き、テストを実行する。

```perl
# クライアントコード（呼び出し側）が劇的に単純化
# Processorクラスすら不要で、ルート・コンポーネントを叩くだけ
my $logs = $root->backup('/backup');
```

「すごい……条件分岐が一つもない」
私は画面に見入った。ギザギザしていたインデントが消え、平坦な草原のように美しいコードになっている。
「これが、Composite Pattern……」

## 予後：伝送ロス

「アレルギー反応は鎮静化しました」
助手さんがにっこりと微笑む。「個々を区別することに囚われず、全体の振る舞いに目を向けることが大切です」

私は深く頷き、整然としたコードを見つめた。
「ありがとうございます。僕、ファイルだから、ディレクトリだからって、勝手に壁を作っていたのかもしれません」

ふと、ドクターが私の胸元をジッと見つめていることに気づいた。
その視線は鋭く、でもどこか真剣だ。
（僕の社員証を見ているのか？ この過酷な現場を深夜まで支えている責任感に、敬意を表してくれているんだ…！）

私は誇らしげに胸を張った。
「このIDカードは、僕のエンジニアとしての誇りです」

ドクターは無言で手を伸ばすと、私の胸ポケットから垂れ下がっていたねじれたLANケーブルを掴み、グイッと真っ直ぐにした。

「……伝送ロス。」

「え？」
私が呆然としていると、助手さんが苦笑しながら言った。
「ケーブルがねじれていると、ドクター、気になって眠れないんです。……お大事に」

二人は嵐のように去っていった。
残された私は、真っ直ぐになったLANケーブルとコードを見送りながら、「僕たちもまた、システムという巨大なツリーの一部（Node）なんだな」と妙に納得していた。

---
## 処方箋まとめ

| 症状 | 適用すべき | 経過観察 |
| :--- | :---: | :---: |
| 全体と部分（容器と中身）を区別して記述し、コードが複雑化している | ✓ | |
| 再帰的な構造を扱う必要がある | ✓ | |
| オブジェクトの種類によって全く異なるメソッドを呼び出す必要がある | | ✓ |

### 治療のステップ

1.  **Componentの定義**: Leaf（葉）とComposite（容器）に共通するインターフェース（Role/抽象クラス）を定義する。
2.  **共通操作の実装**: `backup` や `print` など、共通して行いたい操作を定義する。
3.  **Leafの実装**: Componentを実装し、自身の処理のみを行う。
4.  **Compositeの実装**: Componentを実装し、子要素（Componentのリスト）を保持する。操作は自身で行いつつ、子要素へ委譲（再帰呼び出し）する。
5.  **Clientの単純化**: 呼び出し元は、相手がLeafかCompositeかを気にせず、ただComponentのメソッドを呼ぶだけでよくなる。

### 助手より

ファイルとディレクトリのように、「構造を持つもの」と「持たないもの」を再帰的に扱う場合、どうしても条件分岐が増えてしまいがちです。
Composite Patternを使ってそれらを「同一視」することで、コードの見通しは驚くほど良くなります。
几帳面なのは素晴らしいことですが、コードにおいては「あえて区別しない」という勇気も、時には必要ですよ。
