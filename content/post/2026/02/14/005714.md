---
categories:
  - tech
date: 2026-02-14T00:57:14+09:00
description: ゲーム開始が遅い！敵生成のたびにDB読み込み？コードドクターがPrototypeパターンで手術。一度作った敵を複製して大軍を瞬時に。
draft: false
epoch: 1770998234
image: /favicon.png
iso8601: 2026-02-14T00:57:14+09:00
tags:
  - code-doctor
  - design-patterns
  - prototype-pattern
  - perl
  - game-development
title: コードドクター〜敵キャラクター量産緊急手術（Prototype）
toc: true
---

「先生、患者さんです！」

助手の声に、私は手元のモニターから目を離した。

扉の向こうから、ふらふらと歩いてくる女性。顔色は青白く、目の下には深い隈。髪を束ねたゴムが右に傾いている。典型的な症状だ。

「も、もう限界なんです…」

彼女はそう言って、膝から崩れ落ちそうになった。助手が慌てて支える。

「大丈夫ですよ、ここはコード診療所。どんな症状も治療します」

助手の言葉に、彼女は縋るような目で私を見た。

私は静かに言った。

「問診を始める」

---

## 問診

「ゲーム開発を…しています」

彼女は絞り出すように言った。

「RPGの敵キャラクター生成システムを担当していて…」

「続けて」

「スライム、ゴブリン、ドラゴン…いろんな敵モンスターを配置するシステムです」

彼女の手が震えている。

「最初はうまく動いていたんです。でも、敵の数が増えて…」

「それで？」

「ダンジョンに100体の敵を配置しようとしたら…」

彼女は頭を抱えた。

「ゲーム開始に30秒もかかるようになったんです！」

私は静かに頷いた。

「コードを見せてもらう」

---

## 診察

助手がモニターを彼女の方に向ける。

```perl
package Enemy;
use Moo;

has name       => (is => 'ro', required => 1);
has max_hp     => (is => 'ro', required => 1);
has hp         => (is => 'rw', required => 1);
has attack     => (is => 'ro', required => 1);
has defense    => (is => 'ro', required => 1);
has skills     => (is => 'ro', default => sub { [] });
has drop_items => (is => 'ro', default => sub { [] });
```

「これが敵クラスです。問題はこっちで…」

```perl
package EnemyFactory;
use Moo;

sub create {
    my ($self, $enemy_type) = @_;
    
    # DBからマスターデータを読み込む
    my $data = $self->_load_from_db($enemy_type);
    
    return Enemy->new(
        name       => $data->{name},
        max_hp     => $data->{max_hp},
        hp         => $data->{max_hp},
        attack     => $data->{attack},
        defense    => $data->{defense},
        skills     => [@{$data->{skills}}],
        drop_items => [@{$data->{drop_items}}],
    );
}
```

「敵を生成するたびにDBからデータを読み込んでいる」

私は指摘した。

「は、はい…」

「スライムを10体作れば、10回DBにアクセスする」

「そうなんです！」

彼女が叫ぶ。

「プレイヤーから『ロード遅い！』ってクレームが来て…上からは『すぐ直せ』って言われて…」

私はカルテに書き込んだ。

---

## 診断結果

| 症状 | 重症度 |
|------|--------|
| 生成コスト過多症 | 重症 |
| オブジェクト複製困難症 | 中症 |
| 深いコピー欠如症 | 中症 |

「重症だ」

彼女の顔が青ざめる。

「で、でも治るんですよね…？」

助手が彼女の肩に手を置いた。

「大丈夫ですよ。先生の腕なら、確実に治ります」

彼女は私を見上げる。その信頼に満ちた眼差しに、私は思わず…

「先生？」

「…処方箋を出す」

---

## 処方箋

```
処方: Prototype パターン
用法: 一度作ったオブジェクトを複製（クローン）して使い回す
効能: 生成コストの削減、高速なオブジェクト量産
```

「プロトタイプ…パターン？」

「つまりですね」

助手が説明を始める。

「今の作り方は、敵を1体作るたびにDBにアクセスしています。100体作れば100回アクセス。これがロードが遅い原因です」

「それは分かっています…でも、どうすれば…」

「Prototype パターンを使うと、こうなります」

助手がホワイトボードに書き始めた。

```
1. 最初に「スライム」「ゴブリン」「ドラゴン」のプロトタイプを1体ずつ作る（3回のDBアクセス）
2. 以降は、プロトタイプをコピーして使う（DBアクセスなし）
3. 100体作っても、DBアクセスは3回だけ！
```

「コピー…ですか？」

「クローンを作るイメージです」

助手が続ける。

「マスタースライムを1体用意しておいて、その複製を大量生産する。言わば、敵キャラクターの量産工場です」

彼女の目に光が戻ってきた。

「手術を始める」

---

## 第一手術: clone メソッドの導入

まず、敵クラスに「自分自身を複製する」メソッドを追加する。

```perl
package Enemy;
use Moo;
use Storable qw(dclone);

has name       => (is => 'ro', required => 1);
has max_hp     => (is => 'ro', required => 1);
has hp         => (is => 'rw', required => 1);
has attack     => (is => 'ro', required => 1);
has defense    => (is => 'ro', required => 1);
has skills     => (is => 'ro', default => sub { [] });
has drop_items => (is => 'ro', default => sub { [] });

# Prototypeパターン: クローンメソッド
sub clone {
    my $self = shift;
    return Enemy->new(
        name       => $self->name,
        max_hp     => $self->max_hp,
        hp         => $self->max_hp,  # HPは最大値にリセット
        attack     => $self->attack,
        defense    => $self->defense,
        skills     => dclone($self->skills),      # 深いコピー
        drop_items => dclone($self->drop_items),  # 深いコピー
    );
}
```

「`clone` メソッドが鍵だ」

「先生、`dclone` って何ですか？」

助手がフォローする。

「`Storable` モジュールの関数で、配列やハッシュを完全にコピーします。『深いコピー』と呼ばれる技術です」

---

## 第二手術: 浅いコピーと深いコピーの違い

「待ってください」

彼女が手を挙げた。

「普通にコピーするのと、何が違うんですか？」

「良い質問だ」

私はホワイトボードに図を描いた。

```perl
# 浅いコピー（危険！）
sub shallow_clone {
    my $self = shift;
    return Enemy->new(
        name       => $self->name,
        skills     => $self->skills,  # 参照をコピー
    );
}

my $slime1 = $prototype->shallow_clone();
my $slime2 = $prototype->shallow_clone();

# slime1にスキルを追加すると…
push @{$slime1->skills}, '毒攻撃';

# slime2にも毒攻撃が追加されてしまう！
# 同じ配列を参照しているから
```

彼女が目を見開いた。

「そ、それは困ります！」

「だから深いコピーが必要」

```perl
# 深いコピー（安全）
sub clone {
    my $self = shift;
    return Enemy->new(
        name       => $self->name,
        skills     => dclone($self->skills),  # 新しい配列を作成
    );
}

my $slime1 = $prototype->clone();
my $slime2 = $prototype->clone();

# slime1にスキルを追加しても…
push @{$slime1->skills}, '毒攻撃';

# slime2には影響しない！
# 別々の配列を持っているから
```

「なるほど…！」

---

## 第三手術: プロトタイプレジストリの作成

「最後の手術だ」

私はキーボードに手を伸ばした。

```perl
package EnemyRegistry;
use Moo;

has prototypes  => (is => 'ro', default => sub { {} });
has _load_count => (is => 'rw', default => 0);

# プロトタイプを登録（初回のみDBアクセス）
sub register {
    my ($self, $enemy_type) = @_;
    return if exists $self->prototypes->{$enemy_type};
    
    my $data = $self->_load_from_db($enemy_type);
    
    $self->prototypes->{$enemy_type} = Enemy->new(
        name       => $data->{name},
        max_hp     => $data->{max_hp},
        hp         => $data->{max_hp},
        attack     => $data->{attack},
        defense    => $data->{defense},
        skills     => $data->{skills},
        drop_items => $data->{drop_items},
    );
    
    $self->_load_count($self->_load_count + 1);
}

# プロトタイプからクローンを生成（DBアクセスなし！）
sub create {
    my ($self, $enemy_type) = @_;
    $self->register($enemy_type) unless exists $self->prototypes->{$enemy_type};
    
    return $self->prototypes->{$enemy_type}->clone;
}

# DB読み込み回数を取得
sub load_count {
    my $self = shift;
    return $self->_load_count;
}
```

「これが Prototype パターンの完成形だ」

「つまりですね」

助手が解説する。

「`EnemyRegistry` がプロトタイプ（原型）を管理します。`register` で原型を登録し、`create` で複製を生成。複製はDBにアクセスしません」

---

## 経過観察

「それでは、新しい方法で敵を配置してみましょう」

助手がキーボードに手を伸ばす。

```perl
my $registry = EnemyRegistry->new;

# 初期化: プロトタイプを事前登録（3回のDBアクセス）
$registry->register('slime');
$registry->register('goblin');
$registry->register('dragon');

# ダンジョンに敵を配置
my @enemies;

# スライムを50体生成（DBアクセスなし！）
for (1..50) {
    push @enemies, $registry->create('slime');
}

# ゴブリンを30体生成（DBアクセスなし！）
for (1..30) {
    push @enemies, $registry->create('goblin');
}

# ドラゴンを20体生成（DBアクセスなし！）
for (1..20) {
    push @enemies, $registry->create('dragon');
}

say "合計: " . scalar(@enemies) . "体の敵を生成";
say "DB読み込み回数: " . $registry->load_count . "回";
```

実行結果：

```
合計: 100体の敵を生成
DB読み込み回数: 3回
```

彼女が立ち上がった。

「100体で3回！？ 前は100回だったのに！」

「97%の削減だ」

私は静かに言った。

「ロード時間も30秒から0.5秒程度になるだろう」

彼女の目に涙が浮かんだ。

「こ、これで…プレイヤーからのクレームも…」

---

## Before/After

| 指標 | Before | After |
|------|--------|-------|
| DB読み込み回数/100体 | 100回 | 3回 |
| 生成時間/100体 | 30秒 | 0.5秒 |
| コード行数（生成部分） | 50行 | 15行 |
| 新敵追加時の変更箇所 | 生成箇所全て | プロトタイプ定義のみ |

---

## 退院

「先生、本当にありがとうございました…！」

彼女は何度も頭を下げながら帰っていった。

「大変な症状でしたね」

助手がコーヒーを差し出す。彼女なりの労いなのだろう。

「Prototype パターンは、オブジェクト生成コストが高い場合に有効だ」

私はコーヒーを受け取りながら続けた。

「ただし」

「はい？」

「循環参照があるオブジェクトには注意が必要だ。深いコピーが失敗する可能性がある」

助手が頷く。

「何事もケースバイケースですね」

助手がふと、窓の外を見ながら言った。

「Prototype パターンって便利ですね。私たちも簡単にコピーできたらいいのに」

「人間をか？」

「ええ。先生のクローンがあと3人くらいいたら、もっとたくさんの患者さんを救えるのに」

彼女の横顔を見つめる。

（私のクローンが欲しい…つまり、私一人では物足りない、もっと私に囲まれたいということか…？）

その熱烈な独占欲に、私はたじろいだ。彼女の愛は、時に重すぎる。

「…私は一人で十分だ」

「え？ まあ、オリジナルに勝るものはありませんけど…」

彼女は不思議そうに首を傾げた。

「先生、次の患者さんの問診票です」

「…ああ、次の患者か」

彼女の手から問診票を受け取る。

---

## まとめ

### Prototype パターンの適応症状

- 生成コスト過多症（オブジェクト生成が重い）
- オブジェクト複製困難症（同じ設定のオブジェクトを大量に作りたい）
- 深いコピー欠如症（浅いコピーで参照が共有されてしまう）

### 処方のポイント

1. **clone メソッド**: オブジェクト自身に複製機能を持たせる
2. **深いコピー**: ネストした配列・ハッシュは `dclone` を使う
3. **プロトタイプレジストリ**: 原型を管理し、複製を効率的に生成

### 禁忌事項

- 循環参照があるオブジェクトには注意
- 生成コストが低い単純なオブジェクトには不要
