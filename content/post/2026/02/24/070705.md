---
categories:
  - design-pattern
  - tech
date: 2026-02-24T07:07:05+09:00
draft: true
epoch: 1771884425
image: /favicon.png
iso8601: 2026-02-24T07:07:05+09:00
tags:
  - iterator
  - perl
  - refactoring
  - code-doctor
  - design-pattern
title: コードドクター【Iterator】内部実装依存性多臓器不全〜万能ホバークラフト〜
---

深夜のオフィスに、警告音が鳴り響いていた。

「クソッ、また『Not an ARRAY reference』だ！ 配列だって言っただろ！」

俺はモニターを睨みつけ、キーボードを叩きつけた。42歳にもなって、こんな初歩的なエラーで足止めを食らうとは。
俺たちが開発している音楽ストリーミングサービスは、急激な仕様変更の波に飲まれていた。これまでは単純な曲リスト（配列）だけを扱っていればよかったが、外部API連携やら、複雑な条件付きのプレイリストやら、次々と新しいデータ構造が持ち込まれている。

「データ構造が変わっただけで、何百箇所ものループを書き直せって言うのか？ ループなんて `for` で回せばいいだけだろ！」

俺の怒号が静まり返ったフロアに吸い込まれた瞬間、空調の音がふっ、と止まった。

チロリロ、チロリロ……。

背後から、古びたオルゴールの音が聞こえる。一定のリズムで、狂いなく刻まれる旋律。
振り返ると、いつの間にかそこに二人の影があった。
白衣を纏った無精髭の男と、ナース服の女性。男は手回し式のオルゴールを回し続けている。

「……不整脈（Arrhythmia）」

男がボソリと呟いた。
「ループの鼓動が乱れていますね。不整脈の疑いがあるそうです」

「誰だ！ あんたたちは。今忙しいんだ、プレイリストの改修で……」
「ドクター、この方のコード、呼吸（ループ）が止まりそうです」

女性――助手のナナコさんが、俺の制止も聞かずにモニターを覗き込む。
ドクターと呼ばれた男は、オルゴールを止めると、無遠慮に俺のデスクに近づいてきた。

## 検査：内部実装への不法侵入

ドクターは俺の手からキーボードを奪い取ると、恐ろしい速さでコードをスクロールさせた。そして、ある一行で指を止める。
まるで、汚物でも見るような目つきだった。

「……野蛮（Barbaric）だ」
「なんて乱暴な……。見るに堪えない、と嘆いておられます」

彼が指差したのは、俺が書きなぐったばかりのこのコードだ。

```perl
package MusicPlayer;
use v5.36;

sub new($class) {
    bless { log => [] }, $class;
}

sub play_all($self, $songs) {
    # 悪い点: 配列リファレンスであることを前提としている
    # 悪い点: インデックスアクセスによる密結合
    for (my $i = 0; $i < $songs->@*; $i++) {
        my $song = $songs->[$i];
        
        # 処理: 再生ログに記録（実際の再生の代わり）
        push $self->{log}->@*, "Playing: " . $song->{title};
    }
}
```

「はあ？ これが一番効率的な書き方だぞ！ インデックスで直接アクセスして何が悪い！」

俺が反論すると、ドクターは冷ややかな視線を俺に向けた。

「カプセル化（Encapsulation）の欠如」
「へ？」
「土足で他人の家に上がり込んで、勝手に冷蔵庫を開けるようなものです……と、ドクターは激怒しています」

ナナコさんが穏やかな口調で通訳する。しかし、その目は笑っていない。

「相手が更衣室（プライベートな内部構造）にいても、ノックもせずにズカズカ入ろうとしていると。もし相手が配列じゃなくて、リンクリスト（未舗装の道）やAPIストリーム（水路）だったらどうするんですか？」

「そ、そういうわけじゃ……ただ中身を順番に見たいだけで……」
「抽象化（Abstraction）」

ドクターが短く切り捨てる。

「『中身』ではなく『振る舞い』を見るのです。相手が配列かどうかなんて、些末なことだそうですよ」

「インターフェース（Interface）抽出」
「ただ『次はありますか？』『次のものをください』と聞くだけでいい……それがスマートな付き合い方だそうです」

## 処置：共通語（インターフェース）の確立

「癒着（Adhesion）剥離」
「ベッタリ張り付いた依存関係……今すぐ切り離さないと危険ですね」

ドクターの手が動いた。その手つきは、先ほどまでの乱暴さとは打って変わり、精緻な外科手術のようだった。
彼はまず、新しいファイルを作成した。

```perl
package Iterator;
use v5.36;

# Interface Definition
# Subclasses must implement these methods

sub has_next($self) { die "Method 'has_next' must be implemented by subclass" }
sub next($self)     { die "Method 'next' must be implemented by subclass" }

1;
```

「インターフェース定義」
「メソッドが……空っぽじゃないか」
「契約（Contract）による設計」
「中身なんて空っぽで構いません。『約束』さえ守ってくれれば信頼できる、とのことです」

さらにドクターは、俺が愛用していた配列処理を、この「約束」に従う形に包み込んだ。

```perl
package PlaylistIterator;
use v5.36;
use parent 'Iterator';

sub new($class, $songs) {
    bless {
        songs => $songs,
        index => 0,
    }, $class;
}

sub has_next($self) {
    return $self->{index} < $self->{songs}->@*;
}

sub next($self) {
    return $self->{songs}->[$self->{index}++];
}

1;
```

そして最後に、問題の `MusicPlayer.pm` にメスを入れる。
そこから、`for` ループとインデックス変数 `$i` が消滅した。

```perl
package MusicPlayer;
use v5.36;

sub new($class) {
    bless { log => [] }, $class;
}

sub play_all($self, $iterator) {
    # 改善点: 具体的なデータ構造（配列など）に依存しない
    # Iteratorインターフェース（プロトコル）に従うものなら何でも受け入れる
    while ($iterator->has_next) {
        my $song = $iterator->next;
        push $self->{log}->@*, "Playing: " . $song->{title};
    }
}
```

「な、なんだこれは…… `->next` だけで次が出てくる……！ 配列なのかハッシュなのか気にしなくていいのか！？」

俺の前で、複雑に絡み合っていた血管（スパゲッティコード）が、整然としたバイパス手術によって綺麗に流れ始めたような感覚だった。

「多態性（Polymorphism）による隠蔽」
「中身が何であろうと関係ない。ただ流れてくるものを受け入れればいい……ドクターの美学ですね」
「ええ、その通りですね」

ドクターがキーボードから手を離すと、警告音が止まり、テストスイートが静かに緑色（PASS）に変わった。

## 予後：正しい距離感

「疎結合（Loose Coupling）の維持」

ドクターはそう言い残し、黒い鞄を閉じた。
その言葉が、俺の胸に深く突き刺さる。

「相手の腹の中（内部実装）を覗くなんて、無粋なことはやめてくださいね。『距離感』こそが、長続きの秘訣だそうです」

ナナコさんが補足する。距離感。そうだ、俺がつい深入りしすぎて、相手のすべてを把握しようとしたから……あの子も離れていったのかもしれない。

「ドクター……俺、変わります！ 今度は相手を尊重して……あなたのように！」

俺は感極まり、ドクターの手にすがりつこうとした。

「……」

ドクターは無言で、俺の手をさっと避けた。
その目は「馴れ馴れしい」と語っていた。

「あ、その『距離感』も大事にしてくださいね。お大事にー」

ナナコさんが処方箋を俺の手に押し付け、二人は風のように去っていった。
残された俺の手には、Iteratorパターンの実装ガイドが握られていた。

---

## 処方箋まとめ

| 症状 | 適用すべき | 経過観察 |
| :--- | :---: | :---: |
| コルクションの内部構造（List, Stack, Tree等）を隠蔽して走査したい | ✓ | |
| 複数の異なるコレクションを、統一的な方法で走査したい | ✓ | |
| 複雑な順序（逆順、フィルタリング済み等）で走査したい | ✓ | |
| 単純な配列のみを扱い、将来的な変更も絶対にない | | ✓ |

### 治療のステップ

1.  **Iteratorインターフェースの定義**: `has_next` と `next` メソッドを持つ共通の型（Role/Base Class）を定義する。
2.  **Concrete Iteratorの実装**: 具体的なコレクション（配列など）を包み込み、Iteratorインターフェースを実装するクラスを作成する。
3.  **Clientの修正**: ループ処理を `for ($i=0...)` から `while ($it->has_next)` に書き換え、コレクションの実装詳細への依存を断つ。

### 助手より

配列のインデックスアクセスは高速ですが、それに依存しすぎると変更に弱いコードになってしまいます。「次の要素をください」という会話（インターフェース）を通すことで、どんなデータ構造が来ても動じない、大人の余裕を持ったコードになりますよ。頑張ってくださいね！
