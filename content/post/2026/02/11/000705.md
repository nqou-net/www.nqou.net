---
date: 2026-02-11T00:07:05+09:00
description: 「具体クラス依存症」に苦しむ通知システム。コードドクターによるFactory Methodパターンの処方箋とは？
draft: false
epoch: 1770736025
image: /favicon.png
iso8601: 2026-02-11T00:07:05+09:00
tags:
- code-doctor
- design-patterns
- factory-method
- refactoring
title: コードドクター〜通知システム緊急手術（Factory Method）
toc: true
---

## 来院：深夜の通知音

午前2時。私は震える手で、路地裏にひっそりと佇む「コード診療所」のドアを叩いた。カフェインの過剰摂取で、指先が上手く動かない。

「もう……限界なんです。明日リリースなのに……」

通された診療所の中は、ツンとする消毒液の匂いと、微かな除光液の香りが漂っていた。私は充血した目で訴えながら、乱暴にラップトップを開く。そこには、つぎはぎだらけで複雑に入り組んだ通知システムのコードが映し出されていた。

「マーケティングチームから『LINE通知を追加して』『次はSlack通知だ』と言われるたびに、`NotificationService`クラスを修正しなければなりません。条件分岐が肥大化して、デグレの恐怖で夜も眠れないんです……」

白衣をまとったドクターは、無言でモニターを覗き込んだ。その眼光は、まるで私の心の弱さまで見透かすように、コードの深淵にある病巣を鋭く見据えている。

傍らに立つナース服の助手さんは、怯える私にホットタオルを差し出しながら、ドクターの手にカルテを渡した。

## 触診：具体クラス依存症

ドクターは一瞬だけ眉をひそめ、短く呟いた。

「……硬い」

すかさず助手さんが翻訳してくれる。

「ドクターは『コードの密結合が著しく、拡張に対する柔軟性が欠落している』と……あ、いえ、『ガチガチに固まっていて直しにくい』と仰っています。具体的には、この部分ですね」

```perl
package NotificationService;

sub new {
    my $class = shift;
    return bless {}, $class;
}

sub send {
    my ($self, $n_type, $message) = @_;
    if ($n_type eq 'email') {
        my $email = EmailNotification->new();
        $email->send($message);
    } elsif ($n_type eq 'sms') {
        my $sms = SMSNotification->new();
        $sms->send($message);
    }
    # 新しい通知タイプが増えるたびに、ここを修正する必要がある
}
```

「まさにこれです！」私は思わず身を乗り出した。「新しい通知を追加するたびに、この巨大な`if-else`ブロックをいじらなきゃいけない。テストも全部やり直しです」

ドクターはキーボードを叩く真似をして、指を止めた。

「直せ」

「はい、ドクター」助手さんが優しく微笑み、私に向き直る。「診断結果が出ました。『**急性具体クラス依存症**』です。`NotificationService`が、`EmailNotification`や`SMSNotification`といった具体的なクラスに直接依存してしまっているのが原因ですね」

「治るんでしょうか……？」

「大丈夫ですよ、ここはコード診療所。どんな症状も治療します」

彼女のその言葉は、いつもの決まり文句なのかもしれないが、藁にもすがる思いの私には福音に聞こえた。

## 処方箋：Factory Methodパターン

「今回の処方箋は『**Factory Methodパターン**』です」

助手さんは棚からネイルチップのサンプルケースを取り出し、カチャリと机に置いた。中には色とりどりのネイルチップが整然と並んでいる。

「イメージしてください。ネイルサロンでお客様が『今日は赤いネイルで』と注文したとします。その時、ネイリストはいちいちプラスチックを溶かして型に流し込んだりはしませんよね？ 『赤いネイルのケース』から既製品を取り出すだけです」

「はぁ……なんとなく」

「今の患者さんのコードは、注文が入るたびに工場でプラスチックを調合しているようなものです。そうではなく、『製品（ネイル）を取り出す箱（Factory）』を種類ごとに用意してあげればいいんです」

ドクターがモニター上のコードを指差す。

「インターフェース」

「そうですね」助手さんが頷く。「まずは、生成される製品（Product）と、それを生成する工場（Creator）のインターフェースを定義しましょう」

### Step 1: 製品の抽象化

```perl
# Product: 全ての通知の共通インターフェース
package Notification;

sub send {
    die "Abstract method 'send' must be implemented";
}

# Concrete Product: 具体的な通知実装
package EmailNotification;
use parent -norequire, 'Notification';

sub new {
    my $class = shift;
    return bless {}, $class;
}

sub send {
    my ($self, $message) = @_;
    print "Sending Email: $message\n";
}

package SMSNotification;
use parent -norequire, 'Notification';

sub new {
    my $class = shift;
    return bless {}, $class;
}

sub send {
    my ($self, $message) = @_;
    print "Sending SMS: $message\n";
}
```

### Step 2: 工場の抽象化

「次に、これらを作る工場の定義です」

```perl
# Creator: 工場のインターフェース
package NotificationFactory;

sub create_notification {
    die "Abstract method 'create_notification' must be implemented";
}

# Concrete Creator: 具体的な工場
package EmailNotificationFactory;
use parent -norequire, 'NotificationFactory';

sub new {
    my $class = shift;
    return bless {}, $class;
}

sub create_notification {
    return EmailNotification->new();
}

package SMSNotificationFactory;
use parent -norequire, 'NotificationFactory';

sub new {
    my $class = shift;
    return bless {}, $class;
}

sub create_notification {
    return SMSNotification->new();
}
```

## 外科手術：依存の逆転

「さあ、いよいよ手術（リファクタリング）です」

助手さんがUVライトを点灯させるような手つきで、メインのコードを照らし出した。

「`NotificationService`が自分で『何を作るか』を判断するのではなく、外部から『適切な工場』を渡してもらうように変更します」

```perl
# Client Code
sub broadcast {
    my ($factory, $message) = @_;
    # どの通知が作られるかは知らないが、とりあえず作って送る
    my $notification = $factory->create_notification();
    $notification->send($message);
}
```

「これなら！」私の声が弾んだ。「新しい通知タイプが増えても……」

「ええ。新しい`Notification`の実装と、それに対応する`Factory`を作るだけ。既存の`Broadcast`関数には指一本触れる必要はありません」

これが『**開放閉鎖の原則（Open/Closed Principle）**』——拡張に対しては開いていて、修正に対しては閉じている状態だ。

## 術後経過：平穏な夜

リファクタリングを終えたコードは、まるで丁寧にケアされた爪先のように美しく整っていた。それを見た私の震えは、いつの間にか止まっていた。

「これで、もう夜中に叩き起こされることもありませんね」

帰り際、助手さんが二つのマグカップと、三種類のコーヒー豆のパッケージをトレイに乗せてやってきた。

「ドクター、お疲れ様でした。今日は『キリマンジャロ』『ブルーマウンテン』、そして私が独自にブレンドした『ミッドナイト・スペシャル』の三つのFactoryを用意しました。どのインスタンスを生成しますか？」

その言葉に、ドクターの手がピクリと止まる。彼は『ミッドナイト・スペシャル』のパッケージを凝視し、何か信じられないものでも見るような目をした。

「……これだ」

「ふふ、やっぱりそれを選ぶと思いました。眠気覚ましに効きますよ」

ドクターは無表情のままカップを受け取ったが、その指先は心なしか震えているように見えた。あるいは感動しているのだろうか？ 深夜専用のブレンドに対するこだわりが、職人の琴線に触れたのかもしれない。

私はそんな不思議な二人を後に、軽くなったラップトップと足取りで診療所を後にした。

二人のやり取りの意味はよく分からなかったが、ドクターが最後にモニターに向かって呟いた言葉だけは、はっきりと聞こえた。

「感謝は、このコードに」

---

## 処方箋まとめ

### Factory Methodパターンの適用基準

| 症状 | 適用すべき | 経過観察 |
|------|-----------|----------|
| 生成すべきクラスが実行時までわからない | ✓ | |
| 新しい製品（機能）を既存コードを変更せず追加したい | ✓ | |
| ライブラリのユーザーにクラスを拡張させたい | ✓ | |
| 生成する製品の種類が固定で増える見込みがない | | ✓（単純なnewで十分） |

### 治療のステップ
1.  **製品の抽象化（Product）**: 全ての製品が持つべき共通インターフェース（例：`Notification`）を定義する。
2.  **工場の抽象化（Creator）**: 製品を生成するメソッド（例：`create_notification`）を持つインターフェースを定義する。
3.  **具体的な工場（Concrete Creator）**: 製品ごとに専用の工場（例：`EmailNotificationFactory`）を用意し、対応する製品を生成する。
4.  **クライアントの修正**: 直接`new`せず、工場クラスを通じて製品を受け取るように変更する（依存性の注入）。

