---
title: Perlで作るAbstract Factory - 装備生成の迷宮と３つの工場
date: 2026-02-11T00:43:22+09:00
categories:
  - Perl
  - Design Pattern
tags:
  - Abstract Factory
  - Code Doctor
image: 
---

## 往診

深夜2時。モニターのブルーライトだけが照らすワンルームマンション。
僕は机に突っ伏して、冷え切ったコーヒーの横で頭を抱えていた。壁には描きかけのキャラクター設定画や武器のラフスケッチが所狭しと貼られている。

「……なんでだ。盗賊（Thief）クラスを追加しただけなのに、どうして戦士（Warrior）が杖を持って生まれてくるんだ！？」

個人製作のRPG。それが僕の夢だ。プログラムもデザインもシナリオも、全部一人で作る。「動けば正義」を合言葉に、思いつくまま機能を追加してきた。
でも今、僕のコードは限界を迎えていた。新しい職業を追加するたびに、全く関係ないはずの既存の職業の挙動がおかしくなるのだ。

その時、玄関のインターホンも鳴らさずに、静かにドアが開いた。
振り返ると、黒い鞄を持った白衣の男性と、看護師風の女性が立っていた。鍵は掛けていたはずなのに。

「ひっ、誰ですか！？ 不法侵入で通報しますよ！」

僕が椅子から転げ落ちそうになると、白衣の男――コードドクターは無表情のまま部屋を見回し、ボソリと言った。

「悲鳴が、聞こえた。」

「落ち着いてください」
女性が穏やかな笑みを浮かべてフォローに入る。
「こちらはコード診療所。あなたのコミットログから、助けを求める信号を確かに受信しました。……かなり、深刻な状態のようですね」

## 診断

ドクターは僕の返事も待たずに椅子に座ると、エディタ画面を指で弾いた。
画面に映っていたのは、装備品を管理する `EquipmentManager.pm` クラスだ。

### 患部：増築を重ねた条件分岐の塔

「これです……。職業ごとに適切な武器と防具をセットするメソッドなんですが」

僕が恐る恐る説明すると、ドクターは眉間に深い皺を寄せた。

```perl
package Game::Bad::EquipmentManager;

sub create_equipment($self, $job_type) {
    my $equipment = {};

    # 共通処理のつもりで書いたが、実は職業ごとに微妙に違うので if が増殖
    if ($job_type eq 'Warrior') {
        $equipment->{weapon} = 'Mighty Sword';
        $equipment->{armor}  = 'Heavy Plate';
        $equipment->{skill}  = 'Slash';
    }
    elsif ($job_type eq 'Mage') {
        $equipment->{weapon} = 'Old Staff';
        $equipment->{armor}  = 'Silk Robe';
        $equipment->{skill}  = 'Fireball';
    }
    elsif ($job_type eq 'Thief') {
        $equipment->{weapon} = 'Dagger';
        $equipment->{armor}  = 'Leather Mail';
        # BUG: コピペミスで Mage のスキルを上書きしてしまう恐れがあったり、
        # ここに共通処理を書くと Warrior に影響したりする。
        $equipment->{skill}  = 'Steal';
    }
    else {
        die "Unknown job type: $job_type";
    }

    # 苦し紛れの共通処理
    $equipment->{bgm} = 'Battle_Theme_v1.mp3';

    return $equipment;
}
```

たった一つのメソッドに、戦士、魔法使い、そして新入りの盗賊のロジックが詰め込まれている。最初は数行だったのが、仕様変更のたびに `elsif` が増え、今や視界に収まりきらない。

「……サイクロマティック複雑度、限界突破（オーバーフロー）。」

ドクターが吐き捨てるように言った。

「条件分岐が複雑に入り組みすぎて、誰も構造を把握できない状態だと言っています」
助手の女性が通訳する。
「まるで、一度入ったら二度と出られない迷宮だと。新しい部屋――つまり新しい職業を追加しようとするたびに、迷宮の構造が変わって、他の部屋への通路まで塞いでしまっている状態です」

「で、でも、一つの場所にまとめた方が管理しやすいと思って……」

「混ぜるな。危険。」

ドクターの言葉は短いが、重かった。

## 外科手術

「手術を始める。……工場を、建てる。」

「え？ 工場？」

ドクターは凄まじい速度でキーボードを叩き始めた。
既存の巨大な `create_equipment` メソッドを容赦なく削除し、代わりに新しいファイルを次々と作成していく。

### 処方：専門工場の設立（Abstract Factory）

「いいですか」助手が解説する。「あなたは今、よろず屋の店主に全ての職業の装備を用意させようとしています。でも、その店主は戦士の剣も魔法使いの杖も区別がつかなくなっています。だから、**職業専門の工場**を作るのです」

ドクターの手によって、コードが生まれ変わっていく。

```perl
use v5.36;

# --- Abstract Factory (工場の設計図) ---
package Game::Factory {
    # インターフェース定義：全ての工場はこのメソッドを持たなければならない
    sub create_weapon($self) { die "Abstract" }
    sub create_armor($self)  { die "Abstract" }
}

# --- Concrete Factories (専門工場) ---

# 戦士のための装備を作る専門工場
package Game::Factory::Warrior {
    use parent -norequire, 'Game::Factory';
    
    # 戦士用の製品セット（剣とプレートアーマー）を生成
    sub create_weapon($self) { Game::Weapon::Sword->new }
    sub create_armor($self)  { Game::Armor::Plate->new }
}

# 魔法使いのための装備を作る専門工場
package Game::Factory::Mage {
    use parent -norequire, 'Game::Factory';
    
    # 魔法使い用の製品セット（杖とローブ）を生成
    sub create_weapon($self) { Game::Weapon::Staff->new }
    sub create_armor($self)  { Game::Armor::Robe->new }
}
```

「これが **Abstract Factory** パターンです。関連するオブジェクトの生成ルールを、ひとつの工場クラスにカプセル化します」

そして、ドクターは製品（武器・防具）のクラス定義も整理し、最後にそれらを使うクライアントコードを書き換えた。

```perl
# --- Client (キャラクター) ---
package Game::Character {
    sub new($class, $factory) {
        my $self = bless {}, $class;
        # 工場を使って装備を整える（具体的なクラス名は知らなくていい）
        $self->{weapon} = $factory->create_weapon;
        $self->{armor}  = $factory->create_armor;
        return $self;
    }

    sub show_status($self) {
        my $w_action = $self->{weapon}->attack;
        my $a_action = $self->{armor}->defend;
        return "Action: [$w_action] / Defense: [$a_action]";
    }
}

package main;

# 「戦士工場」に依頼すれば、戦士セットができあがる
my $warrior_factory = Game::Factory::Warrior->new;
my $warrior = Game::Character->new($warrior_factory);
say "[Warrior] " . $warrior->show_status;

# 「魔法使い工場」に依頼すれば、魔法使いセットができあがる
my $mage_factory = Game::Factory::Mage->new;
my $mage = Game::Character->new($mage_factory);
say "[Mage]    " . $mage->show_status;
```

画面からあの忌まわしい `if` の連鎖が消え去った。
代わりに現れたのは、整然と並んだ「工場」と、それを利用するシンプルなキャラクタークラス。

「なんてことだ……『戦士の工場』に頼めば、戦士の装備一式がセットで届く！ もう組み合わせを間違える心配がない！」

僕は思わず叫んでいた。これなら、盗賊を追加したければ `Game::Factory::Thief` を作るだけでいい。既存の戦士や魔法使いのコードに指一本触れる必要がないんだ。

## 術後経過

手術が終わり、静寂が戻った。
ドクターはふと、僕の机の上にあるマグカップに目を留めた。昨日から飲みかけで放置してあった、表面に怪しい膜が張り始めたコーヒーだ。

ドクターは無言でマグカップを持ち上げると、流し台へ行き、中身を捨てて丁寧に洗い始めた。
スポンジで執拗なまでに汚れを落とし、キュッキュッと音が鳴るまで濯ぐ。

「（ドクター……僕の健康を気遣って、古いコーヒーを捨ててくれたのか？ なんて不器用な優しさなんだ……！）」

僕が感動に打ち震えていると、助手が小声で囁いた。

「ただ単に、汚れたカップが許せなかっただけですよ。あの人、カプセル化されていない不衛生な状態が大嫌いですから」

洗い終わったカップを完璧な角度で棚に戻し、ドクターは呟いた。

「秩序。維持せよ。」

その言葉は、コードに対しても、僕の生活に対しても向けられている気がした。

「新しい職業を追加する時は、新しい工場を建てるだけです。既存の工場には触れないでくださいね」
助手が微笑みながら、一枚のメモを渡してくれた。

---

## 処方箋まとめ

| 症状 | 適用すべき | 経過観察 |
| :--- | :---: | :---: |
| 関連する複数のオブジェクトをまとめて生成したい | ✓ | |
| 生成ロジックに条件分岐が多く、拡張が困難 | ✓ | |
| オブジェクトの生成手順が単純である | | ✓ |

### 治療のステップ

1.  **工場の抽象化**: `create_weapon` などの生成メソッドを持つ `AbstractFactory` (またはRole) を定義する。
2.  **専門工場の建設**: 具体的な組み合わせ（戦士用、魔法使い用など）を生成する `ConcreteFactory` を実装する。
3.  **ラインの切り替え**: クライアントコード（Game::Character）が、具体的なクラス名（Swordなど）ではなく、工場（Factory）経由でオブジェクトを取得するように修正する。
4.  **拡張**: 新しいバリエーションが必要になったら、新しい `ConcreteFactory` を追加する（既存コードは修正しない）。

### 助手より

やりたいことが溢れてくると、つい一つの場所に処理を詰め込みたくなりますよね。でも、それはコードの動脈硬化の始まりです。
「工場」を建てるのは少し手間に感じるかもしれませんが、その手間が将来のあなたを、果てしないデバッグ地獄から救ってくれますよ。
あなたの作るRPG、完成を楽しみにしていますね。
