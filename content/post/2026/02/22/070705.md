---
categories:
  - tech
date: 2026-02-22T07:07:05+09:00
description: コピペで増殖した3つのエクスポート関数を、Template Methodパターンで「処理の骨格」に統一する。コードドクターシリーズ。
draft: true
epoch: 1771711625
image: /favicon.png
iso8601: 2026-02-22T07:07:05+09:00
tags:
  - design-pattern
  - perl
  - template-method
  - code-doctor
title: コードドクター【Template Method】臓器クローン症候群〜標準手術プロトコル策定〜
---

## 往診：コピペの末路

金曜日の夕方17時。定時退社のチャイムが鳴り響く中、僕――瀬戸（せと）は3枚のモニターに映った3つのサブルーチンを睨みつけていた。

`export_csv()`、`export_json()`、`export_xml()`。

社内ツールのデータエクスポート機能。最初はCSVだけだった。それが「JSON形式もお願い」「XMLでも出せる？」と追加依頼が飛んできて、僕はそのたびに元のコードをコピペし、フォーマット部分だけ書き換えてきた。

結果、600行。3つの関数が瓜二つの顔でモニターに並んでいる。

「瀬戸くん、またCSVのヘッダーが重複してるって報告来てるよ」

上司の声が背中に刺さる。先週、JSON側のバリデーションを修正したとき、CSV側に反映するのを忘れた。3つの関数を手作業で同期し続ける日々に、僕の精神は限界を迎えていた。

「もう無理だ……どれがどれの最新版かすらわからない……」

額をデスクに押し付けた瞬間、背後で聞き慣れない足音がした。

「壊疽……放置すれば全身に回る」

弾かれるように振り返ると、白衣の男が僕のモニターを覗き込んでいた。黒い往診鞄を提げ、画面に映る3つの関数を冷たい目で見下ろしている。

「あの……どちら様ですか？」

僕が椅子ごと後ずさると、白衣の男の後ろから助手らしき女性が一歩前に出た。

「大丈夫ですよ、ここはコード診療所です……あ、いえ、往診ですね」

助手のナナコさんは穏やかに微笑んだが、僕の警戒心は解けなかった。こんな時間に、アポもなく現れる白衣の男女。どう見ても不審者だ。

## 触診：三つ子の臓器

ドクターは僕を無視して椅子に座ると、モニターの前で3つの関数をスクロールし始めた。指がコードの上を滑るように動き、ときどき止まっては何かをブツブツ呟いている。

やがて、ドクターは3つの関数を画面上に並べ、共通する行をハイライトしていった。データ取得、バリデーション、ログ出力――驚くほど多くの行が同じだった。差異はフォーマット変換の部分、わずか十数行だけ。

```perl
# export_csv() から抜粋
sub export_csv ($self, $table_name) {
    # データ取得（3関数で同一）
    my @rows = $self->{db}->fetch_all($table_name);
    die "No data found in $table_name" unless @rows;

    # バリデーション（3関数で同一）
    for my $row (@rows) {
        for my $key (keys $row->%*) {
            $row->{$key} //= '';
        }
    }

    # ここだけが違う: CSV変換
    my @headers = sort keys $rows[0]->%*;
    my $output = join(",", @headers) . "\n";
    for my $row (@rows) {
        my @values = map {
            my $v = $row->{$_};
            $v =~ s/"/""/g;
            qq{"$v"};
        } @headers;
        $output .= join(",", @values) . "\n";
    }

    # ログ出力（3関数で同一）
    my $count = scalar @rows;
    print "Exported $count rows from $table_name as CSV\n";

    return $output;
}
```

ドクターが短く言い放った。

「クローン臓器……3つ。同期不全」

「く、クローン？」

ナナコさんがすかさず通訳してくれた。

「瀬戸さん、ドクターは『同じ臓器のコピーが体内に3つある状態だ』とおっしゃっています。1つを治療しても、残り2つにも同じ手術が必要になる……それが今のバグの原因ですね」

図星だった。僕は苦し紛れに反論した。

「で、でも手順が微妙に違うんです！ CSVはカンマ区切りで、JSONは構造体で……」

ドクターは無言でモニターを指差した。ハイライトされた共通部分が画面の大半を占めている。差異はほんの一部。僕の言い訳が、いかに的外れだったか、一目瞭然だった。

「骨格は同じ……皮だけ違う」

## 処方：標準手術プロトコル策定 (Template Method)

ドクターは新しい手袋を装着すると、鞄から黒いUSBメモリを取り出した。

「プロトコル策定……骨格を1つに」

### 患部摘出：共通組織の分離

ドクターの指が動き始めた。3つの関数に散らばっていた共通処理が、1つの基底クラスに集約されていく。

```perl
package DataExporter;
use v5.36;

sub new ($class, %args) {
    return bless {
        db => $args{db} // die "db is required",
    }, $class;
}

# Template Method: エクスポート処理の骨格を定義
sub export ($self, $table_name) {
    my @rows = $self->_fetch_data($table_name);
    $self->_validate(\@rows);
    my $output = $self->_header(\@rows);
    $output   .= $self->_format(\@rows);
    $output   .= $self->_footer(\@rows);
    $self->_log($table_name, scalar @rows);
    return $output;
}

# 共通ステップ: データ取得
sub _fetch_data ($self, $table_name) {
    my @rows = $self->{db}->fetch_all($table_name);
    die "No data found in $table_name" unless @rows;
    return @rows;
}

# 共通ステップ: バリデーション
sub _validate ($self, $rows) {
    for my $row ($rows->@*) {
        for my $key (keys $row->%*) {
            $row->{$key} //= '';
        }
    }
}

# フックメソッド: ヘッダー（デフォルトは空）
sub _header ($self, $rows) { return '' }

# 抽象メソッド: フォーマット変換（サブクラスが実装必須）
sub _format ($self, $rows) {
    die ref($self) . " must implement _format()";
}

# フックメソッド: フッター（デフォルトは空）
sub _footer ($self, $rows) { return '' }

# 共通ステップ: ログ出力
sub _log ($self, $table_name, $count) {
    my $format = ref($self) =~ s/.*:://r;
    print "Exported $count rows from $table_name as $format\n";
}
```

ナナコさんが解説を添えた。

「 `export()` メソッドが **手術の手順書** です。『データを取って、検証して、変換して、記録する』という流れは固定。でも **変換の仕方だけ** は、臓器ごと……つまり形式ごとに違いますよね。そこだけを各専門医に任せるんです」

僕はモニターを見つめた。 `_fetch_data`、`_validate`、`_log` ――あの3つの関数に散らばっていた共通コードが、たった1箇所に収まっている。

「これが **骨格** ……？」

「はい。この骨格のことを、 **テンプレートメソッド** と呼びますよ」

### 臓器再建：専門組織の委譲

ドクターは続けて、形式ごとのサブクラスを作り始めた。

「分離完了……各臓器に専門機能だけ移植」

```perl
package DataExporter::CSV;
use v5.36;
use parent 'DataExporter';

sub _format ($self, $rows) {
    my @headers = sort keys $rows->[0]->%*;
    my $output = join(",", @headers) . "\n";

    for my $row ($rows->@*) {
        my @values = map {
            my $v = $row->{$_};
            $v =~ s/"/""/g;
            qq{"$v"};
        } @headers;
        $output .= join(",", @values) . "\n";
    }

    return $output;
}
```

```perl
package DataExporter::JSON;
use v5.36;
use parent 'DataExporter';

sub _format ($self, $rows) {
    my @json_rows;

    for my $row ($rows->@*) {
        my @pairs;
        for my $key (sort keys $row->%*) {
            my $v = $row->{$key};
            $v =~ s/\\/\\\\/g;
            $v =~ s/"/\\"/g;
            push @pairs, qq{    "$key": "$v"};
        }
        push @json_rows, "  {\n" . join(",\n", @pairs) . "\n  }";
    }

    return "[\n" . join(",\n", @json_rows) . "\n]\n";
}
```

ナナコさんが続けた。

「CSV専門医は CSV の変換だけ、JSON専門医は JSON の変換だけを担当します。共通の手順は親クラスの `export()` が管理しているので、各専門医はフォーマット変換に集中できるんですよ」

### 安全弁：任意処置オプションの追加

ドクターはさらにもう1つ、XMLエクスポーターを作成した。こちらは少し違う。

```perl
package DataExporter::XML;
use v5.36;
use parent 'DataExporter';

# フックメソッドのオーバーライド: XML宣言をヘッダーに
sub _header ($self, $rows) {
    return qq{<?xml version="1.0" encoding="UTF-8"?>\n<records>\n};
}

sub _format ($self, $rows) {
    my $output = '';

    for my $row ($rows->@*) {
        $output .= "  <record>\n";
        for my $key (sort keys $row->%*) {
            my $v = $row->{$key};
            $v =~ s/&/&amp;/g;
            $v =~ s/</&lt;/g;
            $v =~ s/>/&gt;/g;
            $output .= "    <$key>$v</$key>\n";
        }
        $output .= "  </record>\n";
    }

    return $output;
}

# フックメソッドのオーバーライド: 閉じタグをフッターに
sub _footer ($self, $rows) {
    return "</records>\n";
}
```

「フック……安全弁」

ドクターが短く言った。ナナコさんが補足する。

「 `_header()` と `_footer()` は **フックメソッド** といって、デフォルトでは何もしません。でもXMLのように『宣言が必要』な形式だけが、自分でオーバーライドできるようになっています。全員に強制しない **オプション処置** のようなものですね」

僕は呆然としていた。あの600行が、基底クラス1つと3つの小さなサブクラスに凝縮されている。

「消えた……あの600行が……」

## 術後経過：手順書の安心感

テストを実行すると、全てグリーンに点灯した。しかもテストコードも整理されている。共通のテストは1セットだけ、形式固有のテストは各サブクラスごと。もう「3箇所修正」の悪夢はない。

僕はふと、気になっていたことを聞いた。

「もし新しい形式……例えばYAMLが必要になったら？」

ナナコさんが微笑んだ。

「 `DataExporter::YAML` というサブクラスを1つ追加して、 `_format()` を実装するだけですよ。骨格には一切触れません」

その言葉を聞いて、僕の肩から力が抜けた。もう「コピペして微調整」しなくていい。新しい形式が来ても「フォーマット変換だけ書く」。それだけで済む。

ドクターが帰り支度を始めた。その時、僕のデスクに置いてあった缶コーヒーが目に入ったらしい。ドクターは缶を手に取り、周囲をキョロキョロと見回した。ゴミ箱を探しているようだったが、見つからなかったのか、無言で僕に缶を差し出した。

「あ……先生、ありがとうございます」

僕は受け取りながら胸が熱くなった。あんなに無愛想な人なのに、こういう不器用な優しさがある。きっと「お疲れ様」の代わりなのだろう。

ナナコさんが何か言いかけたが、小さく首を振って、そのまま荷物をまとめ始めた。ドクターは怪訝そうな顔で僕を見ていたが、すぐに興味を失ったように背を向けた。

「感謝は、このコードに」

僕は缶コーヒーを握りしめて頷いた。

「手順書を大切にします。もうコピペはしません！」

ナナコさんが最後に振り返って言った。

「お大事に、瀬戸さん。『同じことを二度書きたくなったら、それは骨格を探すサイン』ですよ」

二人が去ったオフィスで、僕は新しいサブクラスのファイルを開いた。 `DataExporter::YAML` ――明日の朝、上司に報告するのが少しだけ楽しみだった。

---

## 処方箋まとめ

| 症状 | 適用すべき | 経過観察 |
| :--- | :---: | :---: |
| 同じ処理手順のコードが複数箇所にコピペされている | ✓ | |
| アルゴリズムの骨格は共通だが、一部のステップだけ異なる | ✓ | |
| サブクラスごとにオプションの拡張点が必要 | ✓ | |
| 処理の流れ自体がケースごとに大きく異なる | | ✓ |

### 治療のステップ

1. **骨格の抽出**: 共通の処理手順を基底クラスのテンプレートメソッドにまとめる。
2. **抽象メソッドの定義**: サブクラスが実装すべきステップを抽象メソッドとして宣言する。
3. **サブクラスの作成**: 各バリエーション（CSV, JSON, XML等）ごとにサブクラスを作り、抽象メソッドを実装する。
4. **フックメソッドの検討**: 全サブクラスに必須ではないが、一部だけが利用するオプション処理にはフックメソッドを用意する。

### 助手より

「似たコードをコピペして少し変える」――忙しい現場では誰もがやりがちですよね。でもそれは、治療が必要な臓器を増やしているのと同じです。
Template Methodパターンを使えば「処理の流れ」を1箇所で管理できるので、修正漏れの心配がなくなります。骨格はしっかり守りつつ、違う部分だけを自由に書き換える。そんなバランス感覚を、ぜひ日々のコードに活かしてくださいね！
