---
categories:
  - tech
date: 2026-02-09T07:07:05+09:00
description: Perl v5.36のstate変数を使ったシングルトンパターンの実装。設定ファイルの多重読み込みや状態の不整合（指揮系統の混乱）を防ぐモダンな設計手法を、医療ドラマ風メタファーで解説。
draft: false
epoch: 1770588425
image: /public_images/2026/code-doctor-singleton/header.png
iso8601: 2026-02-09T07:07:05+09:00
tags:
  - perl
  - code-doctor
  - singleton
  - design-pattern
title: 'コードドクター: Singleton - 多重人格症候群と唯一の真実'
toc: true
---

この雑居ビルの地下に、奇妙な診療所があるという噂を聞いたのは先週のことだ。
「コード診療所」。かつてネイルサロンだったらしいその場所は、看板こそ手書きだが、業界の重鎮たちがこぞって通っているらしい。

私は大規模Webサービスの基盤チームリーダーとして、ある深刻な症状に悩まされていた。システムの設定値が、場所によって食い違うのだ。
「指揮官が複数いて、現場が混乱している」
そんな状態を打開すべく、私は重い足取りでそのドアを叩いた。

---

## 来院

ドアを開けると、そこはカオスと秩序が同居する空間だった。
待合室にはオライリーの動物本や技術書が乱雑に積まれているが、受付カウンターだけは極限まで整理整頓されている。

「予約されていたエンジニア様ですね。お待ちしておりました」

現れたのは、機能的だが品のあるオフィスカジュアルに身を包んだ助手だった。名札には「ナナコ」とある。
診察室に通されると、そこに「彼」はいた。
トリプルディスプレイに囲まれ、HHKBを叩く音だけが響く。こちらを振り返りもしない。

「あの、ドクター？」
「……（タイピング音）」

（EIZOのモニターに、特注と思われるキーボード。弘法筆を選ばずと言うが、彼は徹底的に道具を選ぶタイプか……正直、最初の印象は最悪だ。クリエイターを気取った変人にしか見えない）

ナナコさんが困ったように微笑む。

「コードドクターは、集中しているときは周りが見えなくなるタイプでして……」

私が観察を続けていると、ドクターは突然手を止め、無言で空いている椅子を指差した。

「はい。では、患部を見せていただけますか？」

ナナコさんがそう促してくれて、ようやく診察の体裁が整った。

## 診断

私はラップトップを開き、問題のコードを見せた。
システム全体で利用される `Config` クラスの実装だ。

```perl
package Bad::Config;
use v5.36;

sub new ($class) {
    # シミュレーション: 設定ファイル読み込み（重い処理）
    my $config_data = {
        database => 'mysql://localhost:3306/app',
        timeout  => 30,
        debug    => 1,
        loaded_at => time(),
    };
    
    return bless $config_data, $class;
}
```

このクラスが、アプリケーションの至る所で `Bad::Config->new` されている。
ドクターは画面を高速でスクロールさせ、ある2箇所を指で弾いた。
A機能のコントローラーと、バッチ処理のスクリプトだ。

「多重人格。」

ドクターが呟いたのは、それだけだった。
私が困惑していると、ナナコさんが穏やかに解説を挟む。

「ドクターは、システムがアイデンティティ・クライシスを起こしている症状だと診断されました。設定という名の『記憶』が乖離し、現場が混乱している状態ですね」

「あっ……！」

確かに、A機能では古い設定がキャッシュされ、バッチ処理では新しい設定が読み込まれていた。
`new` を呼ぶたびにファイルIOが走り、それぞれが独立したインスタンスとして存在している。これでは「真実」が複数存在することになる。

「指揮官が複数いて、それぞれ勝手な命令を出している……そういうことですか？」
「その通りです。リソースの無駄遣いでもありますね」

ドクターは無言で頷き、キーボードに手を置いた。

「執刀する。」

## 処置

ドクターの手捌きは、まるでピアニストのようだった。
無駄な動きが一切ない。彼が切開したのは、わずかな行数だけだった。

### 執刀

```perl
package Good::Config;
use v5.36;

# 良い実装: state変数を使ったシングルトン
sub new ($class) {
    # state変数: 一度だけ初期化され、値を保持し続ける（Perl 5.10+）
    state $instance;

    # すでにインスタンスがあればそれを返す
    return $instance if defined $instance;

    # 初回のみ生成
    my $config_data = {
        database => 'mysql://prod-db:3306/app',
        timeout  => 60,
        debug    => 0,
        loaded_at => time(),
    };

    $instance = bless $config_data, $class;
    return $instance;
}
```

「これは…… `state` ？」

私が身を乗り出すと、ドクターはモニターを指差した。

「state。」

ナナコさんがすかさず補足する。

「Perl 5.10から導入された機能ですね。v5.36では標準で有効になっています。一度だけ初期化され、その値を永続的に保持する——いわば『魂の器』のようなものです。クロージャを使わなくても、メソッド内で静的変数を表現できるんですよ」

ナナコさんの説明と同時に、ドクターがテストコードを実行する。

```perl
subtest 'Good Code: Singleton (Cure)' => sub {
    my $config1 = Good::Config->new;
    my $config2 = Good::Config->new;

    # 全く同じインスタンスである（参照が一致）
    is $config1, $config2, 'References should be identical';
    
    # データも当然同じ
    is $config1->{loaded_at}, $config2->{loaded_at}, 'Loaded timestamps should be identical';
};
```

`PASS` の文字が緑色に輝く。
何度 `new` を呼んでも、返ってくるのは最初に生成された「唯一の」インスタンスだ。これなら、どこから呼んでも同じ設定値が保証される。

「Single Source of Truth。これで指揮系統は一本化されましたね」

ナナコさんが、画面を見ながら安堵の表情を浮かべた。

## 予後

システム構成は劇的に改善された。
無駄なIOはなくなり、設定の不整合によるバグも消滅した。
私は深く頭を下げた。

「ありがとうございます。これほど鮮やかな執刀、勉強になりました」

その時、ふとドクターがナナコさんを見た。

「ナナコ。珈琲。」

ナナコさんは慣れた様子で微笑む。

「はい、はい。患者さんの分もお持ちしますね」

私がその様子を見ていると、ドクターが突然立ち上がり、こちらに近づいてきた。
そして無言で、私の手のひらに何か小さな黒い物体を握らせた。

「……？」

それは、プラスチック製の小さなキャップのようだった。
私はハッとした。

（これは……彼が愛用しているUSBメモリの保護キャップ？ いや、これはメタファーだ。システムを守るための『鍵』、あるいは『蓋』……。私に、このシステムの守護者たれというメッセージなのか？）

ドクターが満足げに頷いているように見えた。私の胸は熱くなった。

「受け取りました、ドクター。この重み、決して忘れません」

私が感動に震えながら診療所を出ると、背後で助手の困ったような声が聞こえた。

「ドクター、今の。」
「……？」
「患者さんの自転車の鍵のキャップ、返し忘れてますよ。……あ、もう行っちゃった」

---

## 処方箋まとめ

| 症状 | 適用すべき | 経過観察 |
| :--- | :---: | :---: |
| 設定ファイルなど、システムで単一であるべき情報が散乱している | ✓ | |
| `new` のコストが高く、何度も生成したくない | ✓ | |
| グローバル変数を使いたいが、汚染は防ぎたい | ✓ | |
| ステートレスなユーティリティクラス | | ✓（クラスメソッドで十分） |

### 治療のステップ

1.  **管理クラスの特定**: 設定、DB接続、ログハンドラなど、単一であるべきリソースを特定する。
2.  **`state` 変数の導入**: コンストラクタ内で `state $instance` を宣言する。
3.  **ガード節の設置**: `$instance` が定義済みなら即座にリターンする。
4.  **単一化**: 初回呼び出し時のみ初期化を行い、`$instance` に格納する。

### 助手より

お疲れ様でした。
Singleton は強力なパターンですが、使いすぎると「隠れた依存関係」を生み出し、テストを難しくする副作用もあります（まさに強い薬ですね）。
必要な場所にのみ、用法・用量を守ってお使いくださいね。
ドクターも、言葉足らずですが、あなたのシステムの健康を誰よりも願っていますよ。
