---
date: 2026-02-10T00:45:32+09:00
description: 「コネクション数が上限に達しました…もう動きません…」深夜の診療所に運び込まれた重症患者。原因は、無秩序な `new` による無限インスタンス増殖症だった。
draft: false
epoch: 1770651932
image: /favicon.png
iso8601: 2026-02-10T00:45:32+09:00
tags:
  - code-doctor
  - design-patterns
  - singleton-pattern
  - perl
title: コードドクター〜DB接続マネージャ緊急手術（Singleton）
---

## 冒頭：深夜の緊急搬送

「先生、患者さんです！」

助手の声が、静まり返った診療所に響いた。元ネイルサロンだった店舗を改装したこの場所は、深夜になると本来の診療所らしい空気を取り戻す。ネイル用のカラーチャートがまだ壁に残っているのは、彼女のこだわり——というよりは単に外す時間がなかっただけだろう。

患者は蒼白な顔で、モニターには不気味なエラーログが流れ続けていた。

**「コネクション数が上限に達しました」**

私の口から、自然と一言がこぼれた。

「重症」

助手は困った笑みを浮かべながら、患者を診察台へと誘導した。

「患者さん、大丈夫ですよ。まずは症状を聞かせてください」

---

## 第1章：問診——なぜDB接続は「重い」のか

患者は震える声で語り始めた。

「ユーザーが増えてきたんです。それで、データベースにアクセスする処理を追加していったら……ある日突然、サーバーが止まって……」

私は患者のコードをチラリと見た。問題は明白。

```perl
# 患者のコード（Before）
package DBManager_Before;
use strict;
use warnings;

sub new {
    my $class = shift;

    # 毎回新しいインスタンス（接続）を作成してしまう
    my $self = {
        connection_id => int(rand(10000)),
        status        => 'connected',
    };
    return bless $self, $class;
}

sub query {
    my ($self, $sql) = @_;
    return "Result for '$sql' from Connection #" . $self->{connection_id};
}

1;
```

「典型的な症状」

私が呟くと、助手がすかさず補足した。

「つまりですね、`new`するたびに新しいDB接続を作ってしまっているんです。接続を作るのって、すごく重い処理なんですよ」

患者は首をかしげた。

「重い……って、どういうことですか？」

「コスト」

私は一言だけ答えた。助手が補足する。

「DB接続には、認証やネットワークの確立など、たくさんの手順が必要なんです。毎回その手間をかけていたら、サーバーのリソースはあっという間に枯渇してしまいますよ」

私は診断結果を書き留めた。

---

## 第2章：診断——無限インスタンス増殖症

| 症状 | 深刻度 | 現在の状態 |
|------|--------|------------|
| 無限インスタンス増殖症 | 重症 | 接続数: 無制限 |
| リソース競合不全症 | 中症 | 接続状態: 管理不能 |
| グローバル汚染症候群 | 軽症 | アクセスポイント: 不明確 |

「病名は**無限インスタンス増殖症**」

患者の顔がさらに青ざめた。

「そ、そんな恐ろしい……」

「恐ろしくはない」

私は淡々と続けた。

「治療法がある。処方箋は——Singletonパターン」

「シングルトン……？」

助手が患者の肩に手を置いた。

「ざっくり言うと、『このクラスのインスタンスは、世界に1つしか存在させない』という仕組みです」

---

## 第3章：手術——Singletonの処方

「手術を始める」

私はキーボードに手を置いた。

```perl
# 処方後のコード（After）
package DBManager_After;
use strict;
use warnings;
use Scalar::Util qw(refaddr);

# 唯一のインスタンスを保持する変数
my $INSTANCE;

sub new {
    my $class = shift;

    # 既存のインスタンスがあればそれを返す
    return $INSTANCE if $INSTANCE;

    # 新規作成（初回のみ）
    my $self = {
        connection_id => int(rand(10000)),
        status        => 'connected',
    };
    $INSTANCE = bless $self, $class;
    return $INSTANCE;
}

# 明示的なアクセスメソッド（推奨）
sub instance {
    my $class = shift;
    return $class->new(@_);
}

sub query {
    my ($self, $sql) = @_;
    return "Result for '$sql' from Connection #" . $self->{connection_id};
}

1;
```

「終わった」

患者は目を丸くした。

「え……こ、これだけ？」

「シンプルこそ最良の治療」

助手が画面を指差しながら解説を始めた。

「ポイントは3つあります」

1. **唯一のインスタンスを保持する変数** (`my $INSTANCE`) を用意する
2. **`new`の中で、既存インスタンスをチェック**して、あれば返す
3. 明示的なアクセスポイントとして **`instance`メソッド** を用意する

「`new`を呼んでも、2回目以降は同じインスタンスが返ってくるんですよ」

---

## 第4章：術後確認——テストで証明

「しかし、本当に1つなのか確認したい」

患者が不安そうに呟いた。もっともな疑問。

「テストを見せる」

```perl
use strict;
use warnings;
use Test::More;
use Scalar::Util qw(refaddr);

# Before: 異なるインスタンスが生成される
subtest 'Symptoms: Infinite Instance Proliferation' => sub {
    my $conn1 = DBManager_Before->new();
    my $conn2 = DBManager_Before->new();

    isnt(refaddr($conn1), refaddr($conn2), 'Different instances created');
    isnt($conn1->{connection_id}, $conn2->{connection_id}, 'Connection IDs are different');
};

# After: 同一インスタンスが返される
subtest 'Treatment: Singleton Pattern' => sub {
    my $conn1 = DBManager_After->instance();
    my $conn2 = DBManager_After->instance();

    is(refaddr($conn1), refaddr($conn2), 'Same instance returned');
    is($conn1->{connection_id}, $conn2->{connection_id}, 'Connection IDs are identical');

    # 機能確認
    like($conn1->query('SELECT 1'), qr/Result for 'SELECT 1'/, 'Query method works');

    # new() を直接呼んでも同じインスタンス
    my $conn3 = DBManager_After->new();
    is(refaddr($conn1), refaddr($conn3), 'new() also returns the same instance');
};

done_testing();
```

テストはすべてパスした。

「Before では毎回異なるインスタンスが生成されていましたが、After では必ず同じインスタンスが返ってきていますね」

助手の説明に、患者の表情がようやく和らいだ。

---

## 第5章：退院——健全な接続管理へ

私は退院時の注意事項を伝えた。

「副作用がある」

患者の顔がまた強張った。

「ふ、副作用……！？」

「心配ない」

助手が苦笑いしながら補足した。

「心配しすぎですよ、患者さん。Singletonは便利ですが、使いすぎると別の問題を引き起こすことがあるんです」

**Singletonの注意事項**:

| リスク | 説明 |
|--------|------|
| テストの難しさ | グローバルな状態を持つため、モックへの差し替えが困難 |
| 密結合の温床 | どこからでもアクセスできるため、依存関係が見えにくくなる |
| スレッド安全性 | 並列処理でのインスタンス生成競合に注意 |

「将来的には、依存性注入（DI）への移行も検討してください」

患者は深くお辞儀をした。

「あ、ありがとうございました……」

---

## エピローグ：次の患者

患者を見送った後、助手がコーヒーを差し出してきた。

「先生、お疲れさまでした」

彼女なりの——。

いや、これは深読みしすぎか。単なる労いだ。そうに違いない。

「次の患者は」

「えーと……ファクトリーメソッドを求める症状ですね。オブジェクト生成のロジックがあちこちに散らばって困っているとか」

「生成の責務を分離する……か」

私はコーヒーを一口飲み、次の戦いに備えた。

コードの病を抱えるプログラマーは、まだまだ多い。私に救えるのなら——救い続けよう。

かつての私を、あのドクターが救ってくれたように。

> **次回予告**: コードドクター〜オブジェクト生成緊急手術（Factory Method）
