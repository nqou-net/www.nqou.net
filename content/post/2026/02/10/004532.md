---
date: 2026-02-10T00:45:32+09:00
description: 「コネクション数が上限に達しました…もう動きません…」深夜の診療所に運び込まれた重症患者。原因は、無秩序な `new` による無限インスタンス増殖症だった。
draft: false
epoch: 1770651932
image: /images/2026/02/10/004532.png
iso8601: 2026-02-10T00:45:32+09:00
tags:
  - code-doctor
  - design-patterns
  - singleton-pattern
  - perl
title: コードドクター〜DB接続マネージャ緊急手術（Singleton）
---

深夜2時。私は路地裏の雑居ビルにある「コード診療所」の前に立っていた。

古ぼけた看板。中から漏れ出る消毒液と微かな除光液の匂い。
「どんなバグも直す天才がいる」という噂を信じるしかなかった。私の携わっているWebアプリケーションは、今まさに呼吸停止寸前だったからだ。

恐る恐るドアを開けると、そこにはモニターの青白い光に照らされた二人の姿があった。

「あの……急患です！ DBサーバーが……もう息をしていません！」

## 来院：コネクション枯渇の悪夢

白衣を着た医師と思しき男は、私の悲鳴のような訴えにも動じることなく、静かにキーボードを叩き続けていた。
代わりに、傍らにいた看護師らしき女性がすぐに駆け寄ってくる。

「落ち着いてください。ここはコード診療所。どんな症状も治療します」

彼女の笑顔には、不思議と張り詰めた神経を緩ませる力があった。
私は震える手でラップトップを開き、エラーログを見せる。

「アクセスが増えるたびに『Too many connections』が出て……再起動してもすぐにまた同じ状態になるんです」

医師が椅子を回転させ、こちらを向く。
無精髭。鋭い眼光。その目は、私の顔ではなく、ディスプレイ上のコードを射抜くように見つめていた。

## 診断：無限インスタンス増殖症

医師は無言のまま、私のアプリケーションのDB接続処理周辺をスクロールしていく。
そして、ある一行で指を止めた。

「……増やすな」

低く、短い声。
すかさず看護師さんが通訳に入る。

「ドクターは『インスタンスの生成方法に問題がある』と仰っています」

問題のコードは、このようなものだった。

```perl
# 悪い例：使うたびにnewして接続を作ってしまっている
package UserHandler;
use DBManager;

sub hande_request {
    # リクエストのたびに新しいマネージャ（と接続）を作る
    my $db = DBManager->new(); 
    $db->query('SELECT * FROM users');
}

package ProductHandler;
use DBManager;

sub check_stock {
    # こっちでもまた新しく作る
    my $db = DBManager->new(); 
    $db->query('SELECT * FROM products');
}
```

医師は私を一瞥すると、短く告げた。

「クローン戦争だ」

「つまり、『**無限インスタンス増殖症**』です」看護師さんが補足する。「必要なのはデータベースへの接続窓口ひとつだけなのに、あなたはリクエストのたびに、あるいはクラスのたびに、新しい `DBManager` を `new` してしまっています。これではアクセス数に比例してコネクションが増え続け、いずれDBサーバーがパンクするのは当然です」

私は顔面蒼白になった。
「で、でも、どうすれば……毎回 `new` しないと使えないんじゃ……」

## 手術：たった一つの存在（Singleton）

医師はため息を一つつくと、やおら立ち上がり、私の肩に手を置いた。

「……オンリー・ワン」

彼は真剣な眼差しでそう言った後、ふと看護師さんの方を見た。
俺たちのことだろ、と言わんばかりの、どこか得意げな視線だ。

（えっ、どういう意味……？）

私が呆気にとられていると、看護師さんは至って事務的な調子で頷いた。

「はい、そうですね。プロセス内でインスタンスを『**唯一無二（Singleton）**』にします。何度呼ばれても、最初に作った一つだけを返すようにすればいいんです」

医師は一瞬、フッと満足げに口角を上げた。
「俺の想いは伝わった」とでも言いたげな顔だが、完全にスルーされている。
この診療所、なんだか空気がおかしい。

気を取り直して、医師の手術（リファクタリング）が始まった。

```perl
package DBManager;
use strict;
use warnings;

# クラス（パッケージ）レベルで変数を保持する
# これが「唯一のインスタンス」を格納する場所
my $single_instance;

sub new {
    my $class = shift;
    
    # まだ作られていない時だけ、新しく作る
    unless ($single_instance) {
        # 実際のDB接続処理など
        my $self = {
            dsn => 'dbi:mysql:dbname=mydb',
            # ...
        };
        $single_instance = bless $self, $class;
        print "--- 新しい接続を確立しました ---\n";
    }
    
    # 2回目以降は、作っておいたものをそのまま返す
    return $single_instance;
}

sub query {
    my ($self, $sql) = @_;
    print "Query実行: $sql\n";
}

1;
```

「Perlの場合、レキシカル変数 `my $variable` のスコープ（生存期間）を利用するのが一般的です」
看護師さんが解説してくれる間も、医師の手は止まらない。

修正されたコードを利用する側はこのようになる。

```perl
# 修正後の利用イメージ

# 1回目：ここでインスタンスが作られる
my $db1 = DBManager->new();
$db1->query('SELECT ...');

# 2回目：さっき作った $single_instance が返ってくるだけ（接続は増えない）
my $db2 = DBManager->new(); 
$db2->query('SELECT ...');

# $db1 と $db2 は全く同じ実体
if ($db1 == $db2) {
    print "世界に一つだけの花（インスタンス）です\n";
}
```

## 術後経過：静寂を取り戻したサーバー

修正をデプロイし、再起動する。
恐る恐るモニタリングツールを確認する。
アクセスが増えても、DBのコネクション数は「1」からピクリとも動かない。

「な、直りました……！ 負荷が嘘みたいに消えました！」

医師は深く椅子に腰掛け、熱くなったラップトップを閉じた。

「……感謝は、このコードに」

「ハイハイ、お疲れ様でした」
看護師さんは慣れた手つきで栄養ドリンクを医師のデスクに置くと、私に向き直った。

「Singletonパターンは強力な特効薬ですが、副作用もあります。**グローバルな状態** を作り出すことになるので、テストが難しくなったり、密結合の原因になったりもしやすいんです。用法・用量を守って使ってくださいね」

「は、はい！ 肝に銘じます！」

## 退院

帰り際、ふと気になって振り返ると、医師が栄養ドリンクの瓶を愛おしそうに眺めていた。
「……そんなに俺の体が心配か」

ボソリと呟き、フッと笑う横顔が見えた。
そんな独り言が聞こえた気がしたが、私は見なかったことにして夜の街へ駆け出した。
少なくとも、私のサーバーはもう孤独に死ぬことはないのだから。

---

## 処方箋まとめ

### Singletonパターンの適用基準

| 症状 | 適用すべき | 経過観察 |
|------|-----------|----------|
| プログラム全体でクラスのインスタンスを一つに保つ必要がある | ✓ | |
| グローバル変数を制御し、アクセス手段を一元化したい | ✓ | |
| グローバルな状態を持たせたいだけ | | ✓（安易な使用は避ける） |
| テストの容易さを優先したい | | ✓（DIなどで代替可能か検討） |

### 治療のステップ
1.  **コンストラクタの制限**: クラス外から勝手にインスタンスを生成できないようにする（Perlでは`new`内で制御）。
2.  **静的変数の用意**: 唯一のインスタンスを保持するためのクラス変数（例：`$single_instance`）を用意する。
3.  **インスタンス取得メソッド**: 常に同じインスタンスを返す静的メソッド（例：`getInstance`や調整した`new`）を実装する。
