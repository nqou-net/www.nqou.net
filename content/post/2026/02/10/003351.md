---
categories:
  - perl
  - design-pattern
  - code-doctor
date: 2026-02-10T00:33:51+09:00
description: 「新しいモンスターを追加するたびに、Gameクラスが悲鳴を上げるんです…」増殖するif文と密結合に悩むエンジニアに、コードドクターが処方したのは「生成ロジックの外部化（人工子宮）」だった。
draft: true
epoch: 1770651231
image: /favicon.png
iso8601: 2026-02-10T00:33:51+09:00
tags:
  - factory-method
  - object-oriented
  - refactoring
title: 'Perlで作るFactory Method - 癒着したコードを人工子宮で疎結合にする'
---

深夜26時のオフィスは、静まり返っているはずだった。
しかし僕、ヤマダのディスプレイの中では、Gitのコミットログが悲鳴を上げていた。

「なんでだよ……スライムのドロップ率を直しただけなのに、なんでドラゴンが出なくなるんだよ！」

明朝は大型アップデート「ダンジョン・エクスパンション」のリリース日。
目玉機能である「レアモンスター」の実装が、僕の書いた `Game.pm` の複雑骨折によって阻まれていた。
条件分岐の迷宮。修正するたびに別の場所が壊れる恐怖。

「……もう、無理だ」

机に突っ伏したその時、オフィスの自動ドアが音もなく開いた。

「悲鳴。」

冷徹な声に顔を上げると、白衣の男が立っていた。
無表情で長身の男。その背後には、ナース服を着た女性が穏やかな笑みを浮かべて控えている。
噂に聞く「コードドクター」だ。

「え、あ、呼んでませんけど」

「コードが呼んでいました。」
女性が、手に持ったタブレットを見せてくる。「あなたのリポジトリから、緊急要請信号が出ています。」

## 往診：石灰化した関節

ドクターは無言で僕の椅子を指差した。
僕が慌てて立ち上がると、彼は当然のように腰を下ろし、エディタをスクロールし始めた。

患部は `Game.pm` の `spawn_enemy` サブルーチンだ。初期は数十行だったそれは、度重なる仕様追加で1500行の怪物に成長していた。

```perl
# 患部：Game.pm
sub spawn_enemy ($self, $type) {
    my $enemy;
    
    # 典型的な条件分岐の爆発
    if ($type eq 'slime') {
        require Enemy::Slime;
        $enemy = Enemy::Slime->new;
    }
    elsif ($type eq 'dragon') {
        require Enemy::Dragon;
        # ドラゴンは初期化パラメータが違う…
        $enemy = Enemy::Dragon->new(hp => 5000, color => 'red');
    }
    elsif ($type eq 'goblin') {
        require Enemy::Goblin;
        $enemy = Enemy::Goblin->new;
    }
    # ... 他に50種類以上の分岐 ...
    else {
        die "Unknown enemy type: $type";
    }
    
    # 共通処理に見せかけた個別対応
    if ($type eq 'dragon') {
        $enemy->吼える();
    } else {
        $enemy->scream();
    }
    
    return $enemy;
}
```

ドクターの動きが止まった。
画面を見る彼の眉間に、深い皺が刻まれる。人差し指がデスクを叩いた。カツ、カツ。

「……癒着。石灰化。」

「え？」

助手の女性が、僕に紅茶を差し出しながら解説する。
「『Gameクラスが全てのモンスタークラスと癒着している。条件分岐がカルシウムのように固着し、関節が動かない状態だ』とおっしゃっています。」

「で、でも、分岐しないと何を作るか決められないじゃないですか」

僕が反論すると、ドクターは一瞬だけ僕を見た。冷たい眼差しだ。
そして一言。
「生成は、責務だ。」

助手が補足する。「オブジェクトを使う側（Game）が、オブジェクトの作り方まで知っている必要はありません。それは余計な知識であり、依存です。新しいモンスターという『臓器』を移植するたびに、母体まで手術する必要があるのは異常事態なのです。」

## 処置：人工子宮の設置

「切除する。」

ドクターの指がキーボードの上で踊り始めた。
彼の処置は、破壊的かつ建設的だった。

まず、`Game.pm` からモンスター生成ロジックをすべて引き剥がしていく。
そして、新しいファイル `EnemyFactory.pm` を作成した。

「設置するのは、人工子宮（Factory）だ。」

### Step 1: Factoryの作成

ドクターが書き上げたのは、驚くほどシンプルなモジュールだった。

```perl
# 処方：EnemyFactory.pm
package EnemyFactory;
use v5.36;

# 登録されたクラスを管理する（今回はハッシュで簡易実装）
my %registry;

sub register ($class, $type, $target_class) {
    # 動的にモジュールをロードするならここでrequireしてもいい
    eval "require $target_class" or die $@;
    $registry{$type} = $target_class;
}

sub create ($class, $type) {
    my $target_class = $registry{$type};
    unless ($target_class) {
        die "Factory Error: No class registered for '$type'";
    }
    # 各クラスは共通のインターフェース（new）を持つ前提
    return $target_class->new;
}

1;
```

「これが……人工子宮？」

「そうです」助手が頷く。「どんな種類のモンスターでも、ここを通せば産み出せる。Gameクラスは『何が産まれるか』を知る必要がなくなり、『産んでくれ』と頼むだけでよくなります。」

### Step 2: 患部の切除と結合

次にドクターは、肥大化した `Game.pm` をメスでえぐるように削除していった。
1500行あった分岐は、たった数行に凝縮された。

```perl
# 術後：Game.pm
package Game;
use v5.36;
use EnemyFactory;

sub spawn_enemy ($self, $type) {
    # 依存関係は完全に断ち切られた
    my $enemy = EnemyFactory->create($type);
    
    # 共通インターフェースで操作する
    $enemy->scream();
    
    return $enemy;
}
```

「うわ、すっかすかだ……！」

「疎結合、です」助手が訂正する。

「でもドクター、これだと誰も『どのクラスを使うか』を知らないことになりませんか？ どこかで設定しないと」

ドクターは無言で `main.pl` （あるいは初期化スクリプト）を開き、設定コードを記述した。

```perl
# 初期化プロセス（アプリケーション起動時など）
use EnemyFactory;

# ここで初めて「具体的に何を使うか」を紐付ける
EnemyFactory->register('slime',  'Enemy::Slime');
EnemyFactory->register('dragon', 'Enemy::Dragon');
# 新しいモンスターを追加する時も、Game.pmには触らなくていい
EnemyFactory->register('rare_slime', 'Enemy::RareSlime');
```

「構成は、一度だけ。」

「なるほど……。使う場所（Game）と、構成する場所（Main）を分けるんですね」

## 予後：柔軟な身体

修正されたコードを実行してみる。
テストは見事にパスした。新しい「レアスライム」を追加しても、`Game.pm` にはもはや指一本触れる必要がない。
ただ新しいクラスを作り、Factoryに登録するだけだ。

「すごい……。体が（コードが）軽いよ」

僕が感動して呟くと、ドクターは立ち上がった。
鞄を手に取り、出口へと向かう。

「あの、ありがとうございました！」

僕は思わず手を差し出した。
ドクターが立ち止まり、振り返る。僕の手元をじっと見た。
そして、おもむろに手を伸ばしてくる。

（握手してくれるのか……！？）

胸が熱くなったその時、ドクターは僕が握りしめていたエナジードリンクの空き缶をひょいと摘み上げ、ゴミ箱に放り投げた。

「毒。」

「えっ」

空中に残された僕の手。

「カフェインの過剰摂取は判断力を鈍らせます」助手が同情的な苦笑いを浮かべた。「ドクターなりの、健康指導ですよ」

「あ……はい。水飲みます」

「お大事に。ここはコード診療所、いつでもどうぞ」

二人が去った後のオフィスは、来た時よりも少しだけ明るく見えた。
ディスプレイの中には、整然としたコミットログと、静かに回る人工子宮（Factory）が残されていた。

---

## 処方箋まとめ

| 症状 | 適用すべき | 経過観察 |
| :--- | :---: | :---: |
| 条件分岐で生成するクラスを切り替えている | ✓ | |
| 新しい種類を追加するたびに既存コード修正が必要 | ✓ | |
| 生成ロジックが単純（引数なし） | | ✓ |

### 治療のステップ

1.  **Creator（Factory）インターフェースの定義**: 生成メソッド（`create`）を持つクラスまたはモジュールを作成する。
2.  **Concrete Creatorの実装**: 具体的なクラス（Product）を生成するロジックをFactory内にカプセル化する。
3.  **Client（Game）の修正**: `new` を直接呼ばず、Factory経由でインスタンスを取得するように変更する。
4.  **Registration**: 必要に応じて、識別子（key）とクラス（value）の対応関係を登録する仕組みを作る。

### 助手より

Factory Methodは、オブジェクトの「生成」と「使用」を切り離すための基本的なパターンです。
Perlではモジュール名を変数で扱えるため、JavaやC#よりも柔軟に実装できますが、無法地帯になりがちでもあります。Factoryという「管轄部署」を作ることで、コードの秩序を守ってくださいね。
カフェインは程々に、まずはゆっくり休んでください。
