---
title: "コミット履歴を整理したい！git rebase -i でインタラクティブに履歴を編集"
draft: true
tags:
- "git"
- "git-rebase"
- "code-review"
- "best-practices"
- "workflow"
description: "プルリクエスト前にコミット履歴をきれいにしたい時の必須技術。インタラクティブrebaseで複数コミットの統合、順序変更、分割を自在に操る方法を実例豊富に解説。レビュアーに優しい履歴作りのコツも紹介します。"
---

## なぜコミット履歴を整理するのか

開発中は試行錯誤の連続です。「とりあえずコミット」「WIP」「typo修正」といったコミットが増えがちですが、そのままプルリクエストを出すと、レビュアーにとって分かりづらい履歴になってしまいます。

### レビュアビリティの向上

整理された履歴の利点：

- **変更の意図が明確**: 1コミット = 1つの論理的な変更
- **レビューしやすい**: 機能追加、リファクタ、バグ修正が分離
- **履歴が読みやすい**: 後から見返した時に理解しやすい
- **git bisectが有効**: 問題のある変更を特定しやすい

### 意味のある単位でのコミット分割

理想的な履歴の例：

```
feat: ユーザー認証APIを追加
test: 認証API用のテストを追加
refactor: パスワードハッシュ化ロジックを共通化
docs: 認証APIのドキュメントを更新
```

一方、整理前：

```
WIP
fix typo
とりあえず動いた
あとで直す
```

どちらがレビューしやすいかは明白ですね。

## git rebase -i の基本

インタラクティブリベース（`git rebase -i`）は、コミット履歴を自由に編集できる強力な機能です。

### インタラクティブモードの起動

```bash
# 過去3つのコミットを編集
git rebase -i HEAD~3

# 特定のコミット以降を編集
git rebase -i abc1234

# 現在のブランチの全コミットを編集（mainからの分岐点以降）
git rebase -i main
```

エディタが開き、対象コミットのリストが表示されます。

### pick, reword, edit, squash, fixup の使い分け

エディタには以下のような内容が表示されます：

```
pick abc1234 feat: ユーザー登録機能
pick def5678 fix typo
pick ghi9012 WIP
pick jkl3456 test: テスト追加

# Rebase commands:
# p, pick = use commit
# r, reword = use commit, but edit the commit message
# e, edit = use commit, but stop for amending
# s, squash = use commit, but meld into previous commit
# f, fixup = like "squash", but discard this commit's log message
# d, drop = remove commit
```

各コマンドの意味：

- **pick (p)**: コミットをそのまま使用
- **reword (r)**: メッセージのみを変更
- **edit (e)**: コミット内容を修正
- **squash (s)**: 前のコミットに統合（メッセージも統合）
- **fixup (f)**: 前のコミットに統合（メッセージは破棄）
- **drop (d)**: コミットを削除

## 実践：コミットの統合（squash/fixup）

### WIP コミットをまとめる

開発中の細かいコミットを1つにまとめます。

```
pick abc1234 feat: ユーザー登録機能
fixup def5678 fix typo
fixup ghi9012 WIP
pick jkl3456 test: テスト追加
```

これで「feat: ユーザー登録機能」に2つのWIPが統合されます。

### fixup と squash の違い

```
pick abc1234 feat: 新機能追加
squash def5678 追加のドキュメント
fixup ghi9012 typo修正
```

- **squash**: 両方のメッセージが統合され、編集できる
- **fixup**: 後のコミットメッセージは破棄される

typo修正など、メッセージが不要な場合は`fixup`が便利です。

## 実践：コミットの分割（edit）

1つのコミットを複数に分けたい場合は`edit`を使います。

### 手順

```bash
# rebase開始
git rebase -i HEAD~3
```

エディタで分割したいコミットを`edit`に変更：

```
pick abc1234 feat: 機能A
edit def5678 大きな変更（これを分割したい）
pick ghi9012 feat: 機能B
```

保存すると、そのコミット時点で一時停止します。

```bash
# コミットを取り消す（変更はワーキングツリーに残る）
git reset HEAD^

# 分割して個別にコミット
git add file1.js
git commit -m "refactor: モジュールAを整理"

git add file2.js
git commit -m "feat: 新機能を追加"

git add file3.js
git commit -m "test: テストを追加"

# リベースを続行
git rebase --continue
```

これで1つのコミットが3つに分割されました。

## 実践：コミットの並び替え

コミットの順序を変更できます。

```
pick abc1234 test: テスト追加
pick def5678 feat: 機能追加
pick ghi9012 docs: ドキュメント更新
```

これを論理的な順序に：

```
pick def5678 feat: 機能追加
pick abc1234 test: テスト追加
pick ghi9012 docs: ドキュメント更新
```

行を入れ替えて保存するだけです。

## コンフリクト解決とrebaseの中断・継続

### コンフリクトが発生した場合

```bash
# rebase中にコンフリクト
git rebase -i HEAD~5
# CONFLICT (content): Merge conflict in src/app.js

# コンフリクトを解決
vim src/app.js

# 解決したファイルをステージング
git add src/app.js

# rebaseを続行
git rebase --continue
```

### 途中で中断したい場合

```bash
# rebaseを中止して元に戻す
git rebase --abort
```

## autosquash で効率化

`--fixup`や`--squash`オプションでコミットを作成すると、後で自動的に統合できます。

### 使い方

```bash
# 元のコミット
git commit -m "feat: 新機能追加"

# 後で typo を発見
git add file.js
git commit --fixup HEAD

# または特定のコミットを指定
git commit --fixup abc1234

# 履歴を確認
git log --oneline
# def5678 fixup! feat: 新機能追加
# abc1234 feat: 新機能追加
```

rebase時に`--autosquash`を使うと自動的に統合されます：

```bash
git rebase -i --autosquash main
```

エディタが開くと、fixupコミットが自動的に適切な位置に配置されます。

### .gitconfigで常に有効化

```bash
git config --global rebase.autosquash true
```

こうすると`git rebase -i`で常にautosquashが有効になります。

## 実践例：プルリクエスト前の履歴整理

### 整理前の履歴

```bash
git log --oneline
ghi9012 docs更新
def5678 typo
abc1234 WIP: とりあえず動いた
bcd2345 ユーザー登録機能追加
cde3456 バリデーション追加
efg4567 あとで直す
```

### 整理手順

```bash
# rebase開始
git rebase -i main

# エディタで編集
pick bcd2345 ユーザー登録機能追加
fixup abc1234 WIP: とりあえず動いた
fixup efg4567 あとで直す
pick cde3456 バリデーション追加
fixup def5678 typo
reword ghi9012 docs更新
```

### 整理後の履歴

```bash
git log --oneline
hij0123 docs: ユーザー登録APIドキュメント追加
cde3456 feat: ユーザー登録バリデーション追加
bcd2345 feat: ユーザー登録機能追加
```

すっきりと読みやすくなりました！

## 注意点とベストプラクティス

### push済みのコミットは編集しない

**重要**: すでにリモートにpushしたコミットをrebaseすると、他の開発者に影響が出ます。

```bash
# 個人のfeatureブランチなら問題なし
git rebase -i main
git push --force-with-lease origin feature/my-branch

# 共有ブランチでは絶対にNG！
```

### コミットメッセージの規約

Conventional Commits形式を使うと統一感が出ます：

```
feat: 新機能追加
fix: バグ修正
docs: ドキュメント変更
refactor: リファクタリング
test: テスト追加・修正
chore: ビルド・ツール関連
```

## まとめ

インタラクティブリベースは、きれいなGit履歴を作る強力なツールです。

- **コミット統合**: `squash`/`fixup`でWIPをまとめる
- **コミット分割**: `edit`で1コミットを複数に分ける
- **並び替え**: 論理的な順序に整理
- **autosquash**: `--fixup`で後からの修正を効率化

プルリクエストを出す前に履歴を整理する習慣をつけると、レビュアーに優しく、将来の自分にも優しいコードベースになります。まずは個人のブランチで練習してみましょう！
