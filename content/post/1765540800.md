---
comments: true
date: 2025-12-12T12:00:00+09:00
description: レビューエージェントを構築してコード品質を自動的に検証し、セキュリティやパフォーマンスの問題を早期発見する方法を学びます
draft: true
hidden: false
image: /favicon.png
iso8601: 2025-12-12T12:00:00+09:00
license: ~
math: ~
tags:
  - github
  - copilot
  - ai
  - agent
  - code-review
  - quality
  - hands-on
series: "GitHub エージェントパネル実践ガイド"
title: 【第6回】レビューエージェントの構築 - 品質保証の自動化

---

[@nqounet](https://x.com/nqounet)です。

GitHub エージェントパネル実践ガイド第6回です。今回は、レビューエージェントを構築してコード品質を自動的に検証し、セキュリティやパフォーマンスの問題を早期発見する方法を学びます。

## この記事で学べること

- レビューエージェントの設定と活用
- 自動コードレビューの実装
- 品質メトリクスの測定方法
- セキュリティチェックの自動化
- パフォーマンス分析のポイント

## レビューエージェントの役割

レビューエージェントは、人間のコードレビュアーと同じ視点でコードを分析し、改善提案を行います。

### レビュー対象の5つの観点

```
1. 機能性（Functionality）
   → 要件を満たしているか

2. コード品質（Code Quality）
   → 読みやすさ、保守性、拡張性

3. セキュリティ（Security）
   → 脆弱性、セキュリティリスク

4. パフォーマンス（Performance）
   → 実行速度、リソース使用量

5. テスト（Testing）
   → テストカバレッジ、テストケースの妥当性
```

## AGENTS.md でレビュー基準を定義

プロジェクトルートの `AGENTS.md` にレビュー基準を記載：

```markdown
## code-reviewer エージェント

### 役割
コード品質の検証とレビュー

### レビュー基準

#### 1. 機能性（Critical）
- [ ] 要件を満たしているか
- [ ] エッジケースに対応しているか
- [ ] エラーハンドリングが適切か

#### 2. コード品質（High）
- [ ] DRY原則に従っているか
- [ ] 関数は単一責任か（1関数1責務）
- [ ] 命名は適切か（意図が明確）
- [ ] コメントは必要十分か

#### 3. セキュリティ（Critical）
- [ ] SQL インジェクション対策
- [ ] XSS 対策
- [ ] CSRF 対策
- [ ] 機密情報の漏洩なし
- [ ] 入力値の検証

#### 4. パフォーマンス（Medium）
- [ ] N+1 クエリ問題なし
- [ ] 不要なループ処理なし
- [ ] メモリリークの可能性なし

#### 5. テスト（High）
- [ ] カバレッジ70%以上
- [ ] エッジケースのテストあり
- [ ] モックの適切な使用

### レビューコメントの重要度

**Critical（必須修正）**:
- セキュリティリスク
- 機能不全
- データ損失の可能性

**High（強く推奨）**:
- コード品質の問題
- パフォーマンスの大幅な低下
- テストカバレッジ不足

**Medium（推奨）**:
- より良い実装パターンの提案
- 軽微なパフォーマンス改善
- 可読性の向上

**Low（参考）**:
- スタイルの統一
- タイポ
- ドキュメントの改善
```

## 実践例1: REST API のレビュー

### レビュー対象コード

```javascript
// src/controllers/userController.js
const User = require('../models/User');

const getUsers = async (req, res) => {
  const users = await User.findAll();
  res.json(users);
};

const createUser = async (req, res) => {
  const user = await User.create(req.body);
  res.json(user);
};

module.exports = { getUsers, createUser };
```

### レビューエージェントへのプロンプト

```
以下のコードをレビューしてください：

[コードを貼り付け]

レビュー観点:
- セキュリティ
- エラーハンドリング
- パフォーマンス
- コード品質

プロジェクトの AGENTS.md に記載された基準に従ってください。
```

### レビュー結果

```markdown
## コードレビュー結果

### 総合評価: C（改善が必要）

### Critical 指摘（必須修正）

#### 1. エラーハンドリングの欠如
**場所**: `getUsers`, `createUser` 関数

**問題**:
```javascript
const getUsers = async (req, res) => {
  const users = await User.findAll(); // エラーがキャッチされない
  res.json(users);
};
```

**リスク**:
- データベースエラー時にサーバーがクラッシュ
- クライアントに適切なエラーレスポンスが返らない

**推奨修正**:
```javascript
const getUsers = async (req, res) => {
  try {
    const users = await User.findAll();
    res.json(users);
  } catch (error) {
    logger.error('Failed to fetch users', { error: error.message });
    res.status(500).json({
      error: {
        message: 'Failed to fetch users',
        code: 'INTERNAL_SERVER_ERROR'
      }
    });
  }
};
```

#### 2. バリデーション不足
**場所**: `createUser` 関数

**問題**:
```javascript
const user = await User.create(req.body); // バリデーションなし
```

**リスク**:
- 不正なデータの挿入
- SQLインジェクション（ORM使用だが念のため）
- データ整合性の問題

**推奨修正**:
```javascript
const createUser = async (req, res) => {
  try {
    // バリデーション
    const { error, value } = userSchema.validate(req.body);
    if (error) {
      return res.status(400).json({
        error: {
          message: 'Validation failed',
          details: error.details
        }
      });
    }

    const user = await User.create(value);
    res.status(201).json(user);
  } catch (error) {
    // エラーハンドリング
  }
};
```

### High 指摘（強く推奨）

#### 3. ページネーションの欠如
**場所**: `getUsers` 関数

**問題**:
全ユーザーを一度に取得するとパフォーマンス問題が発生

**推奨修正**:
```javascript
const getUsers = async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;
    const offset = (page - 1) * limit;

    const { users, total } = await User.findAll({ limit, offset });

    res.json({
      data: users,
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit)
      }
    });
  } catch (error) {
    // エラーハンドリング
  }
};
```

#### 4. レスポンス形式の不統一
**問題**:
エラー時とSuccess時でレスポンス形式が異なる

**推奨修正**:
一貫したレスポンス形式を使用
```javascript
// 成功時
{
  "data": { /* データ */ },
  "meta": { /* メタ情報 */ }
}

// エラー時
{
  "error": {
    "message": "エラーメッセージ",
    "code": "ERROR_CODE",
    "details": []
  }
}
```

### Medium 指摘（推奨）

#### 5. ロギングの追加
APIアクセスログを記録することを推奨

```javascript
const getUsers = async (req, res) => {
  try {
    logger.info('Fetching users', { 
      requestId: req.id,
      userId: req.user?.id
    });
    
    const users = await User.findAll();
    
    logger.info('Users fetched successfully', {
      count: users.length
    });
    
    res.json(users);
  } catch (error) {
    // エラーハンドリング
  }
};
```

### 改善後のコード

```javascript
const User = require('../models/User');
const { userSchema } = require('../validators/userValidator');
const logger = require('../utils/logger');

/**
 * ユーザー一覧を取得（ページネーション対応）
 * @param {Object} req - Express request
 * @param {Object} res - Express response
 */
const getUsers = async (req, res) => {
  try {
    logger.info('Fetching users', { requestId: req.id });

    const page = parseInt(req.query.page) || 1;
    const limit = Math.min(parseInt(req.query.limit) || 20, 100);
    const offset = (page - 1) * limit;

    const { users, total } = await User.findAll({ limit, offset });

    logger.info('Users fetched successfully', {
      page,
      limit,
      total,
      returned: users.length
    });

    res.json({
      data: users,
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit)
      }
    });
  } catch (error) {
    logger.error('Failed to fetch users', {
      error: error.message,
      stack: error.stack
    });

    res.status(500).json({
      error: {
        message: 'Failed to fetch users',
        code: 'INTERNAL_SERVER_ERROR'
      }
    });
  }
};

/**
 * 新規ユーザーを作成
 * @param {Object} req - Express request
 * @param {Object} res - Express response
 */
const createUser = async (req, res) => {
  try {
    logger.info('Creating user', { requestId: req.id });

    // バリデーション
    const { error, value } = userSchema.validate(req.body, {
      abortEarly: false
    });

    if (error) {
      logger.warn('Validation failed', {
        errors: error.details.map(d => d.message)
      });

      return res.status(400).json({
        error: {
          message: 'Validation failed',
          code: 'VALIDATION_ERROR',
          details: error.details.map(detail => ({
            field: detail.path[0],
            message: detail.message
          }))
        }
      });
    }

    const user = await User.create(value);

    logger.info('User created successfully', {
      userId: user.id,
      email: user.email
    });

    res.status(201).json({
      data: user
    });
  } catch (error) {
    logger.error('Failed to create user', {
      error: error.message,
      stack: error.stack
    });

    // 重複エラーの場合
    if (error.code === 'ER_DUP_ENTRY') {
      return res.status(409).json({
        error: {
          message: 'User already exists',
          code: 'USER_EXISTS'
        }
      });
    }

    res.status(500).json({
      error: {
        message: 'Failed to create user',
        code: 'INTERNAL_SERVER_ERROR'
      }
    });
  }
};

module.exports = { getUsers, createUser };
```

### チェックリスト

#### 修正前
- [ ] エラーハンドリング
- [ ] バリデーション
- [ ] ページネーション
- [ ] ロギング
- [ ] レスポンス形式の統一

#### 修正後
- [x] エラーハンドリング
- [x] バリデーション
- [x] ページネーション
- [x] ロギング
- [x] レスポンス形式の統一
```

## セキュリティレビューの重点ポイント

### 1. 認証・認可

```javascript
// ❌ 悪い例
app.delete('/api/users/:id', async (req, res) => {
  await User.delete(req.params.id);
});

// ✅ 良い例
app.delete('/api/users/:id', 
  authenticateToken,      // 認証チェック
  authorizeAdmin,         // 権限チェック
  async (req, res) => {
    // 自分自身または管理者のみ削除可能
    if (req.user.id !== parseInt(req.params.id) && !req.user.isAdmin) {
      return res.status(403).json({ error: 'Forbidden' });
    }
    await User.delete(req.params.id);
  }
);
```

### 2. 入力検証

```javascript
// ❌ 悪い例
const search = req.query.q;
const users = await db.query(`SELECT * FROM users WHERE name LIKE '%${search}%'`);

// ✅ 良い例
const search = validator.escape(req.query.q);
const users = await db.query(
  'SELECT * FROM users WHERE name LIKE ?',
  [`%${search}%`]
);
```

### 3. 機密情報の取り扱い

```javascript
// ❌ 悪い例
const user = await User.findById(id);
res.json(user); // パスワードハッシュも含まれる

// ✅ 良い例
const user = await User.findById(id);
const { password, ...safeUser } = user;
res.json(safeUser);

// または
const user = await User.findById(id, {
  select: '-password -resetToken'
});
res.json(user);
```

## パフォーマンスレビューのチェックポイント

### 1. データベースクエリ最適化

```javascript
// ❌ 悪い例: N+1 問題
const users = await User.findAll();
for (const user of users) {
  user.posts = await Post.findByUserId(user.id); // N回クエリ
}

// ✅ 良い例
const users = await User.findAll({
  include: [{ model: Post }] // 1回のクエリで取得
});
```

### 2. 不要な処理の削減

```javascript
// ❌ 悪い例
const allUsers = await User.findAll();
const activeUsers = allUsers.filter(u => u.active);
res.json(activeUsers);

// ✅ 良い例
const activeUsers = await User.findAll({
  where: { active: true }
});
res.json(activeUsers);
```

## 自動レビューワークフロー

### ワークフロー設定例

```markdown
## 自動レビューワークフロー

1. コード生成
   ├─ implementation-agent がコード生成
   └─ 生成されたコードをステージング

2. 静的解析
   ├─ ESLint 実行
   ├─ TypeScript 型チェック
   └─ code-reviewer による分析

3. セキュリティチェック
   ├─ npm audit
   ├─ OWASP 依存関係チェック
   └─ security-checker エージェント

4. レビューレポート生成
   ├─ 問題の優先度付け
   ├─ 修正提案の生成
   └─ チェックリスト作成

5. 修正適用
   ├─ Critical/High の自動修正
   └─ レビュー結果の確認要求
```

## 次回予告

第7回「ドキュメント生成エージェントの設定」では、コードから自動的にドキュメントを生成し、常に最新のドキュメントを維持する方法を学びます。

具体的には：
- API ドキュメントの自動生成
- README やユーザーガイドの作成
- コードコメントとドキュメントの同期
- 多言語ドキュメントの管理

## チェックリスト

- [ ] レビューエージェントの設定を理解した
- [ ] AGENTS.md にレビュー基準を定義できた
- [ ] セキュリティレビューのポイントを理解した
- [ ] パフォーマンスレビューができるようになった
- [ ] 自動レビューワークフローを構築できた

---

**シリーズ目次**
1. [エージェントパネル入門](../1764676800/)
2. [エージェントパネルの基本操作](../1764849600/)
3. [最初のエージェント設定](../1765022400/)
4. [タスクプランニングエージェントの活用](../1765195200/)
5. [コード生成エージェントの実践](../1765368000/)
6. **レビューエージェントの構築**（本記事）
7. ドキュメント生成エージェントの設定
8. マルチエージェント連携
9. カスタムツール統合
10. セキュリティとベストプラクティス
11. トラブルシューティング
12. 実践プロジェクト

質問や感想は [@nqounet](https://x.com/nqounet) までお気軽にどうぞ！
