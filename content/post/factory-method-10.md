---
title: "第10回-これがFactory Methodパターンだ！ - PerlとMooでレポートジェネレーターを作ってみよう"
draft: true
tags:
  - perl
  - moo
  - design-patterns
  - factory-method
description: "実は作ってきたものが「Factory Methodパターン」でした！GoFデザインパターンの生成パターンを学び、Strategyパターンとの違いも解説します。"
---

[@nqounet](https://x.com/nqounet)です。

## 前回の振り返り

前回は、レポートジェネレーターを完成させました。

- 月次・週次・日次・四半期の4種類のレポートに対応
- `ReportRole`で共通のインターフェースを定義
- `ReportGenerator`基底クラスで共通処理を実装
- 各ジェネレーターは`create_report`をオーバーライドするだけ

{{< linkcard "https://www.nqou.net/2021/10/31/191008/" >}}

## 今回の目標

今回は最終回として、これまで作ってきたものが「Factory Methodパターン」というデザインパターンだったことを明かします。

具体的には、以下のことを行います。

- Factory Methodパターンの定義と構造を学ぶ
- 作ってきたレポートジェネレーターとの対応を確認する
- Strategyパターンとの違いを理解する

## Factory Methodパターンとは

**Factory Methodパターン**は、GoF（Gang of Four）が定義した23のデザインパターンの1つで、「生成パターン」に分類されます。

**定義**

> オブジェクトを生成するためのインターフェースを定義し、どのクラスをインスタンス化するかはサブクラスに決定させる。

シンプルに言うと、「何を作るかはサブクラスに任せる」パターンです。

## パターンの構造

Factory Methodパターンは、以下の4つの要素で構成されます。

```
┌─────────────────────────────────────────────────────────┐
│ 用語                 │ 役割                             │
├──────────────────────┼──────────────────────────────────┤
│ Product              │ 生成されるオブジェクトの         │
│                      │ インターフェース                 │
├──────────────────────┼──────────────────────────────────┤
│ ConcreteProduct      │ Productを実装した具体クラス      │
├──────────────────────┼──────────────────────────────────┤
│ Creator              │ ファクトリメソッドを宣言する     │
│                      │ 抽象クラス                       │
├──────────────────────┼──────────────────────────────────┤
│ ConcreteCreator      │ ファクトリメソッドを実装し、     │
│                      │ ConcreteProductを返すサブクラス  │
└─────────────────────────────────────────────────────────┘
```

### コード例1: レポートジェネレーターとの対応

作ってきたレポートジェネレーターは、まさにFactory Methodパターンでした！

```
┌─────────────────────────────────────────────────────────┐
│ パターン要素         │ レポートジェネレーターでの実装   │
├──────────────────────┼──────────────────────────────────┤
│ Product              │ ReportRole                       │
│                      │ (requires 'generate')            │
├──────────────────────┼──────────────────────────────────┤
│ ConcreteProduct      │ MonthlyReport, WeeklyReport,     │
│                      │ DailyReport, QuarterlyReport     │
├──────────────────────┼──────────────────────────────────┤
│ Creator              │ ReportGenerator                  │
│                      │ (create_report()を宣言)          │
├──────────────────────┼──────────────────────────────────┤
│ ConcreteCreator      │ MonthlyReportGenerator,          │
│                      │ WeeklyReportGenerator,           │
│                      │ DailyReportGenerator,            │
│                      │ QuarterlyReportGenerator         │
├──────────────────────┼──────────────────────────────────┤
│ Factory Method       │ create_report()                  │
└─────────────────────────────────────────────────────────┘
```

図にすると以下のようになります。

```
        ┌────────────────┐              ┌────────────────┐
        │ ReportGenerator │              │   ReportRole   │
        │   (Creator)    │              │   (Product)    │
        ├────────────────┤              ├────────────────┤
        │create_report() │─creates──▶   │ generate()     │
        │generate_and_*()│              │ get_period()   │
        └───────▲────────┘              └───────▲────────┘
                │                               │
        ┌───────┴───────┐               ┌───────┴───────┐
        │               │               │               │
┌───────┴───────┐ ┌─────┴─────┐ ┌───────┴───────┐ ┌─────┴─────┐
│MonthlyReport  │ │WeeklyReport│ │MonthlyReport  │ │WeeklyReport│
│Generator      │ │Generator   │ │               │ │            │
│(Concrete      │ │(Concrete   │ │(Concrete      │ │(Concrete   │
│ Creator)      │ │ Creator)   │ │ Product)      │ │ Product)   │
└───────────────┘ └────────────┘ └───────────────┘ └────────────┘
```

私たちは、デザインパターンを知らずに、自然とFactory Methodパターンを実装していたのです！

## Factory Methodパターンのメリット

このパターンには、以下のメリットがあります。

**1. 疎結合（Loose Coupling）**

CreatorはProductの具体的なクラスを知らなくてよい。`ReportGenerator`は`MonthlyReport`などの具体クラスを直接参照していません。

**2. 開放閉鎖原則（OCP）への準拠**

新しいProductを追加するとき、既存のコードを修正する必要がない。第8回で四半期レポートを追加したときに体験しました。

**3. 単一責任の原則（SRP）**

各ConcreteCreatorは、自分が担当するProductの生成だけに責任を持つ。

## Strategyパターンとの違い

「Mooを使ってディスパッチャーを作ってみよう」シリーズで学んだStrategyパターンとの違いを見てみましょう。

{{< linkcard "https://www.nqou.net/2026/01/03/001541/" >}}

### コード例2: 2つのパターンの比較

```
┌─────────────────────────────────────────────────────────┐
│ 項目           │ Strategyパターン │ Factory Methodパターン │
├────────────────┼──────────────────┼───────────────────────┤
│ パターン分類   │ 振る舞いパターン │ 生成パターン           │
├────────────────┼──────────────────┼───────────────────────┤
│ 主な関心       │ 処理の切り替え   │ オブジェクトの生成     │
├────────────────┼──────────────────┼───────────────────────┤
│ 焦点           │「どう処理するか」│「何を作るか」          │
├────────────────┼──────────────────┼───────────────────────┤
│ 実現方法       │ 委譲（has+Role） │ 継承（extends）        │
├────────────────┼──────────────────┼───────────────────────┤
│ 切り替えの     │ 実行時に可能     │ クラス定義時に決定     │
│ タイミング     │                  │                        │
├────────────────┼──────────────────┼───────────────────────┤
│ 例             │ ディスパッチャー │ レポートジェネレーター │
│                │ （ルートを切替） │ （レポートを生成）     │
└─────────────────────────────────────────────────────────┘
```

**Strategyパターン（ディスパッチャー）**

```perl
# 委譲: hasで戦略を持つ
has handler => (
    is   => 'ro',
    does => 'HandlerRole',
);

# 処理を委譲する
sub dispatch ($self) {
    $self->handler->handle();
}
```

**Factory Methodパターン（レポートジェネレーター）**

```perl
# 継承: extendsで派生
extends 'ReportGenerator';

# 生成処理をオーバーライド
sub create_report ($self, $title) {
    return MonthlyReport->new(title => $title);
}
```

どちらも有用なパターンですが、解決する問題が異なります。

- **Strategy**: 「どのように処理するか」を切り替えたい
- **Factory Method**: 「何を作るか」をサブクラスに任せたい

## Factory Methodパターンを使うべき場面

このパターンは、以下のような場面で有効です。

1. **生成すべきオブジェクトのクラスを事前に決められない場合**
   - ユーザー入力や設定に応じて生成するクラスが変わる

2. **サブクラスに生成するオブジェクトを決定させたい場合**
   - フレームワークがスケルトンを提供し、ユーザーがカスタマイズ

3. **オブジェクト生成のロジックをカプセル化したい場合**
   - 生成ロジックの変更がシステム全体に影響しない

## 他の生成パターンへの展望

Factory Methodパターンは、GoFの「生成パターン」の1つです。他にも以下のパターンがあります。

| パターン名 | 概要 |
|-----------|------|
| **Abstract Factory** | 関連するオブジェクト群を、具体クラスを指定せずに生成 |
| **Builder** | 複雑なオブジェクトを段階的に構築 |
| **Prototype** | 既存オブジェクトをコピーして新しいオブジェクトを生成 |
| **Singleton** | クラスのインスタンスが1つだけであることを保証 |

興味があれば、これらのパターンも学んでみてください。

## シリーズのまとめ

全10回を通じて、以下のことを学びました。

**オブジェクト指向の原則**

- 継承（`extends`）とオーバーライド
- インターフェース（`Moo::Role`と`requires`）
- 型チェック（`does`）
- 開放閉鎖原則（OCP）

**Factory Methodパターン**

- Creator（ReportGenerator）が「生成の骨格」を定義
- ConcreteCreator（各ジェネレーター）が「具体的な生成」を実装
- Product（ReportRole）が「生成されるもののインターフェース」を定義
- ConcreteProduct（各レポート）が「具体的な製品」を実装

**設計の改善プロセス**

- if/elseの肥大化問題に直面
- 継承で解決
- 自然とデザインパターンに到達

デザインパターンは、難しい理論から始めるのではなく、実際の問題を解決する中で自然と身についていくものです。

## おわりに

「PerlとMooでレポートジェネレーターを作ってみよう」シリーズ、いかがでしたでしょうか。

最初は単純な月次レポートの生成から始まり、新しい要望に対応する中で、自然とFactory Methodパターンにたどり着きました。

デザインパターンは「目的」ではなく「手段」です。問題を解決するために使うものであり、パターンのためにパターンを使うものではありません。

今後も実際のコードを書く中で、「あ、これはあのパターンだ」と気づく瞬間があるはずです。そのとき、このシリーズで学んだことが役に立てば幸いです。

最後までお読みいただき、ありがとうございました！

## 関連シリーズ

オブジェクト指向の基礎を学びたい方は、以下のシリーズもご覧ください。

{{< linkcard "https://www.nqou.net/2021/10/31/191008/" >}}

Strategyパターンについては、以下のシリーズで詳しく解説しています。

{{< linkcard "https://www.nqou.net/2026/01/03/001541/" >}}
