---
date: 2026-02-01T13:30:00+09:00
description: 'Interpreter × Visitor × Composite パターン組み合わせシリーズの調査ドキュメント - 正規表現リファインリーを題材に'
draft: false
epoch: 1769920200
image: /favicon.png
iso8601: 2026-02-01T13:30:00+09:00
tags:
  - design-patterns
  - interpreter-pattern
  - visitor-pattern
  - composite-pattern
  - perl
  - moo
  - regex
title: Interpreter × Visitor × Composite 組み合わせシリーズ調査
---

# Interpreter × Visitor × Composite 組み合わせシリーズ調査ドキュメント

## 調査目的

3つのデザインパターン（Interpreter、Visitor、Composite）を組み合わせたシリーズ記事作成のための調査を行う。

- **調査対象**: 3パターンの相乗効果、適切な題材選定
- **想定読者**: 「デザインパターン学習シリーズ」読了済みだが、まだパターンを使いこなせない人
- **調査実施日**: 2026年2月1日

---

## 1. 3パターンの相乗効果

### 1.1 パターン間の関係

**要点**:

3パターンは「抽象構文木（AST）」という共通構造を通じて自然に連携する。

| パターン | 役割 | AST での位置づけ |
|---------|------|-----------------|
| **Composite** | ツリー構造の表現 | AST ノードの階層構造を定義 |
| **Interpreter** | ツリーの評価・実行 | ノードごとに `evaluate()` を実行 |
| **Visitor** | ツリーへの操作追加 | ノードを変更せず新操作を追加 |

**根拠**:

- GoF書籍でも、InterpreterパターンはCompositeパターンの特殊化として説明される
- VisitorパターンはComposite構造に対する典型的な適用先
- コンパイラ設計では3パターンの組み合わせが標準的

**信頼度**: 10/10

---

### 1.2 典型的な連携パターン

```
┌─────────────────────────────────────────────────────────┐
│                      Client                              │
│  1. パーサーで入力を解析                                │
│  2. Composite構造（AST）を構築                           │
│  3. Interpreterで評価 または Visitorで操作              │
└─────────────────────────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────┐
│              AST（Composite構造）                        │
│  ┌─────┐                                                │
│  │Root │                                                │
│  └──┬──┘                                                │
│     ├── Leaf1                                           │
│     └── Composite1                                       │
│           ├── Leaf2                                      │
│           └── Leaf3                                      │
└─────────────────────────────────────────────────────────┘
                           │
              ┌────────────┴────────────┐
              ▼                         ▼
┌─────────────────────────┐ ┌─────────────────────────────┐
│     Interpreter         │ │        Visitor              │
│  各ノードの evaluate()  │ │  複数の操作を外部から追加  │
│  - 値の計算             │ │  - 可視化                   │
│  - 条件の判定           │ │  - 変換                     │
│  - アクションの実行     │ │  - 最適化                   │
└─────────────────────────┘ └─────────────────────────────┘
```

---

## 2. 題材選定の調査

### 2.1 既存シリーズで使用済みの題材（避けるべき）

| シリーズ | 題材 | パターン |
|---------|------|---------|
| ダイス言語インタプリタ | TRPG ダイス記法 | Interpreter |
| ドキュメント変換ツール | Markdown 要素 | Visitor |
| Markdown 目次生成器 | 見出し階層 | Composite |
| ウイスキーテイスティングカード | ウイスキー香味 | Flyweight + Prototype + Abstract Factory |
| ウイスキー香味プロファイル | ウイスキー | Factory Method + Strategy |
| ウイスキーテイスティングノート | ウイスキー | Bridge + Adapter + Proxy |

### 2.2 候補題材の評価

| 題材 | 3パターンとの適合性 | 実用性 | 独自性 | 難易度 |
|------|---------------------|--------|--------|--------|
| **正規表現リファインリー** | ◎ | ◎ | ◎ | 中〜高 |
| GitHub トレンド予測 DSL | ○ | ○ | ◎ | 高 |
| テストシナリオ言語 | ○ | ◎ | ○ | 高 |
| 数式計算機 | ◎ | △ | △ | 低 |
| SQL サブセット | ◎ | ○ | △ | 高 |

### 2.3 推奨題材: 正規表現リファインリー（RegexRefinery）

**選定理由**:

1. **3パターンの必然性が高い**
   - Composite: 正規表現の構造（連結、選択、繰り返し、グループ）がツリー
   - Interpreter: マッチング実行、ステップ実行デバッグ
   - Visitor: 可視化、最適化、変換など複数操作

2. **実用性**
   - 全エンジニアが正規表現を使う
   - 「読めない正規表現」問題は普遍的
   - 完成品がポートフォリオになる

3. **独自性**
   - 「他人のコードを添削する」という生意気さ
   - Perl の正規表現エンジンへの深い理解
   - 既存シリーズと完全に異なるドメイン

4. **学習効果**
   - AST の概念を視覚的に理解できる
   - パターンの組み合わせ効果を実感
   - 言語処理の基礎を学べる

---

## 3. 正規表現リファインリーの技術調査

### 3.1 対応する正規表現機能（スコープ）

**基本機能（実装必須）**:

| 機能 | 記法 | AST ノード |
|------|------|-----------|
| リテラル文字 | `a`, `b`, `\n` | Literal |
| 連結 | `ab` | Concatenation |
| 選択 | `a|b` | Alternation |
| 繰り返し（0以上） | `a*` | Star |
| 繰り返し（1以上） | `a+` | Plus |
| オプション | `a?` | Optional |
| グループ | `(ab)` | Group |
| 文字クラス | `[abc]` | CharacterClass |

**拡張機能（オプション）**:

- ワイルドカード `.`
- アンカー `^`, `$`
- 量指定子 `{n,m}`
- 否定文字クラス `[^abc]`

### 3.2 パーサー実装アプローチ

**再帰下降パーサー（推奨）**:

```
regex     → alternation
alternation → concatenation ('|' concatenation)*
concatenation → repetition+
repetition → atom ('*' | '+' | '?')?
atom      → '(' alternation ')' | '[' charclass ']' | literal
```

**実装上の注意点**:

1. メタキャラクターのエスケープ（`\*`, `\+` など）
2. 演算子の優先順位（繰り返し > 連結 > 選択）
3. 空文字列の扱い
4. エラー処理（不正な正規表現）

### 3.3 Visitor 操作の設計

| Visitor | 役割 | 出力 |
|---------|------|------|
| **PrettyPrinter** | 可読化 | インデント付き展開形式 |
| **Optimizer** | 最適化 | 効率的な等価正規表現 |
| **RailroadDiagram** | 可視化 | ASCII アート図 |
| **Matcher** | マッチング | 真偽値 + マッチ情報 |

---

## 4. シリーズ構成案

### 4.1 ストーリーライン

```
動く（ベタ書き）
  ↓
破綻（機能追加で if/else 爆発）
  ↓
Composite 導入（AST 構築）
  ↓
Interpreter 導入（評価）
  ↓
新機能追加の壁（クラス修正必要）
  ↓
Visitor 導入（操作追加）
  ↓
完成
```

### 4.2 章構成（統合版）

| 章 | タイトル | 新概念 | コード例 |
|---|---------|--------|---------|
| 1 | 正規表現を解読してみよう | 基本構造 | ベタ書きパーサー |
| 2 | 複雑な正規表現で破綻 | if/else 問題 | 破綻コード |
| 3 | 正規表現をツリーで表す | Composite | AST ノードクラス |
| 4 | ツリーを歩いてマッチング | Interpreter | evaluate メソッド |
| 5 | 可視化機能を追加したい | OCP 問題 | 問題分析 |
| 6 | 操作をクラスに分離 | Visitor | PrettyPrinter |
| 7 | 最適化と変換も追加 | 複数 Visitor | Optimizer |
| 8 | 3パターンで完成！ | 統合 | 完成コード |

---

## 5. 参考資料

### 5.1 正規表現パーサー実装

- Thompson's construction algorithm
- 再帰下降パーサーの実装パターン
- Perl の正規表現内部構造（re モジュール）

### 5.2 デザインパターン

- GoF「Design Patterns」第5章（Interpreter）
- GoF「Design Patterns」第4章（Composite, Visitor）
- 「Refactoring.Guru」各パターン解説

**信頼度**: 9/10

---

## 6. 競合分析

### 6.1 既存の正規表現可視化ツール

| ツール | 特徴 | 差別化ポイント |
|--------|------|----------------|
| Regex101 | Web ベース、詳細解説 | CLI + Perl ネイティブ |
| Regexper | 鉄道図生成 | 複数出力形式対応 |
| Debuggex | ステップ実行 | 学習教材としての構造 |

### 6.2 本シリーズの独自価値

1. **Perl ネイティブ**: Perl の正規表現を Perl で解析する一貫性
2. **デザインパターン学習**: ツール作成がパターン学習の手段
3. **拡張性**: Visitor 追加で自分だけの機能を追加可能
4. **オフライン動作**: CLI ツールとしてローカルで使用

---

## 調査結論

**推奨題材**: 正規表現リファインリー（RegexRefinery）

**USP（独自の価値提案）**:

- 「他人の正規表現を添削できる」という生意気なツール
- 3パターンの必然的な連携を体感できる最適な題材
- 完成品は実務で使える実用ツール
- Perl の正規表現エンジンへの深い理解が得られる

**作成日**: 2026年2月1日  
**担当エージェント**: GitHub Copilot
