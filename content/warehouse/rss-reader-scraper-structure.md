---
date: 2025-12-31T10:51:44+09:00
description: シリーズ記事「RSSリーダー / ニューススクレイパーで自然に覚えるデザインパターン」（全12回）の連載構造案3つ（案A/B/C）
draft: true
title: '連載構造案 - RSSリーダー / ニューススクレイパーで自然に覚えるデザインパターン（全12回）'
---

# 連載構造案：RSSリーダー / ニューススクレイパーで自然に覚えるデザインパターン

**調査結果**: `content/warehouse/rss-reader-scraper-research.md` に基づく

## 前提情報

### シリーズ概要

- **タイトル**: RSSリーダー / ニューススクレイパーで自然に覚えるデザインパターン
- **全回数**: 12回
- **技術スタック**: Perl / Moo / XML::LibXML / Web::Query / LWP::UserAgent
- **想定読者**: Perl入学式卒業程度、「Mooで覚えるオブジェクト指向プログラミング」シリーズ読了者
- **学習目標**: デザインパターン（Strategy, Adapter, Factory, Template Method）を自然に身につける
- **位置づけ**: 「Mooで覚えるオブジェクト指向プログラミング」シリーズ（全12回）の発展編

### ストーリー背景

お気に入りのWebサイトの新着情報をまとめて取得したい。ブログはRSSを提供しているし、ニュースサイトにはAtomフィードがある。でもRSSを提供していないサイトもある。こうした様々なソースから統一的に情報を取得するツールを作る過程で、複数のフォーマットに対応する必要性に直面し、自然とデザインパターンを身につけていく。

### 制約

- トーンは前シリーズと同じ入門者向けの優しい感じ
- 毎回コード例は2つまで
- 新しい概念は1記事あたり1つまで
- 図解を含めたわかりやすさを目指す
- ゆっくりと、少しずつ、手を動かして実行しているうちに「あー、こういうことだったのか」と理解できるようなシリーズ

### 前シリーズで学習済みの概念

- `has`と`sub`でクラスを定義
- `new`でオブジェクト生成
- `is => 'ro'/'rw'`でアクセス制御
- `required`と`default`
- カプセル化
- 複数クラスの連携
- `extends`による継承
- オーバーライド
- `Moo::Role`と`with`によるロール
- `handles`による委譲
- `isa`による型制約

### 主要な技術選択（調査結果より）

| 用途 | モジュール | 選定理由 |
|-----|-----------|---------|
| XMLパース | XML::LibXML | XPath対応、高速、堅牢 |
| スクレイピング | Web::Query | jQueryライク、簡潔 |
| OOP | Moo | 前シリーズからの継続 |
| HTTP通信 | LWP::UserAgent | 高機能、信頼性 |

---

## 案A：「機能追加駆動」アプローチ

### 特徴・アプローチ

シンプルなRSSリーダーから始めて、「こういう機能も欲しい」「このサイトにも対応したい」という要望に応えながら機能を追加していくアプローチ。機能追加のたびに設計上の課題にぶつかり、その解決策としてデザインパターンを導入します。

### メリット

- **実践的な動機付け**: 「こういうことがしたい」という具体的なニーズから学べる
- **段階的な成長**: 小さなツールが徐々に本格的なアプリケーションに育つ達成感
- **再利用性の実感**: 新しいソースを追加するたびに既存コードが活きる体験

### デメリット

- **後半で設計の大幅変更**: 前半で作ったコードを後半で作り直す必要が生じる可能性
- **パターンの理論的理解が薄くなりがち**: 「動けばいい」になりやすい

### デメリットへの対策

- **設計変更への対策**: 第1回で完成イメージを見せ、「ここを目指す」と明示。各回で小さなリファクタリングを行い、最後の大きな変更を軽減
- **理論的理解への対策**: 第12回でパターンの体系的な解説を行い、「実は名前がついていた」ことを明かす

### 連載構造

| 回 | タイトル | 新しい概念 | ストーリー | コード例1 | コード例2 | 推奨タグ |
|---|---------|-----------|-----------|----------|----------|---------|
| 1 | 第1回-RSSフィードを取得してみよう | LWP::UserAgentによるHTTP取得 | 毎日チェックしているブログの新着記事を自動で取得したい。まずはRSSフィードをダウンロードする | LWP::UserAgentでRSSフィードを取得 | レスポンスの内容を表示 | perl, lwp, http |
| 2 | 第2回-XMLを読み解こう | XML::LibXMLによるXMLパース | ダウンロードしたRSSフィードの中身を解析して、記事のタイトルとリンクを取り出す | XML::LibXMLでXMLをパース | findnodesでitem要素を取得 | perl, xml-libxml, rss |
| 3 | 第3回-XPathで欲しい情報を探す | XPathによるノード検索 | もっと効率的に目的の要素を見つける方法。XPathクエリでピンポイントに情報を取得 | XPathでtitleを取得 | XPathでlinkとpubDateを取得 | perl, xpath, xml |
| 4 | 第4回-RSSパーサをクラスにしよう | パーサクラスの設計（Template Method的構造） | 取得とパースの処理をRssParserクラスにまとめる。共通の処理フローを定義 | RssParserクラスの定義 | fetch→parse→transformの共通フロー | perl, moo, class-design |
| 5 | 第5回-Atomフィードにも対応したい | ロールによる共通インターフェース | 別のサイトはAtomフィードを使っている。共通のルールを決めてパーサを追加する準備 | FeedParser::Roleの定義 | requires 'parse'で共通インターフェース | perl, moo-role, interface |
| 6 | 第6回-パーサを切り替える仕組み | Strategyパターン | RSS用とAtom用のパーサを切り替える仕組みを実装。フィード形式によって戦略を変える | AtomParserクラスの追加 | Contextクラスでパーサを切り替え | perl, strategy-pattern, design-patterns |
| 7 | 第7回-RSSを提供していないサイトはスクレイピングで | Web::Queryによるスクレイピング | RSSがないサイトはHTMLから直接情報を取得。Web::QueryでjQueryライクにスクレイピング | Web::Queryでページを取得 | findでリンクとタイトルを抽出 | perl, web-query, scraping |
| 8 | 第8回-スクレイピングもパーサの仲間に | Adapterパターン | スクレイピング結果をRSS/Atomパーサと同じインターフェースで扱えるようにする | ScraperAdapterクラスの実装 | 統一インターフェースでの呼び出し | perl, adapter-pattern, design-patterns |
| 9 | 第9回-パーサを自動で選ぶ仕組み | Factoryパターン | URLやフィード内容から適切なパーサを自動で選択・生成する仕組みを作る | ParserFactoryクラスの実装 | create_parserメソッドで自動選択 | perl, factory-pattern, design-patterns |
| 10 | 第10回-フィード一覧を設定ファイルで管理 | 設定ファイルの読み込み | チェックするフィードのリストを設定ファイル（YAML）で管理できるようにする | YAMLで設定ファイルを作成 | 設定を読み込んで複数フィードを処理 | perl, yaml, configuration |
| 11 | 第11回-定期的に新着をチェックしよう | cronによる定期実行 | 手動実行ではなく、定期的に自動でフィードをチェックする仕組みを設定 | cronの設定方法 | ログ出力の追加 | perl, cron, automation |
| 12 | 第12回-デザインパターンの振り返り | まとめとパターンの体系化 | 作ってきたツールを振り返り、使ったデザインパターンの名前と意義を確認 | Strategy/Adapter/Factory/Template Methodの図解 | 次に学ぶべきパターンへの展望 | perl, design-patterns, architecture |

### 差別化ポイント

- **ニーズ駆動**: 「〜したい」という具体的な欲求から始まるため、動機付けが明確
- **実用的な成果物**: 連載終了後に実際に使えるRSSリーダーが手元に残る
- **漸進的な複雑化**: 最初はシンプル、徐々に本格的なアプリケーションへ

---

## 案B：「パターン学習優先」アプローチ

### 特徴・アプローチ

デザインパターンの学習を主軸に据え、RSSリーダーはそのパターンを実践する「題材」として位置づけるアプローチ。各回で1つのパターンを取り上げ、そのパターンがRSSリーダーでどう活きるかを示します。

### メリット

- **パターンの体系的理解**: 各パターンの意義と構造を明確に学べる
- **再現性**: 他のプロジェクトでもパターンを応用しやすい
- **GoFパターンへの橋渡し**: パターンの名前と概念を先に学ぶため、参考書籍との接続がスムーズ

### デメリット

- **抽象的な導入**: パターンの説明から始まると入門者には敷居が高い
- **実装より理論先行**: 「なぜそのパターンが必要か」の実感が薄くなる可能性
- **RSSリーダーとしての一体感が薄い**: パターンの解説に偏りがち

### デメリットへの対策

- **抽象的な導入への対策**: 各パターンを日常生活の例え（レストランのメニュー、家電のアダプタなど）で導入
- **理論先行への対策**: 必ず具体的なコード例で「こう使う」を見せる
- **一体感への対策**: 第1回で完成イメージを見せ、全体のつながりを意識させる

### 連載構造

| 回 | タイトル | 新しい概念 | ストーリー | コード例1 | コード例2 | 推奨タグ |
|---|---------|-----------|-----------|----------|----------|---------|
| 1 | 第1回-デザインパターンでRSSリーダーを作ろう | デザインパターンの概要 | 先人の知恵「デザインパターン」を活用してRSSリーダーを作る。完成イメージと学ぶパターンの紹介 | 完成イメージのコード骨格 | 4つのパターンの概要図 | perl, design-patterns, introduction |
| 2 | 第2回-まずはRSSフィードを取得しよう | LWP::UserAgentによるHTTP取得 | RSSリーダーの基礎。HTTPでフィードを取得し、XMLをパースする土台を作る | LWP::UserAgentでの取得 | XML::LibXMLでのパース | perl, lwp, xml-libxml |
| 3 | 第3回-XPathでデータを抽出しよう | XPathによるノード検索 | XML内の情報を効率的に取得する方法。RSS 2.0の構造を理解する | RSS 2.0のXPath | 記事データの抽出 | perl, xpath, rss |
| 4 | 第4回-Template Methodパターン入門 | Template Methodパターン | パース処理の「共通の流れ」を定義する。取得→解析→変換の骨格を作る | 親クラスでの骨格定義 | サブクラスでの具体的実装 | perl, template-method, design-patterns |
| 5 | 第5回-Strategyパターン入門 | Strategyパターン | RSS用とAtom用の「戦略」を切り替える。アルゴリズムをカプセル化 | RssStrategyクラス | AtomStrategyクラス | perl, strategy-pattern, design-patterns |
| 6 | 第6回-Strategyパターンの実装 | Contextクラスの設計 | 戦略を保持するContextを実装。フィード形式に応じた切り替え | FeedReaderContext | 動的なStrategy切り替え | perl, moo, context |
| 7 | 第7回-Adapterパターン入門 | Adapterパターン | 異なるインターフェースを統一する。家電のアダプタのようなもの | Adapterパターンの構造 | インターフェースの統一 | perl, adapter-pattern, design-patterns |
| 8 | 第8回-スクレイピングをAdapterで統合 | Web::Queryとアダプタ実装 | RSSがないサイトをスクレイピングで取得し、Adapterで他と同じ形式に変換 | Web::Queryでスクレイピング | ScraperAdapterの実装 | perl, web-query, adapter |
| 9 | 第9回-Factoryパターン入門 | Factoryパターン | パーサの生成を一箇所に集約。どのパーサを使うかの判断をFactoryに任せる | ParserFactoryクラス | フィード形式の自動判定 | perl, factory-pattern, design-patterns |
| 10 | 第10回-設定駆動で複数フィードに対応 | 設定ファイルの読み込み | YAMLで複数のフィードを管理。設定に基づいてFactoryがパーサを生成 | YAML設定ファイル | 設定からの一括処理 | perl, yaml, configuration |
| 11 | 第11回-定期実行と出力フォーマット | cronと出力の選択 | 定期実行の設定と、ターミナル/HTMLでの出力切り替え（Strategyの応用） | cronの設定 | 出力フォーマットStrategy | perl, cron, output |
| 12 | 第12回-4つのパターンを振り返る | まとめと発展 | 学んだ4つのパターンの関係性を整理し、次に学ぶべきパターンを紹介 | パターン関係図 | 発展的な学習リソース | perl, design-patterns, architecture |

### 差別化ポイント

- **パターン中心**: デザインパターンの学習が主目的として明確
- **体系的な理解**: 各パターンの構造と役割を順序立てて学ぶ
- **汎用性**: RSSリーダー以外のプロジェクトにも応用しやすい知識が身につく

---

## 案C：「問題解決駆動」アプローチ

### 特徴・アプローチ

各回で「困った状況」を提示し、それをオブジェクト指向とデザインパターンで解決する形式。前シリーズ（Mooで覚えるOOP）と同じアプローチを継続し、読者に「確かにこれは便利だ！」と納得してもらいながら進める構成です。

### メリット

- **動機付けが明確**: 問題を体験してから解決策を学ぶため、「なぜ必要か」が実感できる
- **記憶に残りやすい**: 問題→解決のストーリーで学習内容が定着
- **前シリーズとの連続性**: 同じアプローチで学習スタイルに一貫性がある
- **実践的**: 実務でも「問題→解決」の流れでコードを改善することが多い

### デメリット

- **毎回「悪い例」を示す必要**: コード例が冗長になる可能性
- **前半が地味になりがち**: 問題提示に時間を使うため、解決策の実装量が減る

### デメリットへの対策

- **冗長さへの対策**: 悪い例は最小限にし、「こうなってしまう」を簡潔に示す
- **前半の地味さへの対策**: 問題の提示を「クイズ形式」や「読者への問いかけ」にして能動的な参加を促す

### 連載構造

| 回 | タイトル | 新しい概念 | ストーリー | コード例1 | コード例2 | 推奨タグ |
|---|---------|-----------|-----------|----------|----------|---------|
| 1 | 第1回-お気に入りサイトの新着が知りたい | LWP::UserAgentによるHTTP取得 | 毎日複数のサイトを巡回するのが面倒。RSSフィードを自動取得してまとめて見たい | LWP::UserAgentでフィード取得 | 取得したXMLを表示 | perl, lwp, http |
| 2 | 第2回-XMLを解読できない問題 | XML::LibXMLによるXMLパース | 取得したXMLを見ても何が何だかわからない。構造化データとしてパースしよう | XML::LibXMLでDOMを構築 | 要素の取得と表示 | perl, xml-libxml, parsing |
| 3 | 第3回-欲しい情報が見つからない問題 | XPathによるノード検索 | titleやlinkを取り出すのに何行もコードが必要。XPathで一発検索 | findnodesでの基本検索 | findvalueで値を直接取得 | perl, xpath, xml |
| 4 | 第4回-コードがごちゃごちゃ問題 | パーサクラスの設計（Template Method的構造） | 取得、パース、表示が混ざってわかりにくい。処理の流れを整理してクラスにまとめる | RssParserクラスの作成 | fetch→parse→transformの共通フロー | perl, moo, class-design |
| 5 | 第5回-Atomフィードが読めない問題 | ロールによる共通インターフェース | 別のサイトのAtomフィードが既存のパーサで読めない。共通ルールを決めて拡張準備 | FeedParser::Roleの定義 | requires 'parse'の設定 | perl, moo-role, interface |
| 6 | 第6回-if/elseだらけで見通しが悪い問題 | Strategyパターン | RSS/Atomの判定でif/elseが増えすぎ。パーサを戦略として切り替える仕組みに | AtomParserの追加 | ContextでのStrategy切り替え | perl, strategy-pattern, design-patterns |
| 7 | 第7回-RSSがないサイトに対応できない問題 | Web::Queryによるスクレイピング | お気に入りのニュースサイトがRSSを提供していない。HTMLから直接スクレイピング | Web::QueryでHTMLパース | CSSセレクタで要素抽出 | perl, web-query, scraping |
| 8 | 第8回-スクレイピング結果の形式が違う問題 | Adapterパターン | スクレイピング結果がRSS/Atomパーサと別形式で扱いにくい。Adapterで統一 | ScraperAdapterの実装 | 統一インターフェースで呼び出し | perl, adapter-pattern, design-patterns |
| 9 | 第9回-毎回パーサを選ぶのが面倒な問題 | Factoryパターン | どのパーサを使うか毎回判断するのが面倒。URLや内容から自動で選ぶ仕組みを作る | ParserFactoryクラス | create_parserメソッド | perl, factory-pattern, design-patterns |
| 10 | 第10回-フィードURLをハードコードする問題 | 設定ファイルの読み込み | フィードリストをコードに書くと変更のたびに編集が必要。設定ファイルで外部化 | YAML設定ファイルの作成 | YAML::XSで読み込み | perl, yaml, configuration |
| 11 | 第11回-毎回手動で実行する問題 | cronによる定期実行 | 毎日コマンドを実行するのを忘れる。cronで自動実行してログに記録 | crontabの設定 | ログ出力と日時記録 | perl, cron, automation |
| 12 | 第12回-気づけばデザインパターンだった | まとめとパターンの振り返り | 問題を解決してきた方法がデザインパターンだったことを知る。パターンの関係性を図解 | 4パターンの構造図（Strategy/Adapter/Factory/Template Method） | 次に学ぶべきパターン紹介 | perl, design-patterns, architecture |

### 差別化ポイント

- **問題ファースト**: 毎回「こういう困りごとがある」から始まる
- **前シリーズとの一貫性**: 「Mooで覚えるOOP」と同じ学習スタイル
- **実感のある学習**: パターンの必要性を体験してから名前を知る流れ

---

## 推薦案：案C「問題解決駆動」アプローチ

### 推薦理由

#### 1. 前シリーズとの連続性

「Mooで覚えるオブジェクト指向プログラミング」シリーズは案C「問題解決駆動」アプローチで12回構成されており、読者は既にこの学習スタイルに慣れています。同じアプローチを継続することで、スムーズに新シリーズに入れます。

#### 2. ペルソナとの適合性

想定読者は「Perl入学式卒業程度」「Mooシリーズ読了者」であり、デザインパターンについては初学者です。抽象的なパターンの説明よりも、「こういう問題がある→こう解決する」という具体的な流れのほうが理解しやすいです。

#### 3. 「気づき」の演出

第12回で「実はこれがデザインパターンだった！」と明かす構成は、読者に発見の喜びを与えます。「教わった」のではなく「自分で辿り着いた」という感覚が記憶に残りやすいです。

#### 4. 動機付けの明確さ

毎回「〜問題」という形で課題を提示するため、その回で学ぶ内容の価値がすぐに理解できます。「なぜこれを学ぶのか」が常に明確です。

#### 5. 実務への橋渡し

実際のソフトウェア開発でも「問題に遭遇→解決策を模索→パターンを発見」という流れが多いため、実践的な思考力が身につきます。

### 代替案の選択指針

- **案A**: 機能追加のワクワク感を優先したい場合。読者が「自分でもこういうツールを作りたい」と思えるストーリー重視
- **案B**: デザインパターンの体系的学習を優先したい場合。GoFの本への橋渡しを重視する場合

---

## 3案の比較表

| 項目 | 案A（機能追加駆動） | 案B（パターン学習優先） | 案C（問題解決駆動） |
|-----|-------------------|---------------------|-------------------|
| **アプローチ** | 機能を追加しながら学ぶ | パターンを先に学んで実装 | 問題を解決しながら学ぶ |
| **デザインパターン登場** | 中盤から徐々に | 第1回で概要、各回で詳細 | 最終回で振り返り |
| **動機付けの強さ** | ○ 機能追加の欲求 | △ 理論への関心 | ◎ 問題解決の実感 |
| **入門者の取り組みやすさ** | ◎ 取り組みやすい | △ 最初が抽象的 | ◎ 取り組みやすい |
| **パターンの体系的理解** | △ 後付けになりがち | ◎ 体系的 | ○ 振り返りで整理 |
| **前シリーズとの連続性** | ○ 中程度 | △ アプローチが異なる | ◎ 同じスタイル |
| **成果物の実用性** | ◎ すぐ使える | ○ 使える | ◎ すぐ使える |
| **ストーリー適合度** | ○ 適合 | △ やや理論寄り | ◎ 最適 |

---

## 付記

### 図解の推奨

各回で以下のような図解を含めることを推奨（Mermaidで作成可能）：

#### 第4回: パーサクラスの構造（Template Method的）
```
┌─────────────────────────────────────────┐
│        FeedParser (親クラス)             │
│  ┌─────────────────────────────────┐   │
│  │ + read() ← Template Method       │   │
│  │   1. fetch() - 取得              │   │
│  │   2. parse() - 解析（抽象）       │   │
│  │   3. transform() - 変換          │   │
│  └─────────────────────────────────┘   │
└─────────────────────────────────────────┘
                   │ extends
      ┌────────────┴────────────┐
      ↓                         ↓
┌───────────┐            ┌───────────┐
│ RssParser │            │AtomParser │
│ parse()   │            │ parse()   │
│ を実装     │            │ を実装     │
└───────────┘            └───────────┘
```

#### 第6回: Strategyパターンの構造
```
┌─────────────────────────────────────────┐
│        FeedReader (Context)             │
│  ┌─────────────────────────────────┐   │
│  │ has parser => (Strategy)         │   │
│  └─────────────────────────────────┘   │
│                  │                      │
│                  ↓ read()               │
│           parser->parse()               │
└─────────────────────────────────────────┘
                   │
      ┌────────────┴────────────┐
      ↓                         ↓
┌───────────┐            ┌───────────┐
│ RssParser │            │AtomParser │
│ (Strategy)│            │ (Strategy)│
└───────────┘            └───────────┘
```

#### 第8回: Adapterパターンの構造
```
┌─────────────────┐          ┌─────────────────┐
│  FeedReader     │  uses    │ FeedParser::Role│
│  (Client)       │─────────→│ (Target)        │
└─────────────────┘          │ + parse()       │
                             └────────┬────────┘
                                      │
              ┌───────────────────────┼───────────────────────┐
              │                       │                       │
              ↓                       ↓                       ↓
       ┌───────────┐          ┌───────────┐          ┌─────────────────┐
       │ RssParser │          │AtomParser │          │ ScraperAdapter  │
       └───────────┘          └───────────┘          │   (Adapter)     │
                                                     └────────┬────────┘
                                                              │ wraps
                                                              ↓
                                                     ┌─────────────────┐
                                                     │  Web::Query     │
                                                     │   (Adaptee)     │
                                                     └─────────────────┘
```

#### 第9回: Factoryパターンの構造
```
┌─────────────────────────────────────────┐
│          ParserFactory                  │
│  ┌─────────────────────────────────┐   │
│  │ + create_parser(url) -> Parser   │   │
│  └─────────────────────────────────┘   │
└─────────────────────────────────────────┘
                   │
                   │ creates
                   ↓
      ┌────────────┴────────────┬────────────┐
      ↓                         ↓            ↓
┌───────────┐            ┌───────────┐ ┌─────────────┐
│ RssParser │            │AtomParser │ │ScraperAdapter│
└───────────┘            └───────────┘ └─────────────┘
```

### 前シリーズへのリンク

各回の冒頭で、関連する前シリーズの記事へのリンクを設置することを推奨：

| 本シリーズの回 | 関連する前シリーズの回 | トピック |
|--------------|---------------------|---------|
| 第4回 | 第7回「複数クラスの連携」 | クラスの分割と連携 |
| 第5回 | 第10回「ロール」 | Moo::Roleとwith |
| 第6回 | 第10回「ロール」、第11回「委譲」 | Roleとhandles |
| 第8回 | 第8回「継承入門」 | インターフェースの統一 |

### 調査結果からの引用

本連載構造は以下の調査結果に基づいています：

- **主要モジュール選定**: XML::LibXML（XPath対応、高速）、Web::Query（jQueryライク）、LWP::UserAgent（高機能）
- **デザインパターン**: Strategy、Adapter、Factory、Template Method
- **RSSフィード仕様**: RSS 2.0（`<item>`）、Atom（`<entry>`）の構造差異への対応
- **定期実行**: システムcronを推奨（信頼性、シンプルさ）

### 各回の想定文字数

入門者向けシリーズのため、各回の本文は以下の範囲に収めることを推奨：

- **本文**: 1,500〜2,500文字程度
- **コード例**: 各20〜50行程度（2例合計で40〜100行）
- **図解**: 1〜2点

### 執筆上の注意点

1. **専門用語の初出時は必ず説明する**（例：「XPath（XMLの検索言語）」）
2. **英語の概念は日本語で言い換える**（例：Strategy → 戦略、Adapter → 変換器）
3. **「なぜ」を省略しない**（各改善の理由を必ず述べる）
4. **コードは動作確認済みのものを使用**
5. **毎回冒頭で前回の内容を1-2文で振り返る**
6. **robots.txt遵守やリクエスト間隔など、スクレイピングのマナーを第7回で説明**

---

**作成日**: 2025年12月31日
**レビュー回数**: 3回目（最終版）
**関連ドキュメント**: [調査結果 - RSSリーダー / ニューススクレイパー](/warehouse/rss-reader-scraper-research/)
